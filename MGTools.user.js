// ==UserScript==
// @name         Hua'sMGTools
// @namespace    http://tampermonkey.net/
// @version      1.0.0
// @description  All-in-one assistant for Magic Garden with beautiful unified UI (Enhanced Discord Support!)
// @author       Unified Script
// @updateURL    https://github.com/hua8211/MGTools/raw/refs/heads/main/MGTools.user.js
// @downloadURL  https://github.com/hua8211/MGTools/raw/refs/heads/main/MGTools.user.js
// @match        https://magiccircle.gg/r/*
// @match        https://magicgarden.gg/r/*
// @match        https://starweaver.org/r/*
// @match        https://1227719606223765687.discordsays.com/*
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_addStyle
// @grant        GM_addElement
// @grant        unsafeWindow
// @grant        GM_xmlhttpRequest
// @connect      raw.githubusercontent.com
// @connect      *
// @run-at       document-end
// ==/UserScript==

// --- EARLY RoomConnection trap (captures true scopePath ASAP) ---
(function installEarlyRoomConnectionTrap() {
  const KEY = 'MagicCircle_RoomConnection';
  // CRITICAL: Use the ACTUAL page window, not sandbox
  const targetWin = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;

  if (targetWin.__mg_rc_trap_installed) return;
  targetWin.__mg_rc_trap_installed = true;

  function installHooks(rc) {
    if (!rc || rc.__mg_scope_installed) return;
    rc.__mg_scope_installed = true;

    const setLast = sp => {
      if (Array.isArray(sp)) {
        targetWin.__mga_lastScopePath = sp.slice();
        // Debug only - uncomment if troubleshooting scopePath issues
        // console.log('[MGTools ScopePatch] captured scopePath', targetWin.__mga_lastScopePath);
      }
    };

    const origSend = rc.sendMessage?.bind(rc);
    if (origSend) {
      rc.sendMessage = function (msg) {
        try {
          setLast(msg?.scopePath);
        } catch {}
        return origSend(msg);
      };
    }

    const origDispatch = rc.dispatch?.bind(rc) || rc._dispatch?.bind(rc);
    if (origDispatch) {
      rc.dispatch = function (evt) {
        try {
          setLast(evt?.scopePath);
        } catch {}
        return origDispatch(evt);
      };
    }

    // Debug only - uncomment if troubleshooting scopePath issues
    // console.log('[MGTools ScopePatch] early RC trap installed');
  }

  // Check if RC already exists
  if (targetWin[KEY]) {
    try {
      installHooks(targetWin[KEY]);
    } catch (e) {
      console.warn('[MGTools ScopePatch] install now failed', e);
    }
    return;
  }

  // Set trap for future RC
  let _rc;
  Object.defineProperty(targetWin, KEY, {
    configurable: true,
    enumerable: true,
    get() {
      return _rc;
    },
    set(v) {
      _rc = v;
      try {
        installHooks(v);
      } catch (e) {
        console.warn('[MGTools ScopePatch] install on set failed', e);
      }
    }
  });
})();

// ---- Simplified rcSend (waits for scopePath, then sends) ----
async function rcSend(payload, opts = {}) {
  const { retries = 10, delay = 120 } = opts;
  const targetWin = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;

  if (!payload || typeof payload !== 'object') {
    console.warn('[MGTools] rcSend invalid payload:', payload);
    return;
  }

  // Wait for scopePath to be captured
  for (let i = 0; i <= retries; i++) {
    const sp = targetWin.__mga_lastScopePath;
    if (Array.isArray(sp)) {
      payload.scopePath = sp.slice();
      break;
    }
    if (i === retries) {
      // FALLBACK: Use known working scopePath structure
      payload.scopePath = ['Room'];
      console.warn('[MGTools] Using fallback scopePath ["Room"]');
    }
    await new Promise(r => setTimeout(r, delay));
  }

  try {
    targetWin.MagicCircle_RoomConnection?.sendMessage(payload);
    // Debug only - uncomment if troubleshooting message sending
    // console.log('[MGTools] Sent with scopePath:', payload.scopePath);
  } catch (e) {
    console.error('[MGTools] rcSend error', e);
  }
}

/**
 * MGTools - Magic Garden Enhancement Suite
 * A comprehensive userscript for enhancing the Magic Garden gaming experience
 *
 * @version 1.1.0
 * @author Unified Script
 * @license MIT
 */

/* ============================================================================
 * MODULE STRUCTURE
 * ============================================================================
 *
 * 1. INITIALIZATION MODULE     - Script startup and diagnostic logging
 * 2. CONFIGURATION MODULE      - Global constants, settings, and debug flags
 * 3. COMPATIBILITY MODULE      - Browser detection, CSP handling, polyfills
 * 4. STORAGE MODULE           - Unified storage abstraction layer
 * 5. LOGGING MODULE           - Production and debug logging system
 * 6. NETWORK MODULE           - API calls, fetch wrappers, WebSocket
 * 7. STATE MODULE             - UnifiedState and data management
 * 8. UI FRAMEWORK MODULE      - Base styles, components, and utilities
 * 9. FEATURE MODULES          - Individual feature implementations
 *    9.1 Pet Management        - Pet presets, feeding, hunger tracking
 *    9.2 Shop System          - Shop monitoring, notifications, pricing
 *    9.3 Ability System       - Ability logging, filtering, display
 *    9.4 Seeds & Values       - Seed management, value calculations
 *    9.5 Timers              - Game timers and countdowns
 *    9.6 Rooms               - Room management and navigation
 * 10. EVENT MODULE            - Event handlers and hotkey system
 * 11. INITIALIZATION MODULE   - Bootstrap and startup logic
 * 12. PUBLIC API MODULE       - External interfaces and helpers
 *
 * ============================================================================
 */

/* ============================================================================
 * 1. INITIALIZATION MODULE
 * ============================================================================
 * Handles initial script loading, diagnostics, and environment detection
 */

// === DIAGNOSTIC LOGGING (MUST EXECUTE IF SCRIPT LOADS) ===
console.error('üö®üö®üö® MGTOOLS LOADING - IF YOU SEE THIS, SCRIPT IS RUNNING üö®üö®üö®');
console.log('[MGTOOLS-DEBUG] 1. Script file loaded');
console.log('[MGTOOLS-DEBUG] ‚ö° VERSION: 2.0.0 - Pet auto-favorite fixes + Micro/Mini dock sizes');
console.log('[MGTOOLS-DEBUG] üïê Load Time:', new Date().toISOString());
console.log('[MGTOOLS-DEBUG] 2. Location:', window.location.href);
console.log('[MGTOOLS-DEBUG] 3. Navigator:', navigator.userAgent);
console.log('[MGTOOLS-DEBUG] 4. Window type:', window === window.top ? 'TOP' : 'IFRAME');

/* ============================================================================
 * 2. COMPATIBILITY MODULE - START
 * ============================================================================
 * Handles browser compatibility, CSP issues, and Discord-specific workarounds
 */

// === CSP Guard: Disable external Google Fonts in Discord/webview ===
(function () {
  try {
    const isDiscord =
      /discord|overlay|electron/i.test(navigator.userAgent) || window.DiscordNative || window.__discordApp;
    if (isDiscord) {
      console.log('üõ°Ô∏è [CSP] External font loads disabled in Discord context.');
    }
    const origCreateElement = Document.prototype.createElement;
    Document.prototype.createElement = function (tag) {
      const el = origCreateElement.call(this, tag);
      try {
        if (isDiscord && tag && tag.toLowerCase() === 'link') {
          const origSetAttribute = el.setAttribute;
          el.setAttribute = function (name, value) {
            if (name === 'href' && typeof value === 'string' && /fonts\.googleapis/i.test(value)) {
              console.log('üõ°Ô∏è [CSP] Prevented external font link injection:', value);
              return;
            }
            return origSetAttribute.apply(this, arguments);
          };
        }
      } catch (_) {
        // Intentionally ignore setAttribute errors in restricted environments
      }
      return el;
    };
  } catch (_) {
    // Intentionally ignore createElement override errors
  }
})();

(function () {
  'use strict';

  /* ============================================================================
   * 3. STORAGE MODULE - START
   * ============================================================================
   * Unified storage abstraction with multiple fallback mechanisms
   */

  /**
   * Unified Storage Module
   * Provides consistent storage API with automatic fallback chain:
   * GM Storage ‚Üí localStorage ‚Üí sessionStorage ‚Üí memory
   *
   * @namespace Storage
   */
  const Storage = (() => {
    // Private state
    let initialized = false;
    let storageType = null;
    let gmApiAvailable = null;
    const _gmApiWarningShown = false; // Reserved for future warning system
    const memoryStore = {};
    const storageTypes = {
      GM: 'gm',
      LOCAL: 'local',
      SESSION: 'session',
      MEMORY: 'memory'
    };

    // Storage references
    let localStorageRef = null;
    let sessionStorageRef = null;

    /**
     * Test if GM storage API is available and working
     * @private
     * @returns {boolean}
     */
    function testGMStorage() {
      if (gmApiAvailable !== null) return gmApiAvailable;

      try {
        if (typeof GM_setValue === 'undefined' || typeof GM_getValue === 'undefined') {
          gmApiAvailable = false;
          return false;
        }

        // Test actual functionality
        const testKey = '__mgtools_gm_test__';
        const testValue = 'test_' + Date.now();
        GM_setValue(testKey, testValue);
        const retrieved = GM_getValue(testKey, null);

        // Clean up
        if (typeof GM_deleteValue !== 'undefined') {
          try {
            GM_deleteValue(testKey);
          } catch (e) {
            // Ignore GM_deleteValue errors during cleanup
          }
        }

        gmApiAvailable = retrieved === testValue;
        return gmApiAvailable;
      } catch (e) {
        gmApiAvailable = false;
        return false;
      }
    }

    /**
     * Get localStorage reference (with Discord iframe workaround)
     * @private
     * @returns {Storage|null}
     */
    function getLocalStorage() {
      if (localStorageRef) return localStorageRef;

      try {
        // Try direct access
        if (window.localStorage && typeof window.localStorage !== 'undefined') {
          const test = '__localStorage_test__';
          window.localStorage.setItem(test, test);
          window.localStorage.removeItem(test);
          localStorageRef = window.localStorage;
          return localStorageRef;
        }
      } catch (e) {
        // Discord iframe workaround
        try {
          const iframe = document.createElement('iframe');
          iframe.style.display = 'none';
          iframe.style.position = 'absolute';
          iframe.style.width = '0';
          iframe.style.height = '0';

          if (document.body) {
            document.body.appendChild(iframe);
          } else {
            document.documentElement.appendChild(iframe);
          }

          const iframeStorage = iframe.contentWindow.localStorage;
          const test = '__mgtools_iframe_test__';
          iframeStorage.setItem(test, test);
          iframeStorage.removeItem(test);

          localStorageRef = iframeStorage;
          console.log('‚úÖ [STORAGE] Using iframe localStorage workaround');
          return localStorageRef;
        } catch (iframeError) {
          // Fallback failed
        }
      }

      return null;
    }

    /**
     * Get sessionStorage reference
     * @private
     * @returns {Storage|null}
     */
    function getSessionStorage() {
      if (sessionStorageRef) return sessionStorageRef;

      try {
        if (window.sessionStorage && typeof window.sessionStorage !== 'undefined') {
          const test = '__sessionStorage_test__';
          window.sessionStorage.setItem(test, test);
          window.sessionStorage.removeItem(test);
          sessionStorageRef = window.sessionStorage;
          return sessionStorageRef;
        }
      } catch (e) {
        // sessionStorage not available or blocked
      }

      return null;
    }

    /**
     * Initialize storage system and determine best available type
     * @private
     */
    function initialize() {
      if (initialized) return;

      // Test storage types in order of preference
      if (testGMStorage()) {
        storageType = storageTypes.GM;
        console.log('‚úÖ [STORAGE] Using GM storage (persistent across domains)');
      } else if (getLocalStorage()) {
        storageType = storageTypes.LOCAL;
        console.log('‚úÖ [STORAGE] Using localStorage');
      } else if (getSessionStorage()) {
        storageType = storageTypes.SESSION;
        console.warn('‚ö†Ô∏è [STORAGE] Using sessionStorage (data lost on tab close)');
      } else {
        storageType = storageTypes.MEMORY;
        console.warn('‚ö†Ô∏è [STORAGE] Using memory storage (data lost on refresh)');
      }

      initialized = true;
    }

    /**
     * Get item from storage
     * @param {string} key - Storage key
     * @param {*} [defaultValue=null] - Default value if not found
     * @returns {*} Value or default
     */
    function getItem(key, defaultValue = null) {
      initialize();

      try {
        let value = null;

        switch (storageType) {
          case storageTypes.GM:
            value = GM_getValue(key, null);
            break;
          case storageTypes.LOCAL:
            value = localStorageRef.getItem(key);
            break;
          case storageTypes.SESSION:
            value = sessionStorageRef.getItem(key);
            break;
          case storageTypes.MEMORY:
            value = memoryStore[key] || null;
            break;
        }

        // Try to parse JSON if applicable
        if (value && typeof value === 'string') {
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }

        return value !== null ? value : defaultValue;
      } catch (e) {
        console.error('[STORAGE] getItem error:', e);
        return defaultValue;
      }
    }

    /**
     * Set item in storage
     * @param {string} key - Storage key
     * @param {*} value - Value to store
     * @returns {boolean} Success status
     */
    function setItem(key, value) {
      initialize();

      try {
        // Convert objects to JSON
        const stringValue = typeof value === 'object' ? JSON.stringify(value) : String(value);

        switch (storageType) {
          case storageTypes.GM:
            GM_setValue(key, stringValue);
            break;
          case storageTypes.LOCAL:
            localStorageRef.setItem(key, stringValue);
            break;
          case storageTypes.SESSION:
            sessionStorageRef.setItem(key, stringValue);
            break;
          case storageTypes.MEMORY:
            memoryStore[key] = stringValue;
            break;
        }

        return true;
      } catch (e) {
        console.error('[STORAGE] setItem error:', e);

        // Try fallback to memory if other storage fails
        if (storageType !== storageTypes.MEMORY) {
          try {
            memoryStore[key] = typeof value === 'object' ? JSON.stringify(value) : String(value);
            console.warn('[STORAGE] Fallback to memory for key:', key);
            return true;
          } catch (e2) {}
        }

        return false;
      }
    }

    /**
     * Remove item from storage
     * @param {string} key - Storage key
     * @returns {boolean} Success status
     */
    function removeItem(key) {
      initialize();

      try {
        switch (storageType) {
          case storageTypes.GM:
            if (typeof GM_deleteValue !== 'undefined') {
              GM_deleteValue(key);
            } else {
              GM_setValue(key, undefined);
            }
            break;
          case storageTypes.LOCAL:
            localStorageRef.removeItem(key);
            break;
          case storageTypes.SESSION:
            sessionStorageRef.removeItem(key);
            break;
          case storageTypes.MEMORY:
            delete memoryStore[key];
            break;
        }

        return true;
      } catch (e) {
        console.error('[STORAGE] removeItem error:', e);
        return false;
      }
    }

    /**
     * Clear all storage (use with caution)
     * @returns {boolean} Success status
     */
    function clear() {
      initialize();

      try {
        switch (storageType) {
          case storageTypes.GM:
            // GM storage doesn't have a clear method, would need to track keys
            console.warn('[STORAGE] GM storage clear not implemented');
            break;
          case storageTypes.LOCAL:
            localStorageRef.clear();
            break;
          case storageTypes.SESSION:
            sessionStorageRef.clear();
            break;
          case storageTypes.MEMORY:
            Object.keys(memoryStore).forEach(key => delete memoryStore[key]);
            break;
        }

        return true;
      } catch (e) {
        console.error('[STORAGE] clear error:', e);
        return false;
      }
    }

    /**
     * Get current storage type
     * @returns {string|null} Current storage type
     */
    function getStorageType() {
      initialize();
      return storageType;
    }

    /**
     * Get storage info for debugging
     * @returns {Object} Storage information
     */
    function getInfo() {
      initialize();
      return {
        type: storageType,
        gmAvailable: gmApiAvailable,
        localStorageAvailable: localStorageRef !== null,
        sessionStorageAvailable: sessionStorageRef !== null,
        memoryKeys: Object.keys(memoryStore).length
      };
    }

    // Public API
    return {
      get: getItem,
      set: setItem,
      remove: removeItem,
      clear,
      getType: getStorageType,
      getInfo,

      // Legacy compatibility
      getItem,
      setItem,
      removeItem,

      // Storage type constants
      TYPES: storageTypes
    };
  })();

  // Legacy compatibility - maintain old references
  const _safeStorage = Storage; // Kept for backwards compatibility
  const localStorage = {
    getItem: key => Storage.get(key),
    setItem: (key, value) => Storage.set(key, value),
    removeItem: key => Storage.remove(key),
    clear: () => Storage.clear(),
    get length() {
      console.warn('[STORAGE] localStorage.length not supported in unified storage');
      return 0;
    },
    key: _index => {
      console.warn('[STORAGE] localStorage.key() not supported in unified storage');
      return null;
    }
  };

  /* ============================================================================
   * 4. CONFIGURATION MODULE - START
   * ============================================================================
   * Global constants, version info, URLs, and configuration values
   */

  /**
   * Main configuration object containing all global settings
   * @namespace CONFIG
   * @constant {Object}
   */
  const CONFIG = {
    // Version Information
    VERSION: {
      CURRENT: '2.1.1',
      CHECK_URL_STABLE: 'https://raw.githubusercontent.com/Myke247/MGTools/main/MGTools.user.js',
      CHECK_URL_BETA: 'https://raw.githubusercontent.com/Myke247/MGTools/Live-Beta/MGTools.user.js',
      DOWNLOAD_URL_STABLE: 'https://github.com/Myke247/MGTools/raw/refs/heads/main/MGTools.user.js',
      DOWNLOAD_URL_BETA: 'https://github.com/Myke247/MGTools/raw/refs/heads/Live-Beta/MGTools.user.js'
    },

    // Debug Settings
    DEBUG: {
      PRODUCTION: true, // Set to false for verbose debug logging
      FLAGS: {
        OVERLAY_LIFECYCLE: false,
        HANDLER_SETUP: false,
        THEME_APPLICATION: false,
        VALUE_CALCULATIONS: false,
        ABILITY_LOGS: false,
        BUTTON_INTERACTIONS: false,
        POP_OUT_DESIGN: false,
        ERROR_TRACKING: true,
        PERFORMANCE: false,
        FIX_VALIDATION: false // Enable to see fix debug logs during testing (now controlled by debugMode setting)
      }
    },

    // UI Settings
    UI: {
      DEFAULT_OPACITY: 95,
      DEFAULT_POPOUT_OPACITY: 50,
      DEFAULT_THEME: 'default',
      DEFAULT_GRADIENT: 'blue-purple',
      DEFAULT_EFFECT: 'none',
      DOCK_WIDTH: 380,
      DOCK_MIN_WIDTH: 320,
      DOCK_MAX_WIDTH: 600,
      TAB_HEIGHT: 40,
      ANIMATION_DURATION: 300
    },

    // Timing Settings
    TIMERS: {
      AUTO_SAVE_INTERVAL: 30000, // 30 seconds
      CONNECTION_CHECK_INTERVAL: 5000, // 5 seconds
      HEARTBEAT_INTERVAL: 300000, // 5 minutes
      SHOP_CHECK_INTERVAL: 3000, // 3 seconds
      PET_HUNGER_CHECK_INTERVAL: 60000 // 1 minute
    },

    // API Settings
    API: {
      BASE_URL_PRIMARY: 'https://magiccircle.gg',
      BASE_URL_FALLBACK: 'https://magicgarden.gg',
      ENDPOINTS: {
        ROOMS: '/api/rooms',
        SHOP: '/api/shop',
        PETS: '/api/pets',
        INVENTORY: '/api/inventory'
      }
    },

    // Game Data - Decoration Items
    DECOR_ITEMS: [
      // Rocks
      { id: 'SmallRock', name: 'Small Garden Rock', category: 'Rocks' },
      { id: 'MediumRock', name: 'Medium Garden Rock', category: 'Rocks' },
      { id: 'LargeRock', name: 'Large Garden Rock', category: 'Rocks' },
      // Wood Items
      { id: 'WoodBench', name: 'Wood Bench', category: 'Wood' },
      { id: 'WoodArch', name: 'Wood Arch', category: 'Wood' },
      { id: 'WoodBridge', name: 'Wood Bridge', category: 'Wood' },
      { id: 'WoodLampPost', name: 'Wood Lamp Post', category: 'Wood' },
      { id: 'WoodOwl', name: 'Wood Owl', category: 'Wood' },
      { id: 'WoodBirdhouse', name: 'Wood Birdhouse', category: 'Wood' },
      // Stone Items
      { id: 'StoneBench', name: 'Stone Bench', category: 'Stone' },
      { id: 'StoneArch', name: 'Stone Arch', category: 'Stone' },
      { id: 'StoneBridge', name: 'Stone Bridge', category: 'Stone' },
      { id: 'StoneLampPost', name: 'Stone Lamp Post', category: 'Stone' },
      { id: 'StoneGnome', name: 'Stone Gnome', category: 'Stone' },
      { id: 'StoneBirdbath', name: 'Stone Birdbath', category: 'Stone' },
      // Marble Items
      { id: 'MarbleBench', name: 'Marble Bench', category: 'Marble' },
      { id: 'MarbleArch', name: 'Marble Arch', category: 'Marble' },
      { id: 'MarbleBridge', name: 'Marble Bridge', category: 'Marble' },
      { id: 'MarbleLampPost', name: 'Marble Lamp Post', category: 'Marble' }
    ]
  };

  // Legacy compatibility - maintain old variable names
  const CURRENT_VERSION = CONFIG.VERSION.CURRENT;
  const _VERSION_CHECK_URL_STABLE = CONFIG.VERSION.CHECK_URL_STABLE;
  const _VERSION_CHECK_URL_BETA = CONFIG.VERSION.CHECK_URL_BETA;
  const STABLE_DOWNLOAD_URL = CONFIG.VERSION.DOWNLOAD_URL_STABLE;
  const BETA_DOWNLOAD_URL = CONFIG.VERSION.DOWNLOAD_URL_BETA;

  // Detect if running Live Beta version (check @updateURL in script)
  // Safe check for Discord pop-out and console paste compatibility
  const IS_LIVE_BETA = (() => {
    try {
      if (typeof GM_info === 'undefined') {
        return false;
      }
      return GM_info?.script?.updateURL?.includes('Live-Beta') || false;
    } catch (e) {
      console.warn('[MGTOOLS] Branch detection failed:', e.message);
      return false;
    }
  })();

  // Detect if running without Tampermonkey (console paste or incompatible environment)
  const isRunningWithoutTampermonkey = typeof GM_info === 'undefined';

  if (isRunningWithoutTampermonkey) {
    console.error('%c‚ö†Ô∏è MGTOOLS INSTALLATION ERROR', 'font-size:16px;color:#ff0000;font-weight:bold');
    console.error('%cMGTools MUST be installed via Tampermonkey!', 'font-size:14px;color:#ff9900');
    console.error('%cDo NOT paste the script in console - it will not work correctly!', 'font-size:14px;color:#ff9900');
    console.error(
      '%c\nüìã Correct Installation:\n1. Install Tampermonkey: https://www.tampermonkey.net/\n2. Click: https://github.com/Myke247/MGTools/raw/main/MGTools.user.js\n3. Click "Install" button\n4. Refresh Magic Garden',
      'font-size:12px;color:#00ffff'
    );

    // Try to continue anyway using localStorage fallback
    console.warn('%c‚ö†Ô∏è Attempting to run in fallback mode (limited functionality)...', 'font-size:12px;color:#ffff00');
  }

  // Semantic version comparison function
  function compareVersions(v1, v2) {
    // Returns: -1 if v1 < v2, 0 if v1 === v2, 1 if v1 > v2
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);

    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const part1 = parts1[i] || 0;
      const part2 = parts2[i] || 0;

      if (part1 > part2) return 1;
      if (part1 < part2) return -1;
    }

    return 0;
  }

  /* ============================================================================
   * 5. LOGGING MODULE - START
   * ============================================================================
   * Unified logging system with production/debug modes and categories
   */

  /**
   * Unified logging system with production/debug modes
   * @namespace Logger
   */
  const Logger = (() => {
    // Configuration
    const PRODUCTION = CONFIG.DEBUG.PRODUCTION;
    const DEBUG_FLAGS = CONFIG.DEBUG.FLAGS;

    // Logging levels
    const LogLevel = {
      NONE: 0,
      ERROR: 1,
      WARN: 2,
      INFO: 3,
      DEBUG: 4
    };

    const CURRENT_LOG_LEVEL = PRODUCTION ? LogLevel.WARN : LogLevel.DEBUG;
    const tooltipContainer = null;

    /**
     * Core logging function with level and category support
     * @private
     * @param {number} level - Log level
     * @param {string} category - Log category
     * @param {string} message - Log message
     * @param {*} [data] - Optional data to log
     */
    function log(level, category, message, data) {
      if (level > CURRENT_LOG_LEVEL) return;

      const prefix = `[${category}]`;
      const args = data !== undefined ? [prefix, message, data] : [prefix, message];

      if (level === LogLevel.ERROR) console.error(...args);
      else if (level === LogLevel.WARN) console.warn(...args);
      else console.log(...args);
    }

    /**
     * Debug log for specific debug flags
     * @param {string} flag - Debug flag to check
     * @param {string} message - Log message
     * @param {*} [data] - Optional data
     */
    function debugLog(flag, message, data = null) {
      if (!PRODUCTION && DEBUG_FLAGS[flag]) {
        const timestamp = new Date().toLocaleTimeString();
        log(LogLevel.DEBUG, `DEBUG-${flag}`, `${timestamp} ${message}`, data);
      }
    }

    /**
     * Debug error logging
     * @param {string} flag - Debug flag to check
     * @param {string} message - Error message
     * @param {Error} error - Error object
     * @param {Object} [context] - Additional context
     */
    function debugError(flag, message, error, context = {}) {
      if (DEBUG_FLAGS[flag] || DEBUG_FLAGS.ERROR_TRACKING) {
        const timestamp = new Date().toLocaleTimeString();
        log(LogLevel.ERROR, `ERROR-${flag}`, `${timestamp} ${message}`, {
          error: error,
          context: context,
          stack: error?.stack
        });
      }
    }

    // Public API
    const api = {
      // Core logging methods
      error: (cat, msg, data) => log(LogLevel.ERROR, cat, msg, data),
      warn: (cat, msg, data) => log(LogLevel.WARN, cat, msg, data),
      info: (cat, msg, data) => log(LogLevel.INFO, cat, msg, data),
      debug: (cat, msg, data) => log(LogLevel.DEBUG, cat, msg, data),

      // Debug logging methods
      debugLog,
      debugError,

      // Legacy support methods
      productionLog: (...args) => {
        const message = String(args[0] || '');
        const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
        const category = categoryMatch ? categoryMatch[1] : 'LEGACY';
        api.info(category, ...args);
      },
      productionWarn: (...args) => {
        const message = String(args[0] || '');
        const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
        const category = categoryMatch ? categoryMatch[1] : 'LEGACY';
        api.warn(category, ...args);
      },
      productionError: (...args) => {
        const message = String(args[0] || '');
        const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
        const category = categoryMatch ? categoryMatch[1] : 'LEGACY';
        api.error(category, ...args);
      }
    };

    return api;
  })();

  // Export legacy function names for compatibility
  const logError = Logger.error;
  const logWarn = Logger.warn;
  const logInfo = Logger.info;
  const logDebug = Logger.debug;
  const debugLog = Logger.debugLog;
  const debugError = Logger.debugError;
  const productionLog = Logger.productionLog;
  const productionWarn = Logger.productionWarn;
  const productionError = Logger.productionError;

  // Export globally for IIFE access
  if (typeof window !== 'undefined') {
    window.Logger = Logger;
    window.productionLog = productionLog;
    window.productionWarn = productionWarn;
    window.productionError = productionError;
    window.debugLog = debugLog;
    window.debugError = debugError;
  }

  /* ============================================================================
   * 6. COMPATIBILITY MODULE - EXTENDED
   * ============================================================================
   * Advanced CSP detection and compatibility mode for Discord/managed devices
   */

  /**
   * Compatibility mode system for handling restricted environments
   * @namespace CompatibilityMode
   */
  const CompatibilityMode = {
    flags: {
      enabled: false,
      blockExternalFonts: false,
      blockExternalBeacons: false,
      wsReconnectWhenHidden: false,
      strictNoEvalDynamicImport: false,
      inlineAssetsOnly: false,
      uiReducedMode: false,
      domOnlyStyles: false,
      bypassCSPNetworking: false
    },

    detectionComplete: false,
    cspViolations: [],
    detectionReason: null,

    detect() {
      // Check for user override first
      try {
        const disabled = localStorage.getItem('mgtools_compat_disabled');
        if (disabled === 'true') {
          logInfo('COMPAT', 'Compatibility mode disabled by user');
          this.detectionComplete = true;
          return;
        }

        const forced = localStorage.getItem('mgtools_compat_forced');
        if (forced === 'true') {
          this.enableCompat('user-forced');
          this.detectionComplete = true;
          return;
        }
      } catch (e) {
        logWarn('COMPAT', 'Unable to check localStorage for compat settings', e);
      }

      // 1. Discord embed detection (enhanced)
      const host = window.location.host;
      const isDiscordHost =
        host.includes('discordsays.com') ||
        host.includes('discordactivities.com') ||
        host.includes('discord.gg') ||
        host.includes('discord.com');
      const isDiscordDesktop = typeof window.DiscordNative !== 'undefined';
      const inDiscordIframe = window !== window.top && document.referrer?.includes('discord');
      const hasDiscordSDK = typeof window.DiscordSDK !== 'undefined' || typeof window.__DISCORD__ !== 'undefined';

      const isDiscordEmbed = isDiscordHost || isDiscordDesktop || inDiscordIframe || hasDiscordSDK;

      if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
        console.log('[FIX_DISCORD]', {
          host: isDiscordHost,
          desktop: isDiscordDesktop,
          iframe: inDiscordIframe,
          sdk: hasDiscordSDK,
          scope: typeof unsafeWindow !== 'undefined' ? 'unsafeWindow' : 'window'
        });
      }

      /**
       * Discord CSP Constraints:
       * - No external stylesheets (Google Fonts blocked)
       * - Limited fetch (use GM_xmlhttpRequest)
       * - Storage fallback to sessionStorage/memory
       * - Scope bridging via unsafeWindow when available
       */

      if (isDiscordEmbed) {
        this.enableCompat('discord-embed');
        this.detectionComplete = true;
        return;
      }

      // 2. CSP violation listener (500ms window) with duplicate prevention
      // CRITICAL FIX: Opera/Tampermonkey makes console.error read-only, causing fatal crash
      const self = this;
      const seenCSPMessages = new Set();

      try {
        // Check if console.error is writable before attempting override
        const descriptor = Object.getOwnPropertyDescriptor(console, 'error');
        const canOverride = !descriptor || descriptor.writable || descriptor.configurable;

        if (canOverride) {
          // Safe to override console.error
          const originalError = console.error.bind(console);

          console.error = function (...args) {
            const msg = args.join(' ');

            // Check for CSP-related errors
            if (
              (msg.includes('Content Security Policy') ||
                msg.includes('Refused to load') ||
                msg.includes('violates the following')) &&
              !msg.includes('mgtools')
            ) {
              // Ignore our own CSP issues

              // Skip duplicate CSP violations to reduce console spam
              if (seenCSPMessages.has(msg)) {
                return; // Silently skip duplicate
              }
              seenCSPMessages.add(msg);

              self.cspViolations.push(msg);
              if (self.cspViolations.length >= 2 && !self.flags.enabled) {
                self.enableCompat('csp-violations');
              }
            }
            return originalError.apply(console, args);
          };

          logInfo('COMPAT', '‚úÖ Console.error override successful for CSP detection');
        } else {
          // Console.error is read-only (Opera/Tampermonkey) - use alternative detection
          logWarn('COMPAT', '‚ö†Ô∏è Console.error is read-only, using alternative CSP detection');

          // Alternative: listen for window error events
          window.addEventListener(
            'error',
            event => {
              const msg = event.message || '';
              if (
                (msg.includes('Content Security Policy') ||
                  msg.includes('Refused to load') ||
                  msg.includes('violates the following')) &&
                !msg.includes('mgtools') &&
                !seenCSPMessages.has(msg)
              ) {
                seenCSPMessages.add(msg);
                self.cspViolations.push(msg);
                if (self.cspViolations.length >= 2 && !self.flags.enabled) {
                  self.enableCompat('csp-violations');
                }
              }
            },
            true
          );
        }
      } catch (e) {
        // Complete failure - continue without CSP detection
        logWarn('COMPAT', '‚ùå Cannot setup CSP detection:', e.message);
        logInfo('COMPAT', 'Continuing without CSP violation detection');
      }

      // 3. Test storage availability
      setTimeout(() => {
        if (!this.flags.enabled) {
          try {
            const testKey = '__mgtools_compat_test_' + Date.now();
            GM_setValue(testKey, 'test');
            GM_deleteValue(testKey);
          } catch (e) {
            this.enableCompat('storage-failed');
          }
        }

        this.detectionComplete = true;
        if (this.flags.enabled) {
          logInfo('COMPAT', 'Compatibility mode ACTIVE', {
            reason: this.detectionReason,
            violations: this.cspViolations.length
          });
        } else {
          logDebug('COMPAT', 'Compatibility mode not needed, running in normal mode');
        }
      }, 500);
    },

    enableCompat(reason) {
      if (this.flags.enabled) return; // Already enabled

      logInfo('COMPAT', `Enabling compatibility mode: ${reason}`);

      // Discord Fix: Add detailed Discord-specific logging
      const isDiscordReason = reason.includes('discord') || reason.includes('csp');
      if (isDiscordReason) {
        productionLog('üéÆ [DISCORD] Compatibility mode activated for Discord environment');
        productionLog('   üìã [DISCORD] Features enabled:');
        productionLog('      ‚Ä¢ Inline styles only (no external CSS)');
        productionLog('      ‚Ä¢ System fonts (no Google Fonts CDN)');
        productionLog('      ‚Ä¢ GM_xmlhttpRequest for network requests');
        productionLog('      ‚Ä¢ DOM mutation observer for UI persistence');
      }

      this.detectionReason = reason;
      this.flags.enabled = true;
      this.flags.blockExternalFonts = true;
      this.flags.blockExternalBeacons = true;
      this.flags.wsReconnectWhenHidden = true;
      this.flags.strictNoEvalDynamicImport = true;
      this.flags.inlineAssetsOnly = true;
      this.flags.uiReducedMode = true;
      this.flags.domOnlyStyles = true;
      this.flags.bypassCSPNetworking = true;

      // Save preference
      try {
        localStorage.setItem('mgtools_compat_mode', 'true');
        localStorage.setItem('mgtools_compat_reason', reason);
      } catch (e) {
        // Ignore localStorage errors in restricted environments
      }
    },

    disableCompat() {
      this.flags.enabled = false;
      Object.keys(this.flags).forEach(key => {
        if (key !== 'enabled') this.flags[key] = false;
      });

      try {
        localStorage.setItem('mgtools_compat_disabled', 'true');
        localStorage.removeItem('mgtools_compat_mode');
      } catch (e) {}

      logInfo('COMPAT', 'Compatibility mode disabled');
    },

    isEnabled() {
      return this.flags.enabled;
    }
  };

  // Initialize compatibility detection immediately
  CompatibilityMode.detect();

  /* ============================================================================
   * 7. NETWORK MODULE - START
   * ============================================================================
   * Unified network layer with CSP bypass capabilities
   */

  /**
   * Network abstraction layer with fallback to GM_xmlhttpRequest
   * @namespace Network
   */
  const Network = {
    async fetch(url, options = {}) {
      if (
        CompatibilityMode.flags.bypassCSPNetworking &&
        typeof GM_xmlhttpRequest === 'function' &&
        !url.startsWith(window.location.origin)
      ) {
        // Use GM_xmlhttpRequest to bypass CSP for external requests
        logDebug('NETWORK', `Using GM_xmlhttpRequest for: ${url}`);
        return new Promise((resolve, reject) => {
          GM_xmlhttpRequest({
            url,
            method: options.method || 'GET',
            headers: options.headers || {},
            data: options.body,
            responseType: 'text',
            timeout: options.timeout || 10000,
            onload: response => {
              resolve({
                ok: response.status >= 200 && response.status < 300,
                status: response.status,
                statusText: response.statusText,
                text: () => Promise.resolve(response.responseText),
                json: () => Promise.resolve(JSON.parse(response.responseText)),
                headers: {
                  get: name => response.responseHeaders.match(new RegExp(`^${name}:\\s*(.*)$`, 'mi'))?.[1]
                }
              });
            },
            onerror: error => reject(new Error(error.statusText || 'Network error')),
            ontimeout: () => reject(new Error('Request timeout'))
          });
        });
      } else {
        // Normal fetch
        return fetch(url, options);
      }
    }
  };

  /* ============================================================================
   * 8. UI FRAMEWORK MODULE - ASSET MANAGEMENT
   * ============================================================================
   * Compatibility-aware style and font loading
   */

  /**
   * Asset management system for styles, fonts, and icons
   * @namespace AssetManager
   */
  const AssetManager = {
    addStyles(css, id) {
      // Discord Fix: Prefer GM_addElement for best CSP compatibility
      // GM_addElement bypasses CSP better than regular createElement
      if (typeof GM_addElement === 'function' && CompatibilityMode.flags.enabled) {
        try {
          const attrs = { textContent: css };
          if (id) attrs.id = id;
          GM_addElement('style', attrs);
          logDebug('ASSETS', `Added styles via GM_addElement${id ? ` (${id})` : ''} (Discord-safe)`);
          return;
        } catch (e) {
          logWarn('ASSETS', 'GM_addElement failed, falling back to standard method', e);
        }
      }

      if (CompatibilityMode.flags.domOnlyStyles) {
        // Inline styles only - inject into head with style element
        const style = document.createElement('style');
        style.textContent = css;
        if (id) style.id = id;
        document.head.appendChild(style);
        logDebug('ASSETS', `Injected inline styles${id ? ` (${id})` : ''}`);
      } else {
        // Normal mode - use GM_addStyle if available
        if (typeof GM_addStyle === 'function') {
          GM_addStyle(css);
        } else {
          const style = document.createElement('style');
          style.textContent = css;
          if (id) style.id = id;
          document.head.appendChild(style);
        }
        logDebug('ASSETS', `Added styles${id ? ` (${id})` : ''}`);
      }
    },

    loadFonts() {
      if (CompatibilityMode.flags.blockExternalFonts) {
        // Use system fonts only
        this.addStyles(
          `
                      .mgtools-ui *, .mga-dock *, .mga-sidebar *, .mga-panel * {
                          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                                       Roboto, Helvetica, Arial, sans-serif !important;
                      }
                      .fancy-header, .mgtools-header {
                          font-family: Georgia, "Times New Roman", serif !important;
                          font-style: italic;
                      }
                  `,
          'mgtools-compat-fonts'
        );
        logInfo('ASSETS', 'Using system fonts (compat mode)');
      } else {
        // Normal font loading - Google Fonts
        // The CSP guard at the top of the file will prevent this in Discord anyway
        logDebug('ASSETS', 'External fonts allowed (normal mode)');
      }
    },

    // Icon helper - returns data URI in compat mode or emoji/text fallback
    getIcon(name) {
      // In compat mode or for simplicity, use emoji fallbacks
      const icons = {
        pet: 'üêæ',
        timer: '‚è∞',
        shop: 'üõí',
        seeds: 'üå±',
        values: 'üíé',
        abilities: '‚ö°',
        rooms: 'üè†',
        tools: 'üîß',
        settings: '‚öôÔ∏è',
        hotkeys: '‚å®Ô∏è',
        help: '‚ùì',
        alert: 'üîî',
        close: '‚úñÔ∏è',
        refresh: 'üîÑ',
        save: 'üíæ',
        export: 'üì§',
        import: 'üì•'
      };
      return icons[name] || 'üì¶';
    }
  };

  // Call font setup early
  AssetManager.loadFonts();

  // ==================== SELECTIVE CONTEXT ISOLATION ====================
  // Detect userscript environment and use unsafeWindow for page access (like v3.5.7)
  const isUserscript = typeof unsafeWindow !== 'undefined';
  const targetWindow = isUserscript ? unsafeWindow : window;
  const targetDocument = targetWindow.document;

  // Track which atoms have been hooked to prevent duplicates
  const hookedAtoms = new Set();

  // Store references to hooked atoms for re-querying (CRITICAL for fresh data)
  const atomReferences = new Map(); // Maps windowKey -> {atom, atomCache, atomPath}

  // Store the Jotai store object (has get/set/sub methods for querying atoms)
  let jotaiStore = null;

  // Capture Jotai store from React fiber tree
  function captureJotaiStore() {
    if (jotaiStore) return jotaiStore;

    try {
      // Method 1: Check if store is directly exposed on window
      const directStore = targetWindow.__jotaiStore || targetWindow.jotaiStore;
      if (directStore && typeof directStore.get === 'function' && typeof directStore.set === 'function') {
        jotaiStore = directStore;
        console.log('‚úÖ [STORE] Captured Jotai store from window.__jotaiStore');
        return jotaiStore;
      }

      // Method 2: Try React DevTools hook (original method)
      const hook = targetWindow.__REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook?.renderers?.size) {
        for (const [rid] of hook.renderers) {
          const roots = hook.getFiberRoots?.(rid);
          if (!roots) continue;

          for (const root of roots) {
            const seen = new Set();
            const stack = [root.current];

            while (stack.length) {
              const fiber = stack.pop();
              if (!fiber || seen.has(fiber)) continue;
              seen.add(fiber);

              // Look for Jotai Provider's store in pendingProps.value
              const value = fiber?.pendingProps?.value;
              if (
                value &&
                typeof value.get === 'function' &&
                typeof value.set === 'function' &&
                typeof value.sub === 'function'
              ) {
                jotaiStore = value;
                console.log('‚úÖ [STORE] Captured Jotai store from React fiber tree');
                return jotaiStore;
              }

              if (fiber.child) stack.push(fiber.child);
              if (fiber.sibling) stack.push(fiber.sibling);
              if (fiber.alternate) stack.push(fiber.alternate);
            }
          }
        }
      }

      // Method 3: Try to extract store from an atom in the cache
      const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
      if (atomCache && atomCache.size > 0) {
        // Try to find the store reference in any atom's metadata
        for (const [key, value] of atomCache.entries()) {
          // Some Jotai implementations store the store reference in the atom cache
          if (value?.store && typeof value.store.get === 'function') {
            jotaiStore = value.store;
            console.log('‚úÖ [STORE] Extracted Jotai store from atom cache metadata');
            return jotaiStore;
          }
        }
        productionLog('‚è≥ [STORE] Atom cache exists but store not extractable - will use direct cache reading');
      }

      productionLog('‚è≥ [STORE] Store not found - will fall back to direct atom cache reading');
      return null;
    } catch (error) {
      console.error('[STORE] Error capturing Jotai store:', error);
      return null;
    }
  }

  // Get fresh value from an atom using the store
  async function getAtomValue(atomLabel) {
    try {
      // Get atom from cache by label
      const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
      if (!atomCache) {
        return null;
      }

      // Find atom with matching label
      let targetAtom = null;
      let atomKey = null;

      for (const [key, atom] of atomCache.entries()) {
        const label = atom?.debugLabel || atom?.label || '';
        if (label === atomLabel || label.includes(atomLabel)) {
          targetAtom = atom;
          atomKey = key;
          break;
        }
      }

      if (!targetAtom || !atomKey) {
        return null;
      }

      // PRIORITY 1: Try direct atom cache read first (Tier 1) - v3.8.7 fix
      // This works even when jotaiStore capture fails
      const atomState = atomCache.get(atomKey);
      if (atomState && 'v' in atomState) {
        console.log(`[STORE] ‚úÖ Tier 1: Read '${atomLabel}' directly from atom cache`);
        return atomState.v;
      }

      // PRIORITY 2: Try using jotaiStore if available (fallback)
      if (jotaiStore) {
        try {
          const value = await jotaiStore.get(targetAtom);
          console.log(`[STORE] ‚úÖ Tier 2: Read '${atomLabel}' via jotaiStore`);
          return value;
        } catch (err) {
          console.warn(`[STORE] Tier 2 jotaiStore.get() failed for '${atomLabel}':`, err.message);
        }
      }

      // PRIORITY 3: Try to capture store and use it (last resort)
      if (!jotaiStore) {
        jotaiStore = captureJotaiStore();
        if (jotaiStore) {
          try {
            const value = await jotaiStore.get(targetAtom);
            console.log(`[STORE] ‚úÖ Tier 3: Read '${atomLabel}' via late-captured jotaiStore`);
            return value;
          } catch (err) {
            console.warn(`[STORE] Tier 3 late jotaiStore.get() also failed:`, err.message);
          }
        }
      }

      console.warn(`[STORE] ‚ùå Could not read atom '${atomLabel}' - all tiers failed (cache state:`, atomState, ')');
      return null;
    } catch (error) {
      console.error(`[STORE] Error getting atom '${atomLabel}':`, error);
      return null;
    }
  }

  // Set context identifier for debugging (use window not targetWindow to avoid modifying page)
  window.MGA_CONTEXT = 'userscript';

  // ==================== JOTAI ATOM CACHE WATCHER ====================
  // MutationObserver fallback to detect when jotaiAtomCache becomes available
  let atomCacheWatcherCallbacks = [];

  function watchForAtomCache(callback) {
    // If already available, call immediately
    if (targetWindow.jotaiAtomCache) {
      callback();
      return;
    }

    // Otherwise, register callback
    atomCacheWatcherCallbacks.push(callback);

    // Set up observer only once
    if (atomCacheWatcherCallbacks.length === 1) {
      const observer = new MutationObserver(() => {
        if (targetWindow.jotaiAtomCache) {
          console.log('‚úÖ [ATOM-WATCH] jotaiAtomCache detected via MutationObserver');
          observer.disconnect();
          const callbacks = atomCacheWatcherCallbacks;
          atomCacheWatcherCallbacks = [];
          callbacks.forEach(cb => cb());
        }
      });

      // Watch for property additions to targetWindow
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true
      });

      // Also poll as backup (very infrequent)
      const pollInterval = setInterval(() => {
        if (targetWindow.jotaiAtomCache) {
          clearInterval(pollInterval);
          observer.disconnect();
          console.log('‚úÖ [ATOM-WATCH] jotaiAtomCache detected via polling');
          const callbacks = atomCacheWatcherCallbacks;
          atomCacheWatcherCallbacks = [];
          callbacks.forEach(cb => cb());
        }
      }, 1000); // Check every 1 second as safety net

      // Cleanup after 30 seconds
      setTimeout(() => {
        clearInterval(pollInterval);
        observer.disconnect();
      }, 30000);
    }
  }

  // ==================== ADVANCED STORE CAPTURE SYSTEM ====================
  // Robust Jotai atom store capture for cross-environment compatibility
  const StoreCapture = {
    store: null,
    captureMethod: null,

    // Method 1: Direct cache access (fastest when available)
    tryDirectCache() {
      // Check targetWindow first (unsafeWindow = page context), then fallback to window
      const cache =
        targetWindow.jotaiAtomCache?.cache ||
        targetWindow.jotaiAtomCache ||
        window.jotaiAtomCache?.cache ||
        window.jotaiAtomCache;

      if (cache && (cache.get || (typeof cache.size === 'number' && cache.size > 0))) {
        this.store = cache;
        this.captureMethod = 'direct';
        return true;
      }
      return false;
    },

    // Method 2: React DevTools Fiber Traversal (for iframes)
    tryFiberTraversal() {
      const hook = targetWindow.__REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!hook?.renderers?.size) return false;

      for (const [rendererID] of hook.renderers) {
        const roots = hook.getFiberRoots?.(rendererID);
        if (!roots) continue;

        for (const root of roots) {
          const store = this.traverseFiber(root.current);
          if (store) {
            this.store = store;
            this.captureMethod = 'fiber';
            return true;
          }
        }
      }
      return false;
    },

    // Traverse React Fiber tree to find Jotai store provider
    traverseFiber(fiber) {
      const visited = new Set();
      const queue = [fiber];

      while (queue.length > 0) {
        const node = queue.shift();
        if (!node || visited.has(node)) continue;
        visited.add(node);

        // Check if this fiber node contains the Jotai store
        const storeValue = node?.pendingProps?.value;
        if (
          storeValue &&
          typeof storeValue.get === 'function' &&
          typeof storeValue.set === 'function' &&
          typeof storeValue.sub === 'function'
        ) {
          return storeValue;
        }

        // Continue traversing child, sibling, and alternate fibers
        if (node.child) queue.push(node.child);
        if (node.sibling) queue.push(node.sibling);
        if (node.alternate) queue.push(node.alternate);
      }
      return null;
    },

    // Method 3: Write-intercept fallback (patches atom write functions)
    async tryWriteIntercept(timeoutMs = 5000) {
      const cache = targetWindow.jotaiAtomCache?.cache;
      if (!cache) return false;

      let capturedStore = null;
      const patchedAtoms = [];

      // Temporarily patch atom write functions to intercept store access
      for (const atom of cache.values()) {
        if (!atom || typeof atom.write !== 'function') continue;

        const originalWrite = atom.write;
        atom.__mgtools_originalWrite = originalWrite;

        atom.write = function (get, set, ...args) {
          if (!capturedStore) {
            capturedStore = { get, set, sub: () => () => {} };
            // Restore all patched atoms immediately
            for (const a of patchedAtoms) {
              if (a.__mgtools_originalWrite) {
                a.write = a.__mgtools_originalWrite;
                delete a.__mgtools_originalWrite;
              }
            }
          }
          return originalWrite.call(this, get, set, ...args);
        };

        patchedAtoms.push(atom);
      }

      // Wait for capture or timeout
      const startTime = Date.now();
      while (!capturedStore && Date.now() - startTime < timeoutMs) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }

      if (capturedStore) {
        this.store = capturedStore;
        this.captureMethod = 'intercept';
        return true;
      }

      // Cleanup if failed
      for (const atom of patchedAtoms) {
        if (atom.__mgtools_originalWrite) {
          atom.write = atom.__mgtools_originalWrite;
          delete atom.__mgtools_originalWrite;
        }
      }
      return false;
    },

    // Main capture routine - tries all methods with retry logic
    async capture(maxRetries = 20, retryDelay = 500) {
      console.log('üîç [STORE] Attempting to capture Jotai store...');

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        // Try direct cache access first (fastest)
        if (this.tryDirectCache()) {
          return true;
        }

        // Try Fiber traversal (works in iframes)
        if (this.tryFiberTraversal()) {
          return true;
        }

        // Try write intercept as last resort (only on last few attempts)
        if (attempt >= maxRetries - 3) {
          if (await this.tryWriteIntercept(1000)) {
            return true;
          }
        }

        // Wait before next attempt (but not after last attempt)
        if (attempt < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }

      console.warn('‚ö†Ô∏è [STORE] Failed to capture store after max retries - atoms will not be available');
      return false;
    },

    // Get the captured store (with fallback to direct cache check)
    getStore() {
      if (this.store) return this.store;
      // Try direct access as fallback
      if (this.tryDirectCache()) return this.store;
      return null;
    }
  };

  // StorageManager has been consolidated into the unified Storage module above
  // For legacy compatibility, create an alias
  const StorageManager = Storage;

  // ==================== API BASE URL HELPER (MUST BE EARLY) ====================
  // This function MUST be defined early because roomsInfo() IIFE needs it immediately
  // Determines correct API base URL to prevent 404 errors in Discord browser
  targetWindow.getGameApiBaseUrl = function () {
    try {
      // Check if we're in Discord browser or Discord activity
      const isDiscordHost =
        window.location.host.includes('discordsays.com') ||
        window.location.host.endsWith('.discordsays.com') ||
        window.location.host.includes('discord.com');

      const isInIframe = window.location !== window.parent.location;
      const hasDiscordNative = window.DiscordNative !== undefined;

      // If in any Discord context, use magiccircle.gg API
      // This prevents 404 errors when trying to fetch from discord.com/api/rooms/
      if (
        isDiscordHost ||
        hasDiscordNative ||
        (isInIframe && document.referrer && document.referrer.includes('discord'))
      ) {
        return 'https://magiccircle.gg';
      }

      // Otherwise use current origin for proper same-origin requests
      return location.origin;
    } catch (err) {
      console.error('[API-BASE] Failed to determine API base URL:', err);
      // Safe fallback: use magiccircle.gg if detection fails
      return 'https://magiccircle.gg';
    }
  };

  // Also define as regular function for convenience
  const getGameApiBaseUrl = targetWindow.getGameApiBaseUrl;

  // Verify function is accessible and log current API base
  console.log('‚úÖ [API-BASE] getGameApiBaseUrl() defined and accessible');
  try {
    console.log('üîó [API-BASE] Current API base:', targetWindow.getGameApiBaseUrl());
  } catch (e) {
    console.error('‚ùå [API-BASE] Function exists but failed to execute:', e);
  }

  // GM API availability check with actual functionality test
  let gmApiCheckResult = null; // Cache the result
  let gmApiWarningShown = false; // Only warn once

  function isGMApiAvailable() {
    // CRITICAL: Wrap entire function in try-catch to prevent script failure on managed devices
    try {
      // Return cached result if already tested
      if (gmApiCheckResult !== null) {
        return gmApiCheckResult;
      }

      // Check if functions exist
      if (typeof GM_setValue === 'undefined' || typeof GM_getValue === 'undefined') {
        gmApiCheckResult = false;
        if (!gmApiWarningShown) {
          try {
            logWarn('GM-STORAGE', 'GM API functions not defined - using localStorage fallback');
          } catch (e) {
            console.warn('‚ö†Ô∏è [GM-STORAGE] GM API not available - using localStorage fallback');
          }
          gmApiWarningShown = true;
        }
        return false;
      }

      // Try to actually USE the functions (managed devices may block them)
      try {
        const testKey = '__mgtools_gm_test__';
        const testValue = 'test_' + Date.now();
        GM_setValue(testKey, testValue);
        const retrieved = GM_getValue(testKey, null);

        // Clean up test
        try {
          if (typeof GM_deleteValue !== 'undefined') {
            GM_deleteValue(testKey);
          }
        } catch (e) {
          // Ignore cleanup errors
        }

        // Check if it actually worked
        if (retrieved === testValue) {
          gmApiCheckResult = true;
          try {
            logInfo('GM-STORAGE', 'GM API fully functional');
          } catch (e) {
            console.log('‚úÖ [GM-STORAGE] GM API fully functional');
          }
          return true;
        } else {
          throw new Error('GM_getValue returned incorrect value');
        }
      } catch (e) {
        gmApiCheckResult = false;
        if (!gmApiWarningShown) {
          try {
            logWarn('GM-STORAGE', 'GM API blocked by security policy - using localStorage fallback');
          } catch (e2) {
            console.warn('‚ö†Ô∏è [GM-STORAGE] GM API blocked - using localStorage fallback');
          }
          gmApiWarningShown = true;
        }
        return false;
      }
    } catch (outerError) {
      // Absolute last resort - assume GM API is not available and continue
      gmApiCheckResult = false;
      gmApiWarningShown = true;
      try {
        console.warn('‚ö†Ô∏è [GM-STORAGE] Unexpected error testing GM API - using localStorage fallback');
      } catch (e) {
        // Even console might fail on heavily locked down devices
      }
      return false;
    }
  }

  // SELECTIVE CONTEXT FUNCTIONS - Use these instead of direct document/window references
  function createMGAElement(tag, className) {
    const element = targetDocument.createElement(tag);
    if (className) element.className = className;
    return element;
  }

  function attachToMGAContext(element) {
    targetDocument.body.appendChild(element);
  }

  function isMGAEvent(event) {
    try {
      return (
        event &&
        event.target &&
        event.target.closest &&
        event.target.closest('.mga-panel, .mga-toggle-btn, .mga-overlay')
      );
    } catch (error) {
      console.error('‚ùå [BASIC-DEBUG] Error in isMGAEvent:', error);
      return false;
    }
  }

  function checkForGameModals() {
    try {
      // Use regular document for game modal detection to avoid interference
      const modals = document.querySelectorAll('[class*="modal"], [class*="dialog"], [role="dialog"]');
      // CRITICAL FIX: Exclude game drag overlays that are normal game UI, not blocking modals
      const overlays = document.querySelectorAll(
        '[class*="overlay"]:not(.mga-overlay):not(.top-drag-overlay):not(.bottom-drag-overlay)'
      );
      const popups = document.querySelectorAll('[class*="popup"]:not(.mga-panel)');

      // More comprehensive modal detection
      const mgcModals = document.querySelectorAll('[class*="MGC"], [class*="magic-circle"]');
      const saveDiscardButtons = document.querySelectorAll('button:not(.mga-btn)');

      const totalModalElements = modals.length + overlays.length + popups.length + mgcModals.length;

      // Check for excluded drag overlays
      const dragOverlays = document.querySelectorAll('.top-drag-overlay, .bottom-drag-overlay');

      // DEBUG: Log every modal check with full details
      const modalDetails = {
        modals: modals.length,
        overlays: overlays.length,
        popups: popups.length,
        mgcElements: mgcModals.length,
        dragOverlaysExcluded: dragOverlays.length,
        total: totalModalElements,
        modalClasses: Array.from(modals).map(m => m.className),
        overlayClasses: Array.from(overlays).map(o => o.className),
        mgcClasses: Array.from(mgcModals).map(m => m.className)
      };

      if (window.MGA_DEBUG) {
        window.MGA_DEBUG.logModalEvent('MODAL_CHECK_PERFORMED', modalDetails);
      }

      // Log drag overlay exclusion
      if (dragOverlays.length > 0) {
        logInfo('INIT', `Excluding ${dragOverlays.length} game drag overlays (normal game UI, not blocking modals)`);
      }

      // DISABLED: False positive detection - game naturally has modal/overlay elements
      // This was blocking initialization and causing infinite retry loops
      // eslint-disable-next-line no-constant-condition
      if (false && totalModalElements > 0) {
        logInfo('INIT', 'Game modal system active - deferring MGA interactions', modalDetails);
        if (window.MGA_DEBUG) {
          window.MGA_DEBUG.logModalEvent('MODAL_SYSTEM_ACTIVE', modalDetails);
        }
        return false;
      }

      // SIMPLIFIED: Only block for actual modal/dialog containers, not individual buttons
      // If there are no modals/dialogs detected above, allow initialization
      logInfo('INIT', 'No blocking modals detected - MGA initialization allowed');

      return true;
    } catch (error) {
      console.error('‚ùå [MODAL-CHECK] Error in modal detection:', error);
      if (window.MGA_DEBUG) {
        window.MGA_DEBUG.logError(error, 'checkForGameModals');
      }
      return true; // Allow MGA operations if modal check fails
    }
  }

  // ==================== SCRIPT IDENTIFICATION ====================
  // DO NOT override console - causes issues in Tampermonkey sandbox

  logInfo('CONTEXT', 'Script context:', window.MGA_CONTEXT);
  logInfo('CONTEXT', 'GM API available:', isGMApiAvailable());
  logInfo('CONTEXT', 'Injection mode: page context (@inject-into page)');
  logInfo('CONTEXT', 'Selective isolation enabled - game modals preserved');

  // Add manual debug export command
  logInfo('DEBUG', 'Manual debug export: Run "MGA_DEBUG.exportDebug()" in console anytime');
  logInfo('DEBUG', 'Auto-export will trigger in 30s if issues are detected');

  // Verify debug system is working
  setTimeout(() => {
    if (typeof window.MGA_DEBUG === 'undefined') {
      console.error('‚ùå [DEBUG-VERIFY] MGA_DEBUG is not defined! Debug system failed to initialize');
      logWarn('DEBUG', 'Basic logging will continue without full debug system');
    } else {
      logInfo('DEBUG', 'MGA_DEBUG is available and working');
      logDebug('DEBUG', 'Available methods:', Object.keys(window.MGA_DEBUG));
    }
  }, 100);

  // Add modal system verification logging
  function logModalSystemStatus() {
    const initialModalCheck = checkForGameModals();
    logInfo('INIT', 'Modal isolation verification:', {
      gameModalsActive: !initialModalCheck,
      eventIsolationActive: typeof isMGAEvent === 'function',
      contextIsolationActive: typeof createMGAElement === 'function',
      targetDocumentAvailable: !!targetDocument,
      regularDocumentIntact: !!document
    });

    // Test event isolation function
    const testEvent = { target: document.body };
    const testMGAEvent = { target: { closest: () => null } };
    logDebug('INIT', 'Event isolation test:', {
      gameEventBlocked: !isMGAEvent(testEvent),
      mgaEventAllowed: !isMGAEvent(testMGAEvent) // Should be false since closest returns null
    });
  }

  // Run modal system verification after a short delay
  setTimeout(logModalSystemStatus, 100);

  // ==================== COMPREHENSIVE DEBUG SYSTEM ====================

  function createDebugLogger() {
    const debugData = {
      timestamp: new Date().toISOString(),
      loadingStages: [],
      modalEvents: [],
      contextIssues: [],
      errorLogs: [],
      performanceMetrics: {
        scriptStart: performance.now(),
        domReady: null,
        gameReady: null,
        uiCreated: null,
        fullyLoaded: null
      }
    };

    // Enhanced logging functions
    function logStage(stage, details = {}) {
      const entry = {
        timestamp: performance.now(),
        stage,
        details,
        domState: document.readyState,
        gameElements: {
          jotaiAtoms: !!(targetWindow && targetWindow.jotaiAtomCache),
          magicCircle: !!(targetWindow && targetWindow.MagicCircle_RoomConnection),
          canvas: !!document.querySelector('canvas'),
          gameContainer: !!document.querySelector('#game-container, #app, .game-wrapper, main')
        }
      };
      debugData.loadingStages.push(entry);
      logDebug('DEBUG-SYSTEM', `Stage: ${stage}`, entry);
    }

    function logModalEvent(event, details = {}) {
      const entry = {
        timestamp: performance.now(),
        event,
        details,
        gameModals: document.querySelectorAll('[class*="modal"], [class*="dialog"], [role="dialog"]').length,
        mgaElements: targetDocument.querySelectorAll('.mga-panel, .mga-toggle-btn').length
      };
      debugData.modalEvents.push(entry);
      logDebug('DEBUG-SYSTEM', `Modal Event: ${event}`, entry);
    }

    function logContextIssue(issue, details = {}) {
      const entry = {
        timestamp: performance.now(),
        issue,
        details,
        context: {
          targetWindow: targetWindow === window ? 'same' : 'different',
          targetDocument: targetDocument === document ? 'same' : 'different',
          gmApiAvailable: isGMApiAvailable()
        }
      };
      debugData.contextIssues.push(entry);
      logDebug('DEBUG-SYSTEM', `Context Issue: ${issue}`, entry);
    }

    function logError(error, context = '') {
      const entry = {
        timestamp: performance.now(),
        error: error.toString(),
        stack: error.stack,
        context
      };
      debugData.errorLogs.push(entry);
      console.error(`üêõ [DEBUG-ERROR] ${context}:`, entry);
    }

    // Store debug functions globally
    window.MGA_DEBUG = {
      logStage,
      logModalEvent,
      logContextIssue,
      logError,
      getData: () => debugData,
      exportDebug: () => {
        logInfo('DEBUG-SYSTEM', 'Complete debug data:', JSON.stringify(debugData, null, 2));
        return debugData;
      }
    };

    logStage('DEBUG_SYSTEM_INITIALIZED', {
      userAgent: navigator.userAgent,
      url: window.location.href,
      contextDetection: { targetWindow: targetWindow.constructor.name }
    });

    return window.MGA_DEBUG;
  }

  // Initialize debug system immediately with error handling
  let DEBUG;
  try {
    DEBUG = createDebugLogger();
    logInfo('DEBUG-SYSTEM', 'Debug system initialized successfully');
  } catch (error) {
    logError('DEBUG-SYSTEM', 'Failed to initialize debug system:', error);
    // Create a minimal debug fallback
    window.MGA_DEBUG = {
      logStage: (stage, details) => logDebug('DEBUG-SYSTEM', `Stage: ${stage}`, details),
      logModalEvent: (event, details) => logDebug('DEBUG-SYSTEM', `Modal Event: ${event}`, details),
      logContextIssue: (issue, details) => logDebug('DEBUG-SYSTEM', `Context Issue: ${issue}`, details),
      logError: (error, context) => logError('DEBUG-SYSTEM', `Error in ${context}:`, error),
      getData: () => ({ error: 'Debug system failed to initialize', fallback: true }),
      exportDebug: () => logWarn('DEBUG-SYSTEM', 'Debug system failed to initialize properly')
    };
    DEBUG = window.MGA_DEBUG;
  }

  // Add global error handler for comprehensive error logging
  window.addEventListener('error', event => {
    if (window.MGA_DEBUG) {
      window.MGA_DEBUG.logError(event.error || new Error(event.message), 'GLOBAL_ERROR_HANDLER');
    }
  });

  window.addEventListener('unhandledrejection', event => {
    if (window.MGA_DEBUG) {
      window.MGA_DEBUG.logError(event.reason || new Error('Unhandled Promise Rejection'), 'UNHANDLED_REJECTION');
    }
  });

  // Auto-export debug data after 30 seconds if issues detected
  setTimeout(() => {
    if (window.MGA_DEBUG) {
      const debugData = window.MGA_DEBUG.getData();
      const hasErrors = debugData.errorLogs.length > 0;
      const hasModalIssues = debugData.modalEvents.some(e => e.event === 'MODAL_SYSTEM_ACTIVE');
      const uiNotCreated = !debugData.loadingStages.some(s => s.stage === 'CREATE_UI_COMPLETED');

      if (hasErrors || hasModalIssues || uiNotCreated) {
        productionLog('üö® [AUTO-DEBUG] Issues detected - exporting debug data...');
        window.MGA_DEBUG.exportDebug();
        productionLog('üìã [AUTO-DEBUG] Copy the debug data above and paste it into mgdebug.txt');
      } else {
        productionLog('‚úÖ [AUTO-DEBUG] No issues detected in first 30 seconds');
      }
    }
  }, 30000);

  // ==================== CRITICAL EXECUTION CHECKPOINT ====================
  console.log('üîçüîçüîç [EXECUTION] Reached line 951 - About to define initialization');
  console.log('üîç typeof document:', typeof document);
  console.log('üîç typeof window:', typeof window);
  console.log('üîç document.readyState:', document?.readyState);

  // ==================== PROPER PAGE LOAD DETECTION ====================
  // Fix for document-idle timing issues - wait for complete page load
  let initializationStarted = false;

  function initializeWhenReady() {
    console.log('üîçüîçüîç [EXECUTION] initializeWhenReady() called!');
    console.log(`üîç [EXECUTION] initializationStarted = ${initializationStarted}`);
    if (initializationStarted) {
      console.log('üîç [EXECUTION] Already initialized, returning early');
      return;
    }
    initializationStarted = true;
    console.log('üîç [EXECUTION] Set initializationStarted = true');

    productionLog('üöÄ Magic Garden Unified Assistant v3.5.2 - Discord Fix');
    productionLog('üîß CRITICAL: Disabled data-destroying migration system');
    productionLog('üîß Fixed: Now uses localStorage directly (100% reliable)');
    productionLog('üîß Fixed: Active pets detection with retry logic');
    productionLog('‚úÖ Seeds + Pet Presets will now SAVE and LOAD correctly!');
    productionLog('üîß [TIMING] Page load state:', document.readyState);
    productionLog('üîß [BASIC-DEBUG] Script execution started at:', new Date().toISOString());
    productionLog('üîß [BASIC-DEBUG] Location:', window.location.href);
    productionLog('üîß [BASIC-DEBUG] User Agent:', navigator.userAgent);

    // Proceed with initialization
    console.log('üîç [EXECUTION] About to call startMGAInitialization()');
    startMGAInitialization();
    console.log('üîç [EXECUTION] startMGAInitialization() returned');
  }

  // CRITICAL FIX: Handle all readyState possibilities for Tampermonkey compatibility
  // document-idle means readyState is 'interactive' - not 'loading' or 'complete'

  console.log('üîçüîçüîç [EXECUTION] Reached line 982 - INITIALIZATION BLOCK START');
  console.log('üîç About to call productionLog for readyState...');

  try {
    productionLog('üîß [INIT] Initial readyState:', document.readyState);
  } catch (e) {
    console.error('‚ùå [EXECUTION] productionLog FAILED:', e);
  }

  // Detect Discord environment for special handling
  const isDiscordEnv =
    window.location.host.includes('discordsays.com') ||
    window.location.host.includes('discord.com') ||
    typeof window.DiscordNative !== 'undefined' ||
    typeof window.__DISCORD__ !== 'undefined';

  if (isDiscordEnv) {
    productionLog('üéÆ [DISCORD] Discord environment detected, using specialized initialization');
  }

  // Discord Fix: Use shorter delay for Discord, check for canvas existence
  const initDelay = isDiscordEnv ? 500 : 3000;

  // Helper function to check if game canvas is ready
  function isGameCanvasReady() {
    const canvas = document.querySelector('canvas');
    const gameContainer = document.querySelector('#game-container, #app, .game-wrapper, main, body');
    const ready = canvas && gameContainer;
    if (!ready && isDiscordEnv) {
      productionLog('‚è≥ [DISCORD] Waiting for game canvas...');
    }
    return ready;
  }

  // Discord Fix: Wait for canvas with retry mechanism
  function initWithCanvasCheck(attempt = 0) {
    console.log(`üîç [EXECUTION] initWithCanvasCheck called, attempt=${attempt}`);
    if (isGameCanvasReady()) {
      console.log('üîç [EXECUTION] Canvas ready! Calling initializeWhenReady()');
      productionLog('‚úÖ [INIT] Game canvas detected, initializing MGTools');
      initializeWhenReady();
    } else if (attempt < 20) {
      // Retry up to 20 times (10 seconds) for Discord
      console.log(`üîç [EXECUTION] Canvas not ready, scheduling retry ${attempt + 1}/20`);
      productionLog(`üîÑ [INIT] Canvas not ready, retry ${attempt + 1}/20`);
      setTimeout(() => initWithCanvasCheck(attempt + 1), 500);
    } else {
      console.log('üîç [EXECUTION] Max retries reached, calling initializeWhenReady() anyway');
      productionLog('‚ö†Ô∏è [INIT] Canvas not detected after 10s, initializing anyway');
      initializeWhenReady();
    }
  }

  console.log('üîç [EXECUTION] About to check document.readyState...');

  try {
    if (document.readyState === 'complete') {
      // Page is already fully loaded
      console.log('üîç [EXECUTION] readyState is complete');
      console.log(`üîç [EXECUTION] isDiscordEnv = ${isDiscordEnv}, initDelay = ${initDelay}ms`);
      productionLog(`üîß [INIT] Page already complete, initializing in ${initDelay}ms`);
      console.log(`üîç [EXECUTION] About to schedule setTimeout for ${initDelay}ms`);
      setTimeout(() => {
        console.log('üîçüîçüîç [EXECUTION] setTimeout FIRED! About to call init function...');
        if (isDiscordEnv) {
          console.log('üîç [EXECUTION] Calling initWithCanvasCheck()');
          initWithCanvasCheck();
        } else {
          console.log('üîç [EXECUTION] Calling initializeWhenReady()');
          initializeWhenReady();
        }
      }, initDelay);
    } else if (document.readyState === 'interactive') {
      console.log('üîç [EXECUTION] readyState is interactive');
      // DOM is ready but resources still loading (document-idle state)
      productionLog(`üîß [INIT] DOM interactive (document-idle), initializing in ${initDelay}ms...`);
      setTimeout(() => {
        if (isDiscordEnv) {
          initWithCanvasCheck();
        } else {
          initializeWhenReady();
        }
      }, initDelay);
    } else {
      // readyState is 'loading' - wait for full page load
      productionLog('üîß [INIT] DOM still loading, waiting for load event...');

      // Discord Fix: Use DOMContentLoaded for Discord like other scripts do
      if (isDiscordEnv) {
        document.addEventListener('DOMContentLoaded', () => {
          productionLog('‚úÖ [DISCORD] DOM ready, checking for canvas...');
          setTimeout(() => initWithCanvasCheck(), initDelay);
        });
      } else {
        window.addEventListener('load', initializeWhenReady);

        // Backup: also listen for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
          productionLog('üîß [TIMING] DOM ready, waiting for complete load...');
        });
      }
    }
  } catch (initError) {
    console.error('‚ùå‚ùå‚ùå [EXECUTION] CRITICAL ERROR in initialization block:', initError);
    console.error('Stack:', initError.stack);
    // Try to initialize anyway as fallback
    console.log('üîÑ [EXECUTION] Attempting fallback initialization in 1s...');
    setTimeout(() => {
      try {
        initializeWhenReady();
      } catch (e2) {
        console.error('‚ùå [EXECUTION] Fallback also failed:', e2);
      }
    }, 1000);
  }

  console.log('‚úÖ [EXECUTION] Initialization block completed without throwing');

  function startMGAInitialization() {
    console.log('üîçüîçüîçüîçüîç [EXECUTION] ENTERED startMGAInitialization() function!');
    console.log('üîç [EXECUTION] document.readyState:', document.readyState);
    productionLog('üöÄ [TIMING] Starting MGA initialization with readyState:', document.readyState);
    console.log('üîç [EXECUTION] productionLog completed, continuing...');

    // ==================== PROACTIVE STORAGE CLEANUP ====================
    // CRITICAL: Clean up large debug/console storage items BEFORE MGTools tries to save anything
    // This prevents quota errors on managed devices with monitoring software
    (function cleanupStorageBeforeInit() {
      try {
        const debugKeys = [
          'console-history',
          'mga-debug-cache',
          'mga-temp-cache',
          'console-insights-onboarding-finished',
          'experiments',
          'settles',
          'getItem',
          'removeItem',
          'key',
          'localInspectorVersion'
        ];

        let cleaned = 0;
        let freedBytes = 0;

        for (const key of debugKeys) {
          try {
            const value = localStorage.getItem(key);
            if (value) {
              const size = value.length;
              // Remove any item over 100KB or any console-history regardless of size
              if (size > 100000 || key.includes('console')) {
                localStorage.removeItem(key);
                cleaned++;
                freedBytes += size;
                logInfo('STORAGE-CLEANUP', `Removed ${key} (${(size / 1024).toFixed(1)}KB)`);
              }
            }
          } catch (e) {
            // Ignore errors for individual keys
          }
        }

        if (cleaned > 0) {
          logInfo('STORAGE-CLEANUP', `Freed ${(freedBytes / 1024).toFixed(1)}KB by removing ${cleaned} debug items`);
        }
      } catch (e) {
        logWarn('STORAGE-CLEANUP', 'Could not clean storage, continuing anyway', e);
      }
    })();

    // Detect other Magic Garden scripts
    setTimeout(() => {
      const hasMainScript =
        typeof window.loadJSON === 'function' ||
        typeof window.petAbilityLogs !== 'undefined' ||
        document.hidden === false;
      if (hasMainScript) {
        productionLog('üìù [COMPAT] Detected external scripts - compatibility mode enabled');
      } else {
        productionLog('üìù [COMPAT] No other Magic Garden scripts detected - running standalone');
      }
    }, 100);

    // ==================== IMMEDIATE IDLE PREVENTION ====================
    // CRITICAL: Apply idle prevention immediately before any game code runs
    (function () {
      productionLog('üö´ [IDLE-PREVENTION] Applying immediate anti-idle protection...');

      // Override document properties to prevent idle detection
      try {
        Object.defineProperty(document, 'hidden', {
          value: false,
          writable: false,
          configurable: false
        });
        Object.defineProperty(document, 'visibilityState', {
          value: 'visible',
          writable: false,
          configurable: false
        });
        productionLog('‚úÖ [IDLE-PREVENTION] Document properties overridden');
      } catch (e) {
        productionWarn('‚ö†Ô∏è [IDLE-PREVENTION] Could not override document properties:', e);
      }

      // Block idle detection events with capture phase (highest priority)
      document.addEventListener(
        'visibilitychange',
        e => {
          e.stopImmediatePropagation();
          e.preventDefault();
        },
        true
      );

      window.addEventListener(
        'blur',
        e => {
          e.stopImmediatePropagation();
          e.preventDefault();
        },
        true
      );

      window.addEventListener(
        'focus',
        e => {
          e.stopImmediatePropagation();
          e.preventDefault();
        },
        true
      );

      productionLog('‚úÖ [IDLE-PREVENTION] Event listeners added with capture phase');
    })();

    // ==================== INITIALIZATION ====================
    /* CHECKPOINT removed: INITIALIZATION_START */

    // ==================== GLOBAL STYLES ====================
    // Skip Google Fonts on Discord to avoid CSP violations
    const isDiscordPage =
      window.location.hostname.includes('discord.com') ||
      window.location.hostname.includes('discordsays.com') ||
      typeof window.DiscordNative !== 'undefined' ||
      typeof window.__DISCORD__ !== 'undefined';

    // Use empty string for Discord (system fonts only), otherwise no Google Fonts CDN
    // We never use external CDN to avoid CSP issues entirely
    const googleFontsImport = '';

    const UNIFIED_STYLES = `
          ${googleFontsImport}

          /* ==================== HYBRID DOCK STYLES ==================== */
          #mgh-dock {
              font-family: 'Inter', sans-serif;
              position: fixed;
              display: flex;
              gap: 6px;
              background: rgba(10, 10, 10, 0.9);
              backdrop-filter: blur(20px);
              border: 1px solid rgba(255, 255, 255, 0.15);
              padding: 8px 12px;
              z-index: 999999;
              box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
              /* No transition for instant drag response */
          }

          #mgh-dock.horizontal {
              bottom: 16px;
              left: 50%;
              transform: translateX(-50%);
              flex-direction: row;
              border-radius: 16px;
          }

          #mgh-dock.vertical {
              left: 16px;
              top: 20px;
              transform: none;
              flex-direction: column;
              border-radius: 16px;
              max-height: calc(100vh - 40px);
              overflow-y: auto;
              overflow-x: hidden;
          }

          /* Custom scrollbar for vertical dock */
          #mgh-dock.vertical::-webkit-scrollbar {
              width: 4px;
          }

          #mgh-dock.vertical::-webkit-scrollbar-track {
              background: transparent;
          }

          #mgh-dock.vertical::-webkit-scrollbar-thumb {
              background: rgba(255, 255, 255, 0.2);
              border-radius: 2px;
          }

          #mgh-dock.vertical::-webkit-scrollbar-thumb:hover {
              background: rgba(255, 255, 255, 0.3);
          }

          /* Scroll indicators - gradient shadows at top/bottom when scrollable */
          #mgh-dock.vertical::before,
          #mgh-dock.vertical::after {
              content: '';
              position: sticky;
              display: block;
              left: 0;
              right: 0;
              height: 20px;
              pointer-events: none;
              z-index: 10;
          }

          #mgh-dock.vertical::before {
              top: 0;
              background: linear-gradient(to bottom, rgba(31, 41, 55, 0.9), transparent);
              margin-bottom: -20px;
          }

          #mgh-dock.vertical::after {
              bottom: 0;
              background: linear-gradient(to top, rgba(31, 41, 55, 0.9), transparent);
              margin-top: -20px;
          }

          .mgh-dock-item {
              width: 44px;
              height: 44px;
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.57);
              border-radius: 10px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              cursor: pointer;
              transition: all 0.3s ease;
              position: relative;
          }

          .mgh-dock-item:hover {
              background: rgba(255, 255, 255, 0.15);
              transform: scale(1.1);
          }

          .mgh-dock-item.active {
              background: rgba(102, 126, 234, 0.3);
              border-color: #667eea;
          }

          .mgh-dock-item.flip-toggle {
              background: rgba(255, 255, 255, 0.08);
              font-size: 14px;
          }

          .mgh-dock-item.flip-toggle:hover {
              background: rgba(255, 255, 255, 0.12);
          }

          /* Optimized sizes for vertical mode */
          #mgh-dock.vertical .mgh-dock-item {
              width: 40px;
              height: 40px;
          }

          #mgh-dock.vertical .mgh-dock-item img {
              /* FIX: Match scriptwithicons sizing exactly */
              width: 24px;
              height: 24px;
          }

          #mgh-dock.vertical .mgh-dock-item {
              font-size: 20px;
          }

          /* ==================== DOCK SIZE VARIANTS ==================== */
          /* Micro size (0.50x scale - smallest) */
          #mgh-dock.dock-size-micro.horizontal .mgh-dock-item {
              width: 22px;
              height: 22px;
              font-size: 10px;
          }

          #mgh-dock.dock-size-micro.vertical .mgh-dock-item {
              width: 20px;
              height: 20px;
              font-size: 11px;
          }

          #mgh-dock.dock-size-micro .mgh-dock-item img {
              width: 12px;
              height: 12px;
          }

          /* Mini size (0.61x scale) */
          #mgh-dock.dock-size-mini.horizontal .mgh-dock-item {
              width: 27px;
              height: 27px;
              font-size: 12px;
          }

          #mgh-dock.dock-size-mini.vertical .mgh-dock-item {
              width: 25px;
              height: 25px;
              font-size: 13px;
          }

          #mgh-dock.dock-size-mini .mgh-dock-item img {
              width: 15px;
              height: 15px;
          }

          /* Tiny size (0.73x scale) */
          #mgh-dock.dock-size-tiny.horizontal .mgh-dock-item {
              width: 32px;
              height: 32px;
              font-size: 14px;
          }

          #mgh-dock.dock-size-tiny.vertical .mgh-dock-item {
              width: 30px;
              height: 30px;
              font-size: 15px;
          }

          #mgh-dock.dock-size-tiny .mgh-dock-item img {
              width: 18px;
              height: 18px;
          }

          /* Small size (0.86x scale) */
          #mgh-dock.dock-size-small.horizontal .mgh-dock-item {
              width: 38px;
              height: 38px;
              font-size: 16px;
          }

          #mgh-dock.dock-size-small.vertical .mgh-dock-item {
              width: 36px;
              height: 36px;
              font-size: 17px;
          }

          #mgh-dock.dock-size-small .mgh-dock-item img {
              width: 21px;
              height: 21px;
          }

          /* Medium size (1.0x scale - default, already defined above) */
          /* No additional CSS needed - uses base .mgh-dock-item styles */

          /* Large size (1.18x scale) */
          #mgh-dock.dock-size-large.horizontal .mgh-dock-item {
              width: 52px;
              height: 52px;
              font-size: 22px;
          }

          #mgh-dock.dock-size-large.vertical .mgh-dock-item {
              width: 48px;
              height: 48px;
              font-size: 24px;
          }

          #mgh-dock.dock-size-large .mgh-dock-item img {
              width: 28px;
              height: 28px;
          }

          .mgh-tooltip {
              position: absolute;
              background: rgba(10, 10, 10, 0.95);
              padding: 6px 10px;
              border-radius: 6px;
              font-size: 11px;
              color: white;
              white-space: nowrap;
              opacity: 0;
              pointer-events: none;
              transition: opacity 0.2s;
              border: 1px solid rgba(255, 255, 255, 0.57);
              z-index: 10;
          }

          #mgh-dock.horizontal .mgh-tooltip {
              bottom: 56px;
              left: 50%;
              transform: translateX(-50%);
          }

          #mgh-dock.vertical .mgh-tooltip {
              left: 56px;
              top: 50%;
              transform: translateY(-50%);
          }

          .mgh-dock-item:hover .mgh-tooltip { opacity: 1; }

          .mgh-tail-group {
              display: flex;
              gap: 6px;
              transition: opacity 0.3s ease;
          }

          #mgh-dock.horizontal .mgh-tail-group {
              flex-direction: row;
          }

          #mgh-dock.vertical .mgh-tail-group {
              flex-direction: column;
          }

          /* ==================== SIDEBAR STYLES ==================== */
          #mgh-sidebar {
              font-family: 'Inter', sans-serif;
              position: fixed;
              left: -420px;
              top: 0;
              width: 400px;
              height: 100vh;
              background: rgba(10, 10, 10, 0.95);
              backdrop-filter: blur(20px);
              border-right: 1px solid rgba(255, 255, 255, 0.15);
              z-index: 999998;
              transition: left 0.3s ease;
              display: flex;
              flex-direction: column;
              box-shadow: 4px 0 24px rgba(0, 0, 0, 0.6);
          }

          #mgh-sidebar.open { left: 0; }

          /* ==================== SHOP SIDEBAR STYLES ==================== */
          .mga-shop-sidebar {
              font-family: 'Inter', sans-serif;
              position: fixed;
              top: 0;
              width: 380px;
              height: 100vh;
              background: rgba(10, 10, 10, 0.95);
              backdrop-filter: blur(20px);
              border: 1px solid rgba(255, 255, 255, 0.15);
              z-index: 999998;
              transition: left 0.3s ease, right 0.3s ease;
              display: flex;
              flex-direction: column;
              box-shadow: 0 0 24px rgba(0, 0, 0, 0.6);
          }

          .mga-shop-sidebar-left {
              left: -400px;
              border-right: 1px solid rgba(255, 255, 255, 0.15);
          }

          .mga-shop-sidebar-left.open {
              left: 0;
          }

          .mga-shop-sidebar-right {
              right: -400px;
              border-left: 1px solid rgba(255, 255, 255, 0.15);
          }

          .mga-shop-sidebar-right.open {
              right: 0;
          }

          .mga-shop-sidebar-header {
              padding: 20px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.57);
              display: flex;
              justify-content: space-between;
              align-items: center;
              background: rgba(20, 20, 20, 0.5);
          }

          .mgh-sidebar-header {
              padding: 20px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.57);
              display: flex;
              justify-content: space-between;
              align-items: center;
          }

          .mgh-sidebar-title {
              font-size: 16px;
              font-weight: 600;
              color: white;
          }

          .mgh-sidebar-close {
              width: 32px;
              height: 32px;
              background: transparent;
              border: 1px solid rgba(255, 255, 255, 0.73);
              border-radius: 8px;
              color: rgba(255, 255, 255, 0.7);
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              transition: all 0.2s;
          }

          .mgh-sidebar-close:hover {
              background: rgba(255, 255, 255, 0.57);
              color: white;
          }

          .mgh-sidebar-body {
              flex: 1;
              padding: 20px;
              overflow-y: auto;
              color: white;
          }

          .mgh-sidebar-body::-webkit-scrollbar { width: 6px; }
          .mgh-sidebar-body::-webkit-scrollbar-thumb {
              background: rgba(255, 255, 255, 0.73);
              border-radius: 3px;
          }

          /* ==================== PRESERVE ORIGINAL MGA STYLES ==================== */
          .mga-btn {
              background: rgba(255, 255, 255, 0.57);
              border: 1px solid rgba(255, 255, 255, 0.73);
              color: #ffffff;
              padding: 6px 12px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 13px;
              transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
              outline: none !important;
          }

          .mga-btn:hover {
              background: rgba(255, 255, 255, 0.2);
              border-color: rgba(74, 158, 255, 0.6);
              box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
          }

          .mga-input, .mga-select {
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.2);
              color: #ffffff;
              padding: 6px 12px;
              border-radius: 6px;
              font-size: 13px;
              font-family: inherit;
          }

          .mga-input:focus, .mga-select:focus {
              outline: none;
              border-color: rgba(102, 126, 234, 0.5);
              background: rgba(255, 255, 255, 0.08);
          }

          .mga-select option {
              background: rgba(20, 20, 20, 0.95);
              color: #ffffff;
              padding: 8px;
          }

          .mga-select option:hover {
              background: rgba(74, 158, 255, 0.3);
          }

          .mga-select optgroup {
              background: rgba(0, 0, 0, 0.5);
              color: #4a9eff;
              font-weight: bold;
              font-size: 11px;
              padding: 6px;
              border-top: 1px solid rgba(255, 255, 255, 0.57);
          }

          /* Shop item name colors */
          .shop-color-white { color: #ffffff !important; }
          .shop-color-green { color: #2afd23ff !important; }
          .shop-color-blue { color: #0084ffff !important; }
          .shop-color-yellow { color: #fced19ff !important; }
          .shop-color-purple { color: #774cb3 !important; }
          .shop-color-orange { color: #ff7300ff !important; }

          /* Rainbow text for celestial items */
          .shop-rainbow-text {
              background: linear-gradient(90deg,
                  #ff0000, #ff7b00, #ffd800, #3cff2a, #00b5ff, #774cb3, #ff2ab7, #ff0000);
              background-size: 200% 100%;
              background-repeat: repeat;
              -webkit-background-clip: text;
              background-clip: text;
              color: transparent !important;
              animation: shopRainbowShift 3s linear infinite;
              font-weight: 700;
              -webkit-font-smoothing: antialiased;
              -moz-osx-font-smoothing: grayscale;
          }

          @keyframes shopRainbowShift {
              0%   { background-position: 0% 50%; }
              100% { background-position: 200% 50%; }
          }

          /* ========== TEXTURE ANIMATIONS ========== */
          @keyframes textureSlowDrift {
              0%   { background-position: 0px 0px, 0 0; }
              100% { background-position: 200px 200px, 0 0; }
          }

          @keyframes hologramScan {
              0%   { background-position: 0 0, 0 0; }
              100% { background-position: 0 100%, 0 0; }
          }

          @keyframes energyPulse {
              0%   { background-position: 0% 0%, 0% 0%, 0% 0%, 0 0; }
              50%  { background-position: 100% 0%, 100% 100%, 0% 100%, 0 0; }
              100% { background-position: 0% 0%, 0% 0%, 0% 0%, 0 0; }
          }

          .mga-texture-animated {
              animation: textureSlowDrift 60s linear infinite;
          }

          /* Shop sprite sizing */
          .shop-sprite {
              width: 28px;
              height: 28px;
              border-radius: 6px;
              object-fit: contain;
              flex-shrink: 0;
              background: rgba(255, 255, 255, 0.02);
              transition: transform 0.12s ease, box-shadow 0.12s ease;
          }

          .shop-item.in-stock .shop-sprite {
              transform: scale(1.04);
              box-shadow: 0 4px 10px rgba(0, 255, 42, 0.07);
          }

          /* Original overlay styles preserved */
          .mga-overlay {
              position: fixed;
              background: rgba(17, 24, 39, 0.95);
              border: 1px solid rgba(255, 255, 255, 0.57);
              border-radius: 12px;
              padding: 20px;
              color: #ffffff;
              z-index: 10001;
              box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
          }

          /* Popout widget styles */
          .mgh-popout {
              font-family: 'Inter', sans-serif;
              position: fixed;
              background: rgba(10, 10, 10, 0.95);
              backdrop-filter: blur(20px);
              border: 1px solid rgba(255, 255, 255, 0.15);
              border-radius: 12px;
              box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
              z-index: 1000000;
              min-width: 320px;
              width: 400px; /* Default width, resizable */
              height: 400px; /* Default height, resizable */
              display: flex;
              flex-direction: column;
              /* No transition for instant drag response */
          }

          .mgh-popout-header {
              padding: 12px 16px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.57);
              display: flex;
              align-items: center;
              justify-content: space-between;
              cursor: grab;
              user-select: none;
              background: rgba(20, 20, 20, 0.5);
              flex-shrink: 0;
          }

          .mgh-popout-header:active {
              cursor: grabbing;
          }

          .mgh-popout-body {
              padding: 16px;
              color: white;
              flex: 1;
              min-height: 0;
              overflow-y: auto;
          }

          /* ==================== PET MANAGEMENT STYLES ==================== */
          .mga-section {
              margin-bottom: 20px;
          }

          .mga-section-title {
              font-size: 14px;
              font-weight: 600;
              color: rgba(255, 255, 255, 0.9);
              margin-bottom: 12px;
              padding-bottom: 8px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.57);
          }

          .mga-pet-section-title {
              background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
              -webkit-background-clip: text;
              -webkit-text-fill-color: transparent;
              background-clip: text;
          }

          /* Active Pets Display */
          .mga-active-pets-display {
              background: rgba(255, 255, 255, 0.03);
              border: 1px solid rgba(255, 255, 255, 0.57);
              border-radius: 8px;
              padding: 12px;
              margin-bottom: 12px;
          }

          .mga-active-pets-header {
              color: #93c5fd;
              font-size: 12px;
              margin-bottom: 8px;
              font-weight: 500;
          }

          .mga-active-pets-list {
              display: flex;
              flex-wrap: wrap;
              gap: 8px;
          }

          .mga-pet-slot {
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 4px;
          }

          .mga-pet-badge {
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              padding: 6px 12px;
              border-radius: 6px;
              font-size: 12px;
              font-weight: 600;
              white-space: nowrap;
              box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
              transition: all 0.2s ease;
          }

          .mga-pet-badge:hover {
              transform: translateY(-2px);
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
          }

          .mga-hunger-timer {
              font-size: 11px;
              font-weight: 600;
              padding: 2px 6px;
              border-radius: 4px;
              background: rgba(0, 0, 0, 0.48);
          }

          /* Pet Presets */
          .mga-presets-container {
              display: flex;
              flex-direction: column;
              gap: 8px;
          }

          .mga-preset {
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.57);
              border-radius: 8px;
              padding: 12px;
              transition: all 0.2s ease;
          }

          .mga-preset-clickable {
              cursor: pointer;
          }

          .mga-preset-clickable:hover {
              background: rgba(255, 255, 255, 0.55);
              border-color: #667eea;
              transform: translateY(-2px);
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.48);
          }

          .mga-preset-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 8px;
          }

          .mga-preset-name {
              font-size: 13px;
              font-weight: 600;
              color: #93c5fd;
          }

          .mga-preset-pets {
              font-size: 12px;
              color: rgba(255, 255, 255, 0.7);
              line-height: 1.5;
          }

          /* Empty State */
          .mga-empty-state {
              text-align: center;
              padding: 24px;
              color: rgba(255, 255, 255, 0.5);
          }

          .mga-empty-state-icon {
              font-size: 32px;
              margin-bottom: 8px;
              opacity: 0.5;
          }

          .mga-empty-state-title {
              font-size: 14px;
              font-weight: 600;
              color: rgba(255, 255, 255, 0.7);
              margin-bottom: 6px;
          }

          .mga-empty-state-description {
              font-size: 12px;
              color: rgba(255, 255, 255, 0.5);
              line-height: 1.5;
          }

          /* Scrollable containers */
          .mga-scrollable {
              overflow-y: auto;
          }

          .mga-scrollable::-webkit-scrollbar {
              width: 6px;
          }

          .mga-scrollable::-webkit-scrollbar-track {
              background: rgba(255, 255, 255, 0.05);
              border-radius: 3px;
          }

          .mga-scrollable::-webkit-scrollbar-thumb {
              background: rgba(255, 255, 255, 0.73);
              border-radius: 3px;
          }

          .mga-scrollable::-webkit-scrollbar-thumb:hover {
              background: rgba(255, 255, 255, 0.3);
          }
      `;

    /* CHECKPOINT removed: GLOBAL_STYLES_COMPLETE */

    // ==================== DEBUG SYSTEM ====================

    // Debug system has been consolidated into the Logger module
    // Reference CONFIG.DEBUG.FLAGS for debug settings
    // Use debugLog() and debugError() functions from Logger module
    const DEBUG_FLAGS = CONFIG.DEBUG.FLAGS;

    /* CHECKPOINT removed: DEBUG_SYSTEM_COMPLETE */

    // ==================== RESPONSIVE TEXT SCALING ====================
    // Efficient, smooth text scaling using transform instead of recalculating fonts
    function applyResponsiveTextScaling(overlay, width, height) {
      try {
        const baseWidth = 400;
        const baseHeight = 300;

        const widthScale = width / baseWidth;
        const heightScale = height / baseHeight;
        const scale = Math.min(widthScale, heightScale);

        // Clamp to reasonable values
        const clampedScale = Math.max(0.7, Math.min(1.3, scale));

        // Apply smooth GPU scaling to the overlay‚Äôs inner content
        const content = overlay.querySelector('.mga-content');
        if (content) {
          content.style.transformOrigin = 'top left';
          content.style.transform = `scale(${clampedScale})`;
        }
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to apply transform-based scaling', error, {
          overlayId: overlay.id,
          width,
          height
        });
      }
    }

    // ==================== UNIFIED STATE ====================
    // Global initialization mutex to prevent double initialization
    // Clear any stale flags from previous page load (refresh fix)
    // On normal refresh, these flags shouldn't persist, but Tampermonkey timing can cause race conditions
    const now = Date.now();
    const flagTimestamp = window._MGA_TIMESTAMP || 0;
    const flagAge = now - flagTimestamp;

    // If flags are older than 5 seconds, they're stale from a previous load
    if (flagAge > 5000) {
      productionLog('üîÑ Detected stale initialization flags, clearing...');
      try {
        delete window._MGA_INITIALIZING;
      } catch (e) {
        window._MGA_INITIALIZING = undefined;
      }
      try {
        delete window._MGA_INITIALIZED;
      } catch (e) {
        window._MGA_INITIALIZED = undefined;
      }
      try {
        delete window._MGA_TIMESTAMP;
      } catch (e) {
        window._MGA_TIMESTAMP = undefined;
      }
    }

    const forceInit = targetWindow.location.search.includes('force=true') || window._MGA_FORCE_INIT;

    if ((window._MGA_INITIALIZING || window._MGA_INITIALIZED) && !forceInit) {
      productionLog('üîí MGA already initializing or initialized, stopping duplicate execution');
      productionLog('üí° Use ?force=true in URL or MGA.forceInit() to re-initialize');
      return;
    }

    // Clear flags if forcing re-initialization
    if (forceInit) {
      productionLog('üîÑ Force initialization requested - clearing existing flags');
      window._MGA_INITIALIZED = false;
      window._MGA_FORCE_INIT = false;
    }

    // Set flags with timestamp
    window._MGA_INITIALIZING = true;
    window._MGA_TIMESTAMP = now;

    // ==================== DEFERRED CONFLICT DETECTION ====================
    // Conflict detection moved to after game initialization to prevent loading stalls

    // Legacy compatibility - reference CONFIG.DECOR_ITEMS
    const DECOR_ITEMS = CONFIG.DECOR_ITEMS;

    /* ============================================================================
     * 9. STATE MODULE - START
     * ============================================================================
     * Global state management and data persistence
     */

    /**
     * Unified global state container
     * Manages all application state, settings, and runtime data
     * @namespace UnifiedState
     */
    const UnifiedState = {
      initialized: false,
      jotaiReady: false, // NEW: Track when Jotai store is ready
      atomsSubscribed: false, // NEW: Track when atom subscriptions are active
      connectionStatus: false,
      panels: {
        main: null,
        toggle: null
      },
      activeTab: 'pets',
      // Interval Management System
      intervals: {
        autoDelete: null,
        heartbeat: null,
        activitySimulator: null,
        gameCheck: null,
        connectionCheck: null,
        autoSave: null
      },
      popoutWindows: new Set(), // Track all popout windows
      firebase: {
        app: null,
        database: null,
        reportInterval: null,
        unsubscribe: null
      },
      data: {
        petPresets: {},
        petPresetsOrder: [], // Array to maintain preset display order
        currentPresetIndex: -1, // Track position for cycling through presets
        petAbilityLogs: [],
        seedsToDelete: [],
        autoDeleteEnabled: false,
        inventoryValue: 0,
        gardenValue: 0,
        tileValue: 0,
        lastAbilityTimestamps: {},
        roomStatus: {
          counts: {}, // Store room counts {MG1: 3, MG2: 2, ...}
          currentRoom: null,
          reporterId: null
        },
        customRooms: [], // Dynamic list of tracked rooms (initialized with defaults below)
        timers: {
          seed: null,
          egg: null,
          tool: null,
          lunar: null
        },
        settings: {
          opacity: 95,
          popoutOpacity: 50,
          theme: 'default',
          gradientStyle: 'blue-purple',
          effectStyle: 'none',
          compactMode: false,
          ultraCompactMode: false,
          useInGameOverlays: true,
          notifications: {
            enabled: true,
            volume: 0.3,
            notificationType: 'epic', // Options: 'simple', 'triple', 'alarm', 'epic', 'continuous'
            previousNotificationType: 'epic', // Stores previous selection when switching to continuous
            requiresAcknowledgment: false,
            continuousEnabled: false, // Controls whether continuous option is available
            watchedSeeds: ['Carrot', 'Sunflower', 'Moonbinder', 'Dawnbinder', 'Starweaver'],
            watchedEggs: ['CommonEgg', 'MythicalEgg'],
            watchedDecor: [], // Decoration/hourly shop items
            // Pet hunger notifications
            petHungerEnabled: false,
            petHungerThreshold: 25, // Notify when hunger drops below this % (percentage of observed max)
            petHungerSound: 'double', // Different sound than shop notifications
            // Ability trigger notifications
            abilityNotificationsEnabled: false,
            watchedAbilities: [], // Legacy - kept for backward compatibility
            watchedAbilityCategories: {
              // Category-based notification control
              xpBoost: true,
              cropSizeBoost: true,
              selling: true,
              harvesting: true,
              growthSpeed: true,
              specialMutations: true,
              other: true
            },
            abilityNotificationSound: 'single', // 'single', 'double', 'triple', 'chime', 'alert', 'buzz', 'ding', 'chirp'
            abilityNotificationVolume: 0.2, // Separate volume for abilities (quieter by default)
            // Weather event notifications
            weatherNotificationsEnabled: false,
            watchedWeatherEvents: ['Snow', 'Rain', 'AmberMoon', 'Dawn'],
            // Shop UI Firebase integration toggle
            shopFirebaseEnabled: false,
            lastSeenTimestamps: {}
          },
          detailedTimestamps: true, // Show HH:MM:SS 24-hour format instead of 12-hour AM/PM
          debugMode: false, // Enable debug logging for troubleshooting
          roomDebugMode: false, // Enable detailed room API logging for troubleshooting
          hideWeather: false, // Hide weather visual effects (snow, rain, etc)
          autoFavorite: {
            enabled: false,
            species: [], // List of species names to auto-favorite
            mutations: [], // List of mutations to auto-favorite (Rainbow, Gold, Frozen, Dawnlit, Amberlit, Dawnbound, Amberbound, etc)
            petAbilities: [] // List of pet abilities to auto-favorite (Rainbow Granter, Gold Granter)
          },
          // FIX ISSUE B: Setting to hide/show instant feed buttons
          hideFeedButtons: false // Default: show feed buttons (current behavior)
        },
        hotkeys: {
          enabled: true,
          gameKeys: {
            inventory: { name: 'Open Inventory', original: 'e', custom: null },
            harvest: { name: 'Harvest/Select', original: ' ', custom: null },
            selectLeft: { name: 'Select Left Crop', original: 'x', custom: null },
            selectRight: { name: 'Select Right Crop', original: 'c', custom: null },
            hotbar1: { name: 'Hotbar Slot 1', original: '1', custom: null },
            hotbar2: { name: 'Hotbar Slot 2', original: '2', custom: null },
            hotbar3: { name: 'Hotbar Slot 3', original: '3', custom: null },
            hotbar4: { name: 'Hotbar Slot 4', original: '4', custom: null },
            hotbar5: { name: 'Hotbar Slot 5', original: '5', custom: null },
            hotbar6: { name: 'Hotbar Slot 6', original: '6', custom: null },
            hotbar7: { name: 'Hotbar Slot 7', original: '7', custom: null },
            hotbar8: { name: 'Hotbar Slot 8', original: '8', custom: null },
            hotbar9: { name: 'Hotbar Slot 9', original: '9', custom: null },
            teleportShop: { name: 'Teleport to Shop', original: 'shift+1', custom: null },
            teleportGarden: { name: 'Teleport to Garden', original: 'shift+2', custom: null },
            teleportSell: { name: 'Teleport to Sell', original: 'shift+3', custom: null },
            toggleQuickShop: { name: 'Toggle Quick Shop', original: 'ctrl+b', custom: null }
          },
          mgToolsKeys: {
            openPets: { name: 'Open Pets Tab', custom: null },
            openAbilities: { name: 'Open Abilities Tab', custom: null },
            openSeeds: { name: 'Open Seeds Tab', custom: null },
            openValues: { name: 'Open Values Tab', custom: null },
            openTimers: { name: 'Open Timers Tab', custom: null },
            openRooms: { name: 'Open Rooms Tab', custom: null },
            openShop: { name: 'Open Shop Tab', custom: null },
            cyclePresets: { name: 'Cycle Pet Presets', custom: null }
          }
        },
        petPresetHotkeys: {},
        popouts: {
          overlays: new Map(), // Track in-game overlays (Alt+key)
          windows: new Map(), // Track separate windows
          widgets: new Map() // Track shift+click popout widgets
        },
        // PAL4-style filter system
        filterMode: 'categories', // categories, byPet, custom
        abilityFilters: {
          xpBoost: true,
          cropSizeBoost: true,
          selling: true,
          harvesting: true,
          growthSpeed: true,
          specialMutations: true,
          other: true
        },
        customMode: {
          selectedAbilities: {}
        },
        petFilters: {
          selectedPets: {}
        }
      },
      atoms: {
        activePets: [], // Initialize as empty array to prevent null errors
        petAbility: null,
        inventory: null,
        currentCrop: null,
        friendBonus: 1,
        myGarden: null,
        quinoaData: null
      }
    };

    // Export UnifiedState for debugging and external access
    targetWindow.UnifiedState = UnifiedState;

    /* CHECKPOINT removed: UNIFIED_STATE_COMPLETE */

    // ==================== DEBUG FUNCTIONS ====================
    window.debugSettingsPersistence = function () {
      console.log('=== SETTINGS PERSISTENCE DEBUG ===');
      console.log('Current settings in memory:', UnifiedState.data.settings);
      console.log('Settings in GM storage:', GM_getValue('MGA_data'));
      console.log('Settings in localStorage:', localStorage.getItem('MGA_data'));
      console.log('Handlers attached:', {
        settings: !!document.querySelector('[data-handler-setup]'),
        count: document.querySelectorAll('[data-handler-setup]').length
      });
      console.log('===================================');
    };

    // Emergency save on page unload
    window.addEventListener('beforeunload', () => {
      // Force save all settings before page unload
      if (UnifiedState && UnifiedState.data) {
        try {
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog('üö® Emergency save triggered on page unload');
        } catch (error) {
          console.error('Emergency save failed:', error);
        }
      }
    });

    // ==================== ROOM STATUS & FIREBASE ====================

    const FIREBASE_CONFIG = {
      apiKey: 'AIzaSyBfFW74PLBfLIpYj5dakmKar2wRpLu1ZOA',
      authDomain: 'mg-rooms.firebaseapp.com',
      databaseURL: 'https://mg-rooms-default-rtdb.firebaseio.com',
      projectId: 'mg-rooms',
      storageBucket: 'mg-rooms.firebasestorage.app',
      messagingSenderId: '175773159635',
      appId: '1:175773159635:web:6676c5a625c3fe1da74426'
    };

    const REPORT_INTERVAL = 5000; // Report room count every 5 seconds
    const DEFAULT_ROOMS = [
      'MG1',
      'MG2',
      'MG3',
      'MG4',
      'MG5',
      'MG6',
      'MG7',
      'MG8',
      'MG9',
      'MG10',
      'MG11',
      'MG12',
      'MG13',
      'MG14',
      'MG15',
      'SLAY'
    ]; // Default tracked rooms
    // REMOVED v3.7.3: Discord activity rooms removed - they use numeric IDs and can't be joined from external browser
    // Discord users see play#1-40 natively in Discord's activity sidebar
    // Browser users should use MG1-10 rooms instead
    const DISCORD_PLAY_ROOMS = []; // Legacy constant kept for compatibility

    // ==================== ROOM REGISTRY ====================
    // Centralized room data with categories for the 2-tab interface
    const RoomRegistry = {
      discord: [
        // Garlic Bread's Server (play1-play10 - NO HYPHEN)
        { id: 'i-1425232387037462538-gc-1399110335469977781-1411124424676999308', name: 'play1', category: 'discord' },
        { id: 'i-1426213334721757305-gc-1399110335469977781-1411801827674030191', name: 'play2', category: 'discord' },
        { id: 'i-1426696111514456277-gc-1399110335469977781-1411801899489034471', name: 'play3', category: 'discord' },
        { id: 'i-1425131188074319992-gc-1399110335469977781-1411801931373875240', name: 'play4', category: 'discord' },
        { id: 'i-1426523715059056691-gc-1399110335469977781-1411801958616141864', name: 'play5', category: 'discord' },
        { id: 'i-1426962425999130785-gc-1399110335469977781-1411801990345916496', name: 'play6', category: 'discord' },
        { id: 'i-1426782888900296754-gc-1399110335469977781-1411802027255660644', name: 'play7', category: 'discord' },
        { id: 'i-1426963026216751124-gc-1399110335469977781-1411802063876128980', name: 'play8', category: 'discord' },
        { id: 'i-1426736748104515747-gc-1399110335469977781-1411802098533666837', name: 'play9', category: 'discord' },
        { id: 'i-1426972080355807252-gc-1399110335469977781-1411802136911548467', name: 'play10', category: 'discord' },

        // Magic Circle Numbered Rooms (play-2 through play-50 - WITH HYPHEN)
        { id: 'i-1416705483108257912-gc-808935495543160852-1389438720427425894', name: 'play-2', category: 'discord' },
        { id: 'i-1414738624276205699-gc-808935495543160852-1389979453957996705', name: 'play-3', category: 'discord' },
        { id: 'i-1426270545699405844-gc-808935495543160852-1389979475336233000', name: 'play-4', category: 'discord' },
        { id: 'i-1424918072380231760-gc-808935495543160852-1391350549944733768', name: 'play-5', category: 'discord' },
        { id: 'i-1424940435679477782-gc-808935495543160852-1391629723687452802', name: 'play-6', category: 'discord' },
        { id: 'i-1414738652449345536-gc-808935495543160852-1392897701087019028', name: 'play-7', category: 'discord' },
        { id: 'i-1426340656351150221-gc-808935495543160852-1417928182505672877', name: 'play-8', category: 'discord' },
        { id: 'i-1426648328271167558-gc-808935495543160852-1392928961679331541', name: 'play-9', category: 'discord' },
        { id: 'i-1424650709747499109-gc-808935495543160852-1394338319411970198', name: 'play-10', category: 'discord' },
        { id: 'i-1421249275131859125-gc-808935495543160852-1394338344753959032', name: 'play-11', category: 'discord' },
        { id: 'i-1417583142918950943-gc-808935495543160852-1394338361631703181', name: 'play-12', category: 'discord' },
        { id: 'i-1426272039320158390-gc-808935495543160852-1394714064575271032', name: 'play-13', category: 'discord' },
        { id: 'i-1421215237289545901-gc-808935495543160852-1394714079448399962', name: 'play-14', category: 'discord' },
        { id: 'i-1426260441730125874-gc-808935495543160852-1394714101065974021', name: 'play-15', category: 'discord' },
        { id: 'i-1425314797603520553-gc-808935495543160852-1394714159857270936', name: 'play-16', category: 'discord' },
        { id: 'i-1422642064910319697-gc-808935495543160852-1395445292664488088', name: 'play-17', category: 'discord' },
        { id: 'i-1425331756999118868-gc-808935495543160852-1395445357495718081', name: 'play-18', category: 'discord' },
        { id: 'i-1426661481679945920-gc-808935495543160852-1421303964225372294', name: 'play-19', category: 'discord' },
        { id: 'i-1425346474035646574-gc-808935495543160852-1395445408737788064', name: 'play-20', category: 'discord' },
        { id: 'i-1426272183986163772-gc-808935495543160852-1406700719272104188', name: 'play-21', category: 'discord' },
        { id: 'i-1418751419091124374-gc-808935495543160852-1413559836976873672', name: 'play-22', category: 'discord' },
        { id: 'i-1426656896491978895-gc-808935495543160852-1414650590323277904', name: 'play-23', category: 'discord' },
        { id: 'i-1424941680062369792-gc-808935495543160852-1414650614415102163', name: 'play-24', category: 'discord' },
        { id: 'i-1426340142351781950-gc-808935495543160852-1414650635642732564', name: 'play-25', category: 'discord' },
        { id: 'i-1426361682346901595-gc-808935495543160852-1415547820177625139', name: 'play-26', category: 'discord' },
        { id: 'i-1426942108480180385-gc-808935495543160852-1415547932303687690', name: 'play-27', category: 'discord' },
        { id: 'i-1425073932637048884-gc-808935495543160852-1415547947315236864', name: 'play-28', category: 'discord' },
        { id: 'i-1426290019294908498-gc-808935495543160852-1415550373145350183', name: 'play-29', category: 'discord' },
        { id: 'i-1425336873709998170-gc-808935495543160852-1420055125409661008', name: 'play-30', category: 'discord' },
        { id: 'i-1426645924557361315-gc-808935495543160852-1415737760005755021', name: 'play-31', category: 'discord' },
        { id: 'i-1426363145806418082-gc-808935495543160852-1415737783116628101', name: 'play-32', category: 'discord' },
        { id: 'i-1424670769790586900-gc-808935495543160852-1415737800992751696', name: 'play-33', category: 'discord' },
        { id: 'i-1426648937850474538-gc-808935495543160852-1415737817056940203', name: 'play-34', category: 'discord' },
        { id: 'i-1426634638595592222-gc-808935495543160852-1415737832332329112', name: 'play-35', category: 'discord' },
        { id: 'i-1426636340619116576-gc-808935495543160852-1415737848279335024', name: 'play-36', category: 'discord' },
        { id: 'i-1426633119934582926-gc-808935495543160852-1415737865761194066', name: 'play-37', category: 'discord' },
        { id: 'i-1426691900710322276-gc-808935495543160852-1415737879208001689', name: 'play-38', category: 'discord' },
        { id: 'i-1426659673783930890-gc-808935495543160852-1415737894144053428', name: 'play-39', category: 'discord' },
        { id: 'i-1421247473728622632-gc-808935495543160852-1415737913324605450', name: 'play-40', category: 'discord' },
        { id: 'i-1426432879709392917-gc-808935495543160852-1426432790832087211', name: 'play-41', category: 'discord' },
        { id: 'i-1426433582888648848-gc-808935495543160852-1426433415455965305', name: 'play-42', category: 'discord' },
        { id: 'i-1426434402606387240-gc-808935495543160852-1426434222825930814', name: 'play-43', category: 'discord' },
        { id: 'i-1426434430360227840-gc-808935495543160852-1426434241947893902', name: 'play-44', category: 'discord' },
        { id: 'i-1426434453651193888-gc-808935495543160852-1426434265268097025', name: 'play-45', category: 'discord' },
        { id: 'i-1426434474119397456-gc-808935495543160852-1426434292162101278', name: 'play-46', category: 'discord' },
        { id: 'i-1426434494306455603-gc-808935495543160852-1426434306888171530', name: 'play-47', category: 'discord' },
        { id: 'i-1426434520390832228-gc-808935495543160852-1426434330770804898', name: 'play-48', category: 'discord' },
        { id: 'i-1426434545942659085-gc-808935495543160852-1426434349049577553', name: 'play-49', category: 'discord' },
        { id: 'i-1426434571775381634-gc-808935495543160852-1426434382196904006', name: 'play-50', category: 'discord' },

        // Magic Circle Country/Regional Rooms
        { id: 'i-1426792268613816442-gc-808935495543160852-1413592763617775657', name: 'play-üáßüá©', category: 'discord' },
        { id: 'i-1426912200731131945-gc-808935495543160852-1413628673810239550', name: 'play-üáßüá∑', category: 'discord' },
        { id: 'i-1426725151986286703-gc-808935495543160852-1413627931644661800', name: 'play-üá®üá¶', category: 'discord' },
        { id: 'i-1426827100626751498-gc-808935495543160852-1413586163511328839', name: 'play-üá©üá™', category: 'discord' },
        { id: 'i-1426830750170484746-gc-808935495543160852-1413586384098427002', name: 'play-üá™üá∏', category: 'discord' },
        { id: 'i-1426946558137597963-gc-808935495543160852-1413589376025235508', name: 'play-üá´üáÆ', category: 'discord' },
        { id: 'i-1426458931898617916-gc-808935495543160852-1413592562136252417', name: 'play-üá´üá∑', category: 'discord' },
        { id: 'i-1426814239305240627-gc-808935495543160852-1413586233791086745', name: 'play-üá¨üáß', category: 'discord' },
        { id: 'i-1426946909162967225-gc-808935495543160852-1414314377615642904', name: 'play-üáÆüá©', category: 'discord' },
        { id: 'i-1426491363075031082-gc-808935495543160852-1413618707871301712', name: 'play-üáÆüáπ', category: 'discord' },
        { id: 'i-1424645601508851743-gc-808935495543160852-1413590129213309089', name: 'play-üáØüáµ', category: 'discord' },
        { id: 'i-1419121202450141266-gc-808935495543160852-1415708269762187294', name: 'play-üá∞üá∑', category: 'discord' },
        { id: 'i-1426943939231092838-gc-808935495543160852-1413590246691569794', name: 'play-üá≤üá≥', category: 'discord' },
        { id: 'i-1426972888908566672-gc-808935495543160852-1413622408766689373', name: 'play-üá≤üáΩ', category: 'discord' },
        { id: 'i-1424661883863953488-gc-808935495543160852-1413628856426635264', name: 'play-üá≥üá±', category: 'discord' },
        { id: 'i-1426816652437721092-gc-808935495543160852-1413628948064219236', name: 'play-üáµüá≠', category: 'discord' },
        { id: 'i-1426957485669175436-gc-808935495543160852-1413630205695512607', name: 'play-üáµüá±', category: 'discord' },
        { id: 'i-1426901797056778311-gc-808935495543160852-1413630342379880468', name: 'play-üáµüáπ', category: 'discord' },
        { id: 'i-1426887346990665869-gc-808935495543160852-1413630567003844619', name: 'play-üá∑üá¥', category: 'discord' },
        { id: 'i-1426939853031968799-gc-808935495543160852-1413630623656435742', name: 'play-üá∑üá∫', category: 'discord' },
        { id: 'i-1421302686969557062-gc-808935495543160852-1413630845351010336', name: 'play-üá∏üá™', category: 'discord' },
        { id: 'i-1426974695889502248-gc-808935495543160852-1413593072447705118', name: 'play-üáπüá≠', category: 'discord' },
        { id: 'i-1426925686738731140-gc-808935495543160852-1413630992336257034', name: 'play-üáπüá∑', category: 'discord' },
        { id: 'i-1426975329226395671-gc-808935495543160852-1413631114369695744', name: 'play-üá∫üá¶', category: 'discord' },
        { id: 'i-1426868636468084817-gc-808935495543160852-1413586285082361857', name: 'play-üá∫üá∏', category: 'discord' },
        { id: 'i-1426956652857069662-gc-808935495543160852-1413631297003737108', name: 'play-üáªüá≥', category: 'discord' },

        // Magic Circle Special Rooms
        {
          id: 'i-1424646014697267220-gc-808935495543160852-1417643699050270741',
          name: 'play-qu√©bec',
          category: 'discord'
        },
        { id: 'i-1424646193404747847-gc-808935495543160852-1389442193931571271', name: 'play', category: 'discord' }
      ],

      // Magic Circle public rooms (v3.7.4: Renamed to short codes, added MG11-15)
      magicCircle: [
        { id: 'MG1', name: 'MG1', category: 'public' },
        { id: 'MG2', name: 'MG2', category: 'public' },
        { id: 'MG3', name: 'MG3', category: 'public' },
        { id: 'MG4', name: 'MG4', category: 'public' },
        { id: 'MG5', name: 'MG5', category: 'public' },
        { id: 'MG6', name: 'MG6', category: 'public' },
        { id: 'MG7', name: 'MG7', category: 'public' },
        { id: 'MG8', name: 'MG8', category: 'public' },
        { id: 'MG9', name: 'MG9', category: 'public' },
        { id: 'MG10', name: 'MG10', category: 'public' },
        { id: 'MG11', name: 'MG11', category: 'public' },
        { id: 'MG12', name: 'MG12', category: 'public' },
        { id: 'MG13', name: 'MG13', category: 'public' },
        { id: 'MG14', name: 'MG14', category: 'public' },
        { id: 'MG15', name: 'MG15', category: 'public' },
        { id: 'SLAY', name: 'SLAY', category: 'special' }
      ],

      // Get all rooms (discord + MG + custom)
      getAllRooms() {
        const custom = (UnifiedState.data.customRooms || [])
          .filter(code => !this.discord.some(r => r.id === code) && !this.magicCircle.some(r => r.id === code))
          .map(code => ({ id: code, name: code, category: 'custom' }));
        return [...this.discord, ...this.magicCircle, ...custom];
      },

      // Get combined MG + custom rooms
      getMGAndCustomRooms() {
        const custom = (UnifiedState.data.customRooms || [])
          .filter(code => !this.discord.some(r => r.id === code) && !this.magicCircle.some(r => r.id === code))
          .map(code => ({ id: code, name: code, category: 'custom' }));
        return [...this.magicCircle, ...custom];
      }
    };

    // Expose RoomRegistry to correct window for room polling system
    // Use targetWindow (unsafeWindow in Tampermonkey, window in regular browser)
    targetWindow.RoomRegistry = RoomRegistry;

    // Detect if running in Discord environment
    function isDiscordEnvironment() {
      try {
        // Check if in Discord iframe or Discord-hosted URL
        const isIframe = window.location !== window.parent.location;
        const isDiscordHost =
          window.location.host.includes('discordsays.com') || window.location.host.endsWith('.discordsays.com');
        const isDiscordActivity = isIframe || isDiscordHost;

        if (UnifiedState.data.settings?.debugMode) {
          productionLog('[Discord Detection]', {
            isIframe,
            isDiscordHost,
            isDiscordActivity,
            host: window.location.host
          });
        }

        return isDiscordActivity;
      } catch (err) {
        console.error('Failed to detect Discord environment:', err);
        return false;
      }
    }
    // Get current room code from URL
    function getCurrentRoomCode() {
      try {
        const match = window.location.pathname.match(/\/r\/([^/]+)/);
        return match ? match[1].toUpperCase() : null;
      } catch (err) {
        console.error('Failed to get room code:', err);
        return null;
      }
    }

    // Get actual player count from game's room state
    function getActualPlayerCount() {
      try {
        const roomState = targetWindow.MagicCircle_RoomConnection?.lastRoomStateJsonable;
        if (!roomState?.child?.data?.userSlots) {
          if (UnifiedState.data.settings.roomDebugMode) {
            console.log('[Room Status] No userSlots data available', {
              hasRoomConnection: !!targetWindow.MagicCircle_RoomConnection,
              hasRoomState: !!roomState,
              hasChild: !!roomState?.child,
              hasData: !!roomState?.child?.data
            });
          }
          return null;
        }
        const userSlots = roomState.child.data.userSlots;
        const count = userSlots.filter(slot => slot !== null && slot !== undefined).length;
        if (UnifiedState.data.settings.roomDebugMode) {
          console.log('[Room Status] Player count:', count, 'userSlots:', userSlots);
        }
        return count;
      } catch (err) {
        console.error('[Room Status] Failed to get player count:', err);
        return null;
      }
    }

    // Generate unique reporter ID
    function getReporterId() {
      if (!UnifiedState.data.roomStatus.reporterId) {
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
          UnifiedState.data.roomStatus.reporterId = crypto.randomUUID();
        } else {
          UnifiedState.data.roomStatus.reporterId =
            'reporter_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
      }
      return UnifiedState.data.roomStatus.reporterId;
    }

    // Room API helpers - matches endpoint used by community scripts
    function buildRoomApiUrl(roomIdOrCode, endpoint = 'info') {
      return `${location.origin}/api/rooms/${encodeURIComponent(roomIdOrCode)}/${endpoint}`;
    }

    async function requestRoomEndpoint(roomIdOrCode, options = {}) {
      const endpoint = options.endpoint ?? 'info';
      const url = buildRoomApiUrl(roomIdOrCode, endpoint);
      const timeoutMs = options.timeoutMs ?? 10000;

      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), timeoutMs);

      try {
        const res = await Network.fetch(url, {
          method: 'GET',
          credentials: 'include',
          signal: controller.signal
        });
        const body = await res.text();
        const parsed = res.ok ? JSON.parse(body) : undefined;
        return { status: res.status, ok: res.ok, body, parsed };
      } catch (err) {
        throw new Error(`Room endpoint fetch failed: ${err.message}`);
      } finally {
        clearTimeout(timeout);
      }
    }

    // Load Firebase SDK and initialize with authentication

    async function initializeFirebase() {
      // Replaced Firebase with /info poller stub - integrates with existing listener
      try {
        const firebase = {
          __useInfo: true,
          getDatabase() {
            return {};
          },
          ref(db, path) {
            return { path };
          },
          onValue(refObj, callback) {
            let abort = false;
            const fetchInfo = async room => {
              try {
                // Use /api/rooms/{id}/info endpoint - works for both simple codes and Discord IDs
                const response = await requestRoomEndpoint(room, { endpoint: 'info', timeoutMs: 10000 });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const payload = response.parsed;
                // Extract numPlayers from response (standard pattern)
                const players = typeof payload?.numPlayers === 'number' ? payload.numPlayers : 0;
                const count = Math.max(0, Math.min(6, Math.floor(players)));

                return { count, lastUpdate: Date.now(), reporter: getReporterId() };
              } catch (err) {
                if (UnifiedState.data.settings?.roomDebugMode) {
                  console.warn(`[Room API] Failed to fetch ${room}:`, err.message);
                }
                return { count: 0, lastUpdate: Date.now(), reporter: getReporterId() };
              }
            };
            async function tick() {
              if (abort) return;
              const out = {};

              // Poll custom rooms (MG1-15, SLAY, user-added)
              for (const rc of UnifiedState.data.customRooms) {
                out[rc] = await fetchInfo(rc);
              }

              // Poll Discord rooms (play1-play50, country rooms)
              if (RoomRegistry && RoomRegistry.discord) {
                for (const room of RoomRegistry.discord) {
                  out[room.id] = await fetchInfo(room.id);
                }
              }

              const snapshot = { val: () => out };
              try {
                callback(snapshot);
              } catch (e) {
                console.error('rooms onValue cb error', e);
              }
            }
            tick();
            const iv = setInterval(tick, 5000);
            return function unsubscribe() {
              abort = true;
              clearInterval(iv);
            };
          },
          set() {
            /* no-op in /info mode */
          },
          onDisconnect() {
            return { remove() {} };
          }
        };
        productionLog('‚úÖ /info rooms mode enabled (Firebase stubbed)');
        return firebase;
      } catch (err) {
        console.error('‚ùå initializeFirebase (/info) failed', err);
        return null;
      }
    }

    // Start reporting current room's player count
    async function startRoomReporting(firebase) {
      if (firebase && firebase.__useInfo) {
        productionLog('‚ÑπÔ∏è rooms: /info mode, reporting disabled');
        return;
      }

      if (!firebase) return;

      const roomCode = getCurrentRoomCode();
      if (!roomCode) return;

      UnifiedState.data.roomStatus.currentRoom = roomCode;

      try {
        const { ref, set, onDisconnect } = firebase;
        const currentRoomRef = ref(UnifiedState.firebase.database, `roomCounts/${roomCode}`);

        // Try to report immediately, with retry logic
        let count = getActualPlayerCount();
        let retryCount = 0;
        const maxRetries = 10;

        // If no data yet, retry every 500ms for up to 5 seconds
        while (count === null && retryCount < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, 500));
          count = getActualPlayerCount();
          retryCount++;
          if (UnifiedState.data.settings.roomDebugMode) {
            console.log(`[Room Status] Retry ${retryCount}/${maxRetries} for ${roomCode}...`);
          }
        }

        if (count === null) {
          console.warn(`[Room Status] No player data available after ${maxRetries} retries for ${roomCode}`);
          // Still start the interval reporting - it will catch it later
        } else {
          await set(currentRoomRef, {
            count: count,
            lastUpdate: Date.now(),
            reporter: getReporterId()
          });

          // Update local state immediately so user sees their own room count
          if (!UnifiedState.data.roomStatus.counts) {
            UnifiedState.data.roomStatus.counts = {};
          }
          UnifiedState.data.roomStatus.counts[roomCode] = count;

          productionLog(`üìä Reported ${count} players in ${roomCode}`);
        }

        // Set up onDisconnect cleanup
        await onDisconnect(currentRoomRef).remove();

        // Start interval reporting
        // Debounced reporting: Only update Firebase if count actually changed
        let lastReportedCount = count !== null ? count : -1; // Initialize with actual count or -1 if no data yet
        let lastForceReportTime = Date.now();
        const FORCE_REPORT_INTERVAL = 60000; // Force report every 60 seconds even if no change

        UnifiedState.firebase.reportInterval = setInterval(async () => {
          try {
            const currentCount = getActualPlayerCount();

            // Skip if we don't have valid data yet
            if (currentCount === null) {
              if (UnifiedState.data.settings.roomDebugMode) {
                console.log('[Room Status] Skipping report - no player data available yet');
              }
              return;
            }

            const now = Date.now();
            const timeSinceLastReport = now - lastForceReportTime;
            const shouldForceReport = timeSinceLastReport >= FORCE_REPORT_INTERVAL;

            // Only report if count changed OR it's time for a forced update
            if (currentCount === lastReportedCount && !shouldForceReport) {
              return;
            }

            const previousCount = lastReportedCount;
            lastReportedCount = currentCount;
            lastForceReportTime = now;

            await set(currentRoomRef, {
              count: currentCount,
              lastUpdate: now,
              reporter: getReporterId()
            });

            // Update local state immediately
            UnifiedState.data.roomStatus.counts[roomCode] = currentCount;

            if (UnifiedState.data.settings.roomDebugMode) {
              console.log(
                `[Room Status] Reported count: ${currentCount} (changed from ${previousCount}, forced: ${shouldForceReport})`
              );
            }
          } catch (err) {
            console.error('Failed to report room count:', err);
          }
        }, REPORT_INTERVAL);
      } catch (err) {
        console.error('Failed to start room reporting:', err);
      }
    }

    // Listen to all room counts
    function startRoomListener(firebase) {
      if (!firebase) return;

      try {
        const { ref, onValue } = firebase;
        const allRoomsRef = ref(UnifiedState.firebase.database, 'roomCounts');

        UnifiedState.firebase.unsubscribe = onValue(allRoomsRef, snapshot => {
          const roomData = snapshot.val() || {};
          productionLog('[Room Status] Received update from Firebase:', roomData);

          // Update room counts - use the highest count from fresh data to prevent flickering
          const counts = {};
          UnifiedState.data.customRooms.forEach(roomCode => {
            if (roomData[roomCode]) {
              const age = Date.now() - (roomData[roomCode].lastUpdate || 0);
              const newCount = age < 30000 ? roomData[roomCode].count || 0 : 0;

              // Use the higher of the new count or existing count (prevents flickering from 6->0->6)
              // Only accept decreases if the data is very fresh (< 3s old) - prevents stale 0 reports from overwriting real data
              const existingCount = UnifiedState.data.roomStatus.counts[roomCode] || 0;
              if (newCount >= existingCount || age < 3000) {
                counts[roomCode] = newCount;
              } else {
                counts[roomCode] = existingCount;
              }

              productionLog(
                `[Room Status] ${roomCode}: ${counts[roomCode]} players (new: ${newCount}, existing: ${existingCount}, age: ${Math.round(age / 1000)}s)`
              );
            } else {
              counts[roomCode] = 0;
            }
          });

          UnifiedState.data.roomStatus.counts = counts;
          productionLog('[Room Status] Updated counts:', counts);

          // Update display if rooms tab is active
          updateRoomStatusDisplay();
        });

        productionLog('‚úÖ Listening to all room counts');
      } catch (err) {
        console.error('Failed to start room listener:', err);
      }
    }

    // Update room status display
    function updateRoomStatusDisplay() {
      // BUGFIX v3.7.3: Rewritten to properly handle 2-tab UI (MG vs Discord)
      // OLD: Only updated single #room-status-list (broken for 2-tab layout)
      // NEW: Re-renders entire rooms tab content for both tabs

      // BUGFIX v3.7.7: Only update if rooms tab is currently active
      if (UnifiedState.activeTab !== 'rooms') {
        productionLog('[Rooms] Rooms tab not active - skipping update');
        return;
      }

      // Find the main tab content container
      const container = document.getElementById('mga-tab-content');
      if (!container) {
        productionLog('[Rooms] Tab content container not found - skipping update');
        return;
      }

      // Re-generate complete rooms tab HTML with current state
      const freshHTML = getRoomStatusTabContent();

      // Update the container
      container.innerHTML = freshHTML;

      // Re-attach ALL event handlers after DOM update
      setupRoomJoinButtons(); // Handle ALL room interactions (join, delete, drag-drop, search, add)
      setupRoomsTabButtons(); // Handle MG/Discord tab switching

      // Update popout window if it exists
      refreshSeparateWindowPopouts('rooms');

      productionLog('[Rooms] Room status display updated successfully');
    }

    // Setup join button handlers
    function setupRoomJoinButtons() {
      document.querySelectorAll('.room-join-btn:not([data-handler-attached])').forEach(btn => {
        btn.setAttribute('data-handler-attached', 'true');
        btn.addEventListener('click', () => {
          const roomCode = btn.getAttribute('data-room');
          const host = window.location.host;
          window.location.href = `https://${host}/r/${roomCode}`;
        });
      });

      // Setup room search input - aggressive event blocking
      const searchInput = document.getElementById('room-search-input');
      if (searchInput && !searchInput.hasAttribute('data-handler-attached')) {
        searchInput.setAttribute('data-handler-attached', 'true');

        // Prevent game from stealing focus on ANY key
        let isFocused = false;
        searchInput.addEventListener('focus', () => {
          isFocused = true;
        });
        searchInput.addEventListener('blur', e => {
          // Re-focus immediately if we're supposed to be focused
          if (isFocused && searchInput.value.length >= 0) {
            e.preventDefault();
            setTimeout(() => searchInput.focus(), 0);
          } else {
            isFocused = false;
          }
        });

        // Block ALL key events from reaching game - document level capture
        ['keydown', 'keypress', 'keyup'].forEach(eventType => {
          document.addEventListener(
            eventType,
            e => {
              if (e.target === searchInput || document.activeElement === searchInput) {
                e.stopPropagation();
                e.stopImmediatePropagation();
              }
            },
            true
          );
        });

        searchInput.addEventListener('input', e => {
          const query = e.target.value.trim().toUpperCase();
          const roomList = document.getElementById('room-status-list');

          // NEVER call updateTabContent() during typing - it rebuilds everything!

          if (!query) {
            // Show all rooms without rebuilding
            const allRooms = document.querySelectorAll('.room-status-item');
            allRooms.forEach(room => (room.style.display = 'flex'));

            // Hide search result div if it exists
            const searchResult = document.getElementById('room-search-result');
            if (searchResult) searchResult.style.display = 'none';
            return;
          }

          // Check if this is a tracked room
          const isTrackedRoom = UnifiedState.data.customRooms.includes(query);

          if (isTrackedRoom) {
            // Filter tracked rooms WITHOUT rebuilding
            const roomItems = document.querySelectorAll('.room-status-item');
            roomItems.forEach(item => {
              const roomCode = item.dataset.roomCode || item.querySelector('.room-code')?.textContent;
              if (roomCode && roomCode.includes(query)) {
                item.style.display = 'flex';
              } else {
                item.style.display = 'none';
              }
            });

            // Hide search result if showing
            const searchResult = document.getElementById('room-search-result');
            if (searchResult) searchResult.style.display = 'none';
          } else {
            // Show search UI for non-tracked rooms
            let searchResultDiv = document.getElementById('room-search-result');
            if (!searchResultDiv) {
              // Create the search result div once
              searchResultDiv = document.createElement('div');
              searchResultDiv.id = 'room-search-result';
              roomList.insertBefore(searchResultDiv, roomList.firstChild);
            }

            const currentRoom = getCurrentRoomCode();
            const roomCounts = UnifiedState.data.roomStatus?.counts || {};
            const count = roomCounts[query] || 0;

            searchResultDiv.innerHTML = `
                          <div style="padding: 12px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.73); border-radius: 6px; margin-bottom: 8px;">
                              <div style="display: flex; align-items: center; justify-content: space-between;">
                                  <div style="display: flex; align-items: center; gap: 12px;">
                                      <span style="font-weight: bold; color: #e5e7eb; font-size: 14px;">${query}</span>
                                      <span style="color: ${count > 0 ? '#4ade80' : '#94a3b8'}; font-size: 13px;">${count > 0 ? `${count} online` : 'No data'}</span>
                                  </div>
                                  <button class="mga-button" onclick="window.location.href='https://${window.location.host}/r/${query}'"
                                      style="padding: 6px 14px; font-size: 12px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                      Join
                                  </button>
                              </div>
                              <div style="font-size: 10px; color: #888; margin-top: 4px;">
                                  ${count > 0 ? 'At least one MGTools user is in this room' : 'Room may be empty or no MGTools users reporting'}
                              </div>
                          </div>
                      `;
            searchResultDiv.style.display = 'block';

            // Hide all tracked rooms
            const roomItems = document.querySelectorAll('.room-status-item');
            roomItems.forEach(item => (item.style.display = 'none'));
          }
        });
      }

      // Setup add room button handler
      const addRoomBtn = document.getElementById('add-room-btn');
      const addRoomInput = document.getElementById('add-room-input');

      if (addRoomBtn && addRoomInput && !addRoomBtn.hasAttribute('data-handler-attached')) {
        addRoomBtn.setAttribute('data-handler-attached', 'true');

        const handleAddRoom = () => {
          const roomCode = addRoomInput.value.trim().toUpperCase();

          // Validate room code
          if (!roomCode) {
            alert('Please enter a room code');
            return;
          }

          // Check if already exists
          if (UnifiedState.data.customRooms.includes(roomCode)) {
            alert(`Room "${roomCode}" is already in your list`);
            return;
          }

          // Add to custom rooms
          UnifiedState.data.customRooms.push(roomCode);
          MGA_saveJSON('MGA_data', UnifiedState.data);

          console.log('[FIX_ROOMS] Added to polling:', roomCode, 'Total rooms:', UnifiedState.data.customRooms.length);

          // Clear input
          addRoomInput.value = '';

          // Immediately fetch room info instead of waiting for next poll
          (async () => {
            try {
              const apiBase = window.getGameApiBaseUrl ? window.getGameApiBaseUrl() : location.origin;
              const url = `${apiBase}/api/rooms/${encodeURIComponent(roomCode)}/info`;

              if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
                console.log('[FIX_ROOMS] Immediately fetching room info:', url);
              }

              const response = await fetch(url);
              if (response.ok) {
                const data = await response.json();

                if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
                  console.log('[FIX_ROOMS] Got immediate room data:', data);
                }

                // Extract player count and store it in UnifiedState
                if (data && typeof data.numPlayers === 'number') {
                  if (!UnifiedState.data.roomStatus) {
                    UnifiedState.data.roomStatus = { counts: {}, lastUpdate: {} };
                  }
                  if (!UnifiedState.data.roomStatus.counts) {
                    UnifiedState.data.roomStatus.counts = {};
                  }

                  UnifiedState.data.roomStatus.counts[roomCode] = Math.max(0, Math.min(6, data.numPlayers));
                  UnifiedState.data.roomStatus.lastUpdate[roomCode] = Date.now();

                  // ADDED: Save to persistent storage
                  MGA_saveJSON('MGA_roomStatus', UnifiedState.data.roomStatus);

                  if (UnifiedState.data.settings?.debugMode || UnifiedState.data.settings?.roomDebugMode) {
                    console.log(
                      '[FIX_ROOMS] Stored player count for',
                      roomCode,
                      ':',
                      UnifiedState.data.roomStatus.counts[roomCode]
                    );
                    console.log('[FIX_ROOMS] Saved roomStatus to storage');
                  }
                }

                // Update display with fresh data
                updateRoomStatusDisplay();
              } else {
                if (UnifiedState.data.settings?.debugMode || UnifiedState.data.settings?.roomDebugMode) {
                  console.warn('[FIX_ROOMS] Failed to fetch room info:', response.status);
                }
                // Still refresh display to show the room was added (will show 0/6 initially)
                updateRoomStatusDisplay();
              }
            } catch (error) {
              if (UnifiedState.data.settings?.debugMode || UnifiedState.data.settings?.roomDebugMode) {
                console.error('[FIX_ROOMS] Error fetching room info:', error);
              }
              // Still refresh display
              updateRoomStatusDisplay();
            }
          })();

          productionLog(`[Rooms] Added custom room: ${roomCode}`);
        };

        addRoomBtn.addEventListener('click', handleAddRoom);

        // Also add on Enter key
        addRoomInput.addEventListener('keypress', e => {
          if (e.key === 'Enter') {
            handleAddRoom();
          }
        });

        // Stop hotkeys from triggering when typing in add room input
        addRoomInput.addEventListener('keydown', e => {
          e.stopPropagation();
        });
        addRoomInput.addEventListener('keyup', e => {
          e.stopPropagation();
        });
        addRoomInput.addEventListener('keypress', e => {
          e.stopPropagation();
        });
      }

      // Setup delete room button handlers
      document.querySelectorAll('.room-delete-btn:not([data-handler-attached])').forEach(btn => {
        btn.setAttribute('data-handler-attached', 'true');
        btn.addEventListener('click', e => {
          e.stopPropagation(); // Don't trigger parent clicks

          const roomCode = btn.getAttribute('data-room');

          // Confirm deletion
          if (!confirm(`Remove "${roomCode}" from your tracked rooms?`)) {
            return;
          }

          // Remove from custom rooms
          UnifiedState.data.customRooms = UnifiedState.data.customRooms.filter(code => code !== roomCode);
          MGA_saveJSON('MGA_data', UnifiedState.data);

          if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
            console.log(
              '[FIX_ROOMS] Removed from polling:',
              roomCode,
              'Remaining rooms:',
              UnifiedState.data.customRooms.length
            );
          }

          // Refresh display
          updateRoomStatusDisplay();

          productionLog(`[Rooms] Removed custom room: ${roomCode}`);
        });
      });

      // Setup drag-and-drop reordering
      let draggedElement = null;
      let draggedRoomCode = null;

      document.querySelectorAll('.room-item').forEach(item => {
        // Dragstart
        item.addEventListener('dragstart', e => {
          draggedElement = item;
          draggedRoomCode = item.getAttribute('data-room');
          item.style.opacity = '0.5';
          item.style.cursor = 'grabbing';
          e.dataTransfer.effectAllowed = 'move';

          // Create transparent 1x1 canvas to completely hide drag image
          const canvas = document.createElement('canvas');
          canvas.width = 1;
          canvas.height = 1;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, 1, 1); // Transparent pixel

          // Set as drag image (offset by -10, -10 to hide completely)
          e.dataTransfer.setDragImage(canvas, -10, -10);
        });

        // Dragend
        item.addEventListener('dragend', e => {
          item.style.opacity = '1';
          item.style.cursor = 'grab';
          draggedElement = null;
          draggedRoomCode = null;
        });

        // Dragover
        item.addEventListener('dragover', e => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          if (draggedElement && draggedElement !== item) {
            // Visual feedback
            item.style.borderTop = '2px solid #4a9eff';
          }
        });

        // Dragleave
        item.addEventListener('dragleave', e => {
          item.style.borderTop = '';
        });

        // Drop
        item.addEventListener('drop', e => {
          e.preventDefault();
          item.style.borderTop = '';

          if (!draggedRoomCode || !draggedElement) return;

          const targetRoomCode = item.getAttribute('data-room');

          if (draggedRoomCode === targetRoomCode) return;

          // Reorder the customRooms array
          const newOrder = [...UnifiedState.data.customRooms];
          const draggedIndex = newOrder.indexOf(draggedRoomCode);
          const targetIndex = newOrder.indexOf(targetRoomCode);

          if (draggedIndex === -1 || targetIndex === -1) return;

          // Remove dragged item
          newOrder.splice(draggedIndex, 1);

          // Insert at new position
          const insertIndex = draggedIndex < targetIndex ? targetIndex : targetIndex;
          newOrder.splice(insertIndex, 0, draggedRoomCode);

          // Update state
          UnifiedState.data.customRooms = newOrder;
          MGA_saveJSON('MGA_data', UnifiedState.data);

          // Refresh display
          updateRoomStatusDisplay();

          productionLog(`[Rooms] Reordered: moved ${draggedRoomCode} to position ${insertIndex + 1}`);
        });
      });
    }

    // Setup rooms tab switching buttons
    function setupRoomsTabButtons() {
      document.querySelectorAll('.rooms-tab-btn:not([data-handler-attached])').forEach(btn => {
        btn.setAttribute('data-handler-attached', 'true');
        btn.addEventListener('click', () => {
          const tabName = btn.getAttribute('data-tab');

          // Update state
          UnifiedState.data.activeRoomsTab = tabName;
          MGA_saveJSON('MGA_data', UnifiedState.data);

          // Refresh the rooms display to show the correct tab
          updateRoomStatusDisplay();
        });
      });
    }

    // ==================== SIMPLE PET DETECTION ====================
    function getActivePetsFromRoomState() {
      productionLog('üîß [DEBUG] getActivePetsFromRoomState() called - checking for pets...');
      try {
        // CORRECT path: Get the actual atom value that console shows
        const roomState = targetWindow.MagicCircle_RoomConnection?.lastRoomStateJsonable;
        // Reduced logging for performance
        // productionLog('üîß [DEBUG] roomState available:', !!roomState, roomState?.child?.data ? 'data exists' : 'no data');
        if (!roomState?.child?.data) {
          productionLog('üêæ [SIMPLE-PETS] No room state data');
          return [];
        }

        // Debug: Log the actual structure (disabled for performance)
        // productionLog('üêæ [DEBUG] Actual roomState.child.data structure:', JSON.stringify(roomState.child.data, null, 2).substring(0, 500));
        // productionLog('üêæ [DEBUG] roomState.child.data keys:', Object.keys(roomState.child.data || {}));

        // Try multiple data sources in priority order
        let petData = null;

        // Source 1: Check if pet data is directly in child.data (field1, field2, field3 format)
        if (roomState.child.data.field1 !== undefined) {
          petData = roomState.child.data;
          productionLog('üêæ [SIMPLE-PETS] Found pet data in child.data directly');
        }

        // Source 2: No longer needed - using myPetSlotsAtom instead
        // Room state userSlots doesn't contain species info

        if (!petData) {
          if (UnifiedState.data.settings?.debugMode) {
            productionLog('üêæ [SIMPLE-PETS] No pet data found in room state');
          }

          // FALLBACK: Use atom data if available
          if (window.activePets && window.activePets.length > 0) {
            if (UnifiedState.data.settings?.debugMode) {
              productionLog('üêæ [FALLBACK] Using pets from myPetSlotsAtom:', window.activePets);
            }
            return window.activePets;
          }

          if (UnifiedState.data.settings?.debugMode) {
            productionLog('üêæ [SIMPLE-PETS] No pet data found in room state or atoms');
          }
          return [];
        }

        // Extract pets from field1, field2, field3 format (the actual console format)
        const pets = [];
        const fields = [petData.field1, petData.field2, petData.field3];
        fields.forEach((species, index) => {
          if (species && species !== '' && typeof species === 'string') {
            pets.push({ petSpecies: species, slot: index + 1 });
          }
        });

        productionLog('üêæ [SIMPLE-PETS] Extracted pets:', pets);
        return pets;
      } catch (error) {
        productionLog('üêæ [SIMPLE-PETS] Error:', error.message);
        return [];
      }
    }

    function updateActivePetsFromRoomState() {
      // Removed excessive debug logging to improve performance
      // productionLog('üîß [DEBUG] updateActivePetsFromRoomState() called');
      const roomPets = getActivePetsFromRoomState();
      const previousCount = UnifiedState.atoms.activePets?.length || 0;

      // CRITICAL BUGFIX: Don't overwrite if we already have better data from atom hook
      // The atom gives us FULL pet data with hunger, abilities, etc.
      // Room state only gives us petSpecies and slot - incomplete data!
      if (
        window.activePets &&
        window.activePets.length > 0 &&
        window.activePets[0] &&
        window.activePets[0].hunger !== undefined
      ) {
        // We have full atom data with hunger - preserve it!
        productionLog('üêæ [SIMPLE-PETS] Preserving existing full pet data from atom (has hunger)');

        // Only update species info if it's missing
        roomPets.forEach((roomPet, index) => {
          if (window.activePets[index] && !window.activePets[index].petSpecies && roomPet.petSpecies) {
            window.activePets[index].petSpecies = roomPet.petSpecies;
            productionLog(`üêæ [SIMPLE-PETS] Added missing species ${roomPet.petSpecies} to slot ${index + 1}`);
          }
        });

        UnifiedState.atoms.activePets = window.activePets;
        return window.activePets; // Return the good data
      }

      // Only use room state data if we have NO atom data or it's incomplete
      UnifiedState.atoms.activePets = roomPets;
      window.activePets = roomPets; // Expose globally for debugging (use window to avoid modifying page)

      const newCount = roomPets.length;
      if (newCount !== previousCount) {
        productionLog(`üêæ [SIMPLE-PETS] Pet count changed: ${previousCount} ‚Üí ${newCount}`);

        // Update UI if pets tab is active
        if (UnifiedState.activeTab === 'pets') {
          const context = document.getElementById('mga-tab-content');
          if (context && typeof updateActivePetsDisplay === 'function') {
            updateActivePetsDisplay(context);
          }
        }
      }

      return roomPets;
    }

    // ==================== INTERVAL MANAGEMENT ====================
    function setManagedInterval(name, callback, delay) {
      // Clear existing interval if it exists
      if (UnifiedState.intervals[name]) {
        clearInterval(UnifiedState.intervals[name]);
      }

      // Set new interval and store reference
      UnifiedState.intervals[name] = setInterval(callback, delay);
      debugLog('PERFORMANCE', `Created managed interval: ${name} (${delay}ms)`);
      return UnifiedState.intervals[name];
    }

    function clearManagedInterval(name) {
      if (UnifiedState.intervals[name]) {
        clearInterval(UnifiedState.intervals[name]);
        UnifiedState.intervals[name] = null;
        debugLog('PERFORMANCE', `Cleared managed interval: ${name}`);
      }
    }

    function clearAllManagedIntervals() {
      Object.keys(UnifiedState.intervals).forEach(name => {
        clearManagedInterval(name);
      });
      debugLog('PERFORMANCE', 'Cleared all managed intervals');
    }

    function trackPopoutWindow(popoutWindow) {
      UnifiedState.popoutWindows.add(popoutWindow);

      // Add cleanup listener
      popoutWindow.addEventListener('beforeunload', () => {
        UnifiedState.popoutWindows.delete(popoutWindow);
      });
    }

    function closeAllPopoutWindows() {
      UnifiedState.popoutWindows.forEach(window => {
        try {
          window.close();
        } catch (e) {
          debugError('PERFORMANCE', 'Error closing popout window', e);
        }
      });
      UnifiedState.popoutWindows.clear();
    }

    /* CHECKPOINT removed: INTERVAL_MANAGEMENT_COMPLETE */

    // ==================== ENVIRONMENT DETECTION ====================
    function detectEnvironment() {
      const environment = {
        isGameEnvironment: false,
        isStandalone: false,
        isDiscordEmbed: false,
        gameReady: false,
        url: targetWindow.location.href,
        hasJotaiAtoms: !!((targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache)?.size > 0),
        hasMagicCircleConnection: !!(
          targetWindow.MagicCircle_RoomConnection && typeof targetWindow.MagicCircle_RoomConnection === 'object'
        ),
        domain: targetWindow.location.hostname,
        readyState: document.readyState
      };

      // DEBUG: Log environment details at start
      productionLog('üîç [ENV-DEBUG] Detecting environment:', {
        domain: environment.domain,
        pathname: targetWindow.location.pathname,
        url: environment.url,
        hasAtoms: environment.hasJotaiAtoms,
        hasConnection: environment.hasMagicCircleConnection
      });

      // PRIORITY FIX: Check for game environment FIRST (before Discord check)
      // This ensures that when running inside game iframe in Discord, we detect game mode
      const gameHosts = ['magiccircle.gg', 'magicgarden.gg', 'starweaver.org', 'discordsays.com'];
      const isGameDomain = gameHosts.some(host => environment.domain.includes(host));
      const hasGamePath = targetWindow.location.pathname.includes('/r/');
      const isDiscordActivity = environment.domain.includes('discordsays.com');

      productionLog('üîç [ENV-DEBUG] Game checks:', {
        isGameDomain,
        hasGamePath,
        isDiscordActivity,
        willEnterGameMode: isGameDomain && (hasGamePath || isDiscordActivity)
      });

      // Game environment: Regular game domains with /r/ path OR Discord Activities (no /r/ needed)
      if (isGameDomain && (hasGamePath || isDiscordActivity)) {
        // We're in the game environment (works in Discord iframes, standalone, and everywhere)
        const isInIframe = window.location !== window.parent.location;
        const isDiscordDesktopApp = window.DiscordNative !== undefined;

        productionLog('üéÆ [ENV] Running in game environment:', environment.domain);
        if (isDiscordActivity) {
          productionLog('üéÆ [DISCORD-ACTIVITY] Detected Discord Activity iframe!');
        }
        productionLog('üéÆ [ENV] IsIframe:', isInIframe, '| DiscordNative:', isDiscordDesktopApp);
        environment.isGameEnvironment = true;
        environment.isStandalone = false;
        environment.gameReady =
          environment.hasJotaiAtoms && environment.hasMagicCircleConnection && document.readyState === 'complete';

        // Determine initialization strategy
        let initStrategy = 'unknown';
        if (environment.gameReady) {
          initStrategy = 'game-ready';
        } else {
          initStrategy = 'game-wait';
        }
        environment.initStrategy = initStrategy;

        return environment;
      }

      // Check if we're on Discord page (not in game iframe)
      const isDiscordDomain = environment.domain.includes('discord.com');
      if (isDiscordDomain) {
        environment.isDiscordEmbed = true;
        productionLog('üéÆ [DISCORD] Running on Discord page - looking for game iframe...');

        // Try to find the game iframe (gameHosts already includes discordsays.com)
        const gameIframes = document.querySelectorAll('iframe');
        let foundGameIframe = false;
        for (const iframe of gameIframes) {
          try {
            const iframeSrc = iframe.src || '';
            // gameHosts includes all game domains plus discordsays.com
            if (gameHosts.some(host => iframeSrc.includes(host))) {
              productionLog('‚úÖ [DISCORD] Found game iframe:', iframeSrc);
              productionLog('üí° [DISCORD] Script should be running inside that iframe');
              foundGameIframe = true;
            }
          } catch (e) {
            // Cross-origin iframe, can't access
          }
        }

        if (foundGameIframe) {
          productionLog(
            '‚ö†Ô∏è [DISCORD] On Discord page - script will only run inside the game iframe, not on Discord page itself'
          );
        } else {
          productionLog('‚ö†Ô∏è [DISCORD] On Discord page but no game iframe found yet');
        }

        // Skip initialization on Discord page - only run inside the iframe
        environment.isStandalone = false;
        environment.initStrategy = 'skip';
        return environment;
      }

      // Not a game domain or Discord - standalone mode
      environment.isGameEnvironment = false;
      environment.isStandalone = true;
      environment.gameReady = false;

      // Determine initialization strategy
      let initStrategy = 'unknown';
      if (environment.gameReady) {
        initStrategy = 'game-ready';
      } else if (environment.isGameEnvironment) {
        initStrategy = 'game-wait';
      } else {
        initStrategy = 'standalone';
      }

      environment.initStrategy = initStrategy;

      // ==================== PLATFORM & DEVICE DETECTION ====================
      window.MGA_Platform = {
        // Platform detection
        isDiscord:
          /discord|overlay|electron/i.test(navigator.userAgent) || !!(window.DiscordNative || window.__discordApp),

        isMobile:
          /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
          window.matchMedia?.('(max-width: 768px)').matches,

        isIframe: window !== window.top,

        isTouch: 'ontouchstart' in window || navigator.maxTouchPoints > 0,

        // Get current layout mode
        getLayout() {
          if (this.isMobile) return 'mobile';
          if (this.isDiscord) return 'discord';
          return 'desktop';
        },

        // Get UI scale factor based on platform
        getScaleFactor() {
          if (this.isMobile) return 0.85; // Smaller UI for mobile
          if (this.isDiscord) return 0.95; // Slightly smaller for Discord
          return 1.0; // Full size for desktop
        },

        // Apply responsive styles based on platform
        applyResponsiveStyles() {
          const layout = this.getLayout();
          const scale = this.getScaleFactor();

          const root = document.documentElement;
          root.style.setProperty('--mga-scale', scale.toString());
          root.style.setProperty('--mga-layout', layout);
          root.setAttribute('data-mga-platform', layout);

          productionLog(`[Platform] Detected: ${layout} (scale: ${scale}, touch: ${this.isTouch})`);
        },

        // Get optimized fetch timeout based on platform
        getFetchTimeout() {
          if (this.isMobile) return 8000; // Longer timeout for mobile networks
          if (this.isDiscord) return 6000; // Medium timeout for Discord
          return 5000; // Fast timeout for desktop
        },

        // Get UI animation duration based on platform
        getAnimationDuration() {
          if (this.isMobile) return 200; // Faster animations on mobile
          return 300; // Standard animations on desktop
        }
      };

      // Initialize platform detection
      MGA_Platform.applyResponsiveStyles();

      // Re-apply on resize (debounced)
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          // Re-check mobile status (window size may have changed)
          MGA_Platform.isMobile =
            /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
            window.matchMedia?.('(max-width: 768px)').matches;
          MGA_Platform.applyResponsiveStyles();
        }, 250);
      });

      // Platform-specific initialization
      if (MGA_Platform.isDiscord) {
        productionLog('[Platform] Discord mode: External resources restricted, using bundled assets');
      }

      if (MGA_Platform.isMobile) {
        productionLog('[Platform] Mobile mode: Touch-optimized UI enabled');
      }

      if (MGA_Platform.isTouch) {
        productionLog('[Platform] Touch device detected: Increasing button tap targets');
      }

      return environment;
    }

    function createDemoData() {
      // Create realistic demo data for standalone mode
      const demoData = {
        pets: [
          { petSpecies: 'Bunny', level: 15, abilities: ['Harvesting', 'Selling'], rarity: 'Common' },
          { petSpecies: 'Dragon', level: 32, abilities: ['Growth Speed', 'Special Mutations'], rarity: 'Legendary' },
          { petSpecies: 'Phoenix', level: 28, abilities: ['Selling', 'Harvesting'], rarity: 'Epic' },
          { petSpecies: 'Unicorn', level: 21, abilities: ['Growth Speed', 'Harvesting'], rarity: 'Rare' }
        ],
        inventory: {
          items: [
            { species: 'Carrot', quantity: 145, value: 20 },
            { species: 'Apple', quantity: 82, value: 73 },
            { species: 'Banana', quantity: 23, value: 1750 },
            { species: 'Dragon Fruit', quantity: 7, value: 15000 },
            { species: 'Magic Beans', quantity: 3, value: 50000 }
          ],
          totalValue: 285450
        },
        garden: [
          { species: 'Carrot', quantity: 25, value: 15 },
          { species: 'Apple', quantity: 12, value: 65 },
          { species: 'Banana', quantity: 8, value: 1200 }
        ],
        totalValue: 295875,
        abilityLogs: [
          {
            timestamp: Date.now() - 300000,
            pet: 'Dragon',
            ability: 'Growth Speed',
            description: 'Reduced growth time by 15%'
          },
          {
            timestamp: Date.now() - 240000,
            pet: 'Bunny',
            ability: 'Harvesting',
            description: 'Extra harvest yield +2 items'
          },
          {
            timestamp: Date.now() - 180000,
            pet: 'Phoenix',
            ability: 'Selling',
            description: 'Increased selling price by 8%'
          },
          {
            timestamp: Date.now() - 120000,
            pet: 'Unicorn',
            ability: 'Growth Speed',
            description: 'Reduced growth time by 12%'
          },
          {
            timestamp: Date.now() - 60000,
            pet: 'Dragon',
            ability: 'Special Mutations',
            description: 'Triggered rare mutation chance'
          }
        ]
      };

      return demoData;
    }

    /* CHECKPOINT removed: ENVIRONMENT_DETECTION_COMPLETE */

    // ==================== UTILITIES ====================
    // MGA-specific storage functions using GM_setValue/GM_getValue for reliable persistence

    // ==================== GM STORAGE SYSTEM ====================
    // Reliable storage using Tampermonkey's GM API instead of unreliable localStorage

    function MGA_loadJSON(key, fallback = null) {
      let keyLocal = key;
      // Enforce MGA_ namespace
      if (keyLocal && !String(keyLocal).startsWith('MGA_')) {
        console.error(`‚ùå [MGA-ISOLATION] CRITICAL: Attempted to load with non-MGA key: ${keyLocal}`);
        try {
          console.trace();
        } catch (_) {}
        keyLocal = 'MGA_' + keyLocal;
      }
      try {
        const gmAvailable = typeof GM_getValue === 'function' && typeof GM_setValue === 'function';

        // Collect ALL accessible localStorage contexts
        const lsMain = typeof window !== 'undefined' && window && window.localStorage ? window.localStorage : null;
        const lsTarg =
          typeof targetWindow !== 'undefined' && targetWindow && targetWindow.localStorage
            ? targetWindow.localStorage
            : null;

        const readLS = (ls, k) => {
          if (!ls) return null;
          try {
            return ls.getItem(k);
          } catch (e) {
            return null;
          }
        };

        const toStr = val => (val == null ? null : typeof val === 'string' ? val : JSON.stringify(val));
        const tryParseDeep = val => {
          if (val == null) return null;
          if (typeof val === 'string') {
            const s = val;
            if (s === '' || s === 'null' || s === 'undefined') return null;
            try {
              let first = JSON.parse(s);
              if (typeof first === 'string') {
                try {
                  first = JSON.parse(first);
                } catch (e) {
                  /* keep as string */
                }
              }
              return first;
            } catch (e) {
              return null;
            }
          }
          if (typeof val === 'object') return val;
          return null;
        };
        const score = obj => {
          if (!obj) return -1;
          if (Array.isArray(obj)) return obj.length;
          if (typeof obj === 'object') return Object.keys(obj).length;
          return 0;
        };
        const isEmpty = obj => {
          if (!obj) return true;
          if (Array.isArray(obj)) return obj.length === 0;
          if (typeof obj === 'object') return Object.keys(obj).length === 0;
          return false;
        };

        // Read raw values
        let gmRaw = null;
        try {
          gmRaw = gmAvailable ? GM_getValue(keyLocal, null) : null;
        } catch (e) {}

        const mainRaw = readLS(lsMain, keyLocal);
        const targRaw = readLS(lsTarg, keyLocal);

        // Parse candidates
        const gmParsed = typeof gmRaw === 'string' ? tryParseDeep(gmRaw) : tryParseDeep(toStr(gmRaw));
        const mainParsed = tryParseDeep(mainRaw) || tryParseDeep(toStr(mainRaw));
        const targParsed = tryParseDeep(targRaw) || tryParseDeep(toStr(targRaw));

        // Choose the best non-empty candidate
        const gmScore = score(gmParsed);
        const mnScore = score(mainParsed);
        const tgScore = score(targParsed);

        let best = null;
        let bestSrc = 'none';
        // Prioritize GM storage, then window.localStorage, then targetWindow.localStorage
        // Reject empty objects and arrays explicitly
        if (gmParsed && !isEmpty(gmParsed)) {
          best = gmParsed;
          bestSrc = 'GM';
        } else if (mainParsed && !isEmpty(mainParsed)) {
          best = mainParsed;
          bestSrc = 'WIN';
        } else if (targParsed && !isEmpty(targParsed)) {
          best = targParsed;
          bestSrc = 'TGT';
        }

        try {
          productionLog(`[STORAGE-CHOICE] ${keyLocal}: gm=${gmScore} win=${mnScore} tgt=${tgScore} chosen=${bestSrc}`);
        } catch (_) {}

        if (best && (typeof best === 'object' || Array.isArray(best))) {
          // Do NOT write during load - only read and return
          // Writing during load was overwriting newer data with older data from other storage locations
          return best;
        }

        // Nothing usable, honor fallback
        return typeof fallback === 'undefined' ? null : fallback;
      } catch (err) {
        console.error('[MGA_loadJSON] Unexpected failure for key', keyLocal, err);
        return typeof fallback === 'undefined' ? null : fallback;
      }
    }

    /* ==================== STORAGE SYNC (GM <-> localStorage) ==================== */
    /* ==================== STORAGE SYNC (GM <-> localStorage (both contexts)) ==================== */
    function _MGA_syncStorageBothWays() {
      try {
        const keys = [
          'MGA_data',
          'MGA_petPresets',
          'MGA_petPresetsOrder',
          'MGA_petAbilityLogs',
          'MGA_petAbilityLogs_archive',
          'MGA_seedsToDelete',
          'MGA_autoDeleteEnabled',
          'MGA_filterMode',
          'MGA_abilityFilters',
          'MGA_customMode',
          'MGA_petFilters',
          'MGA_petPresetHotkeys',
          'MGA_hotkeys'
        ];

        const gmAvailable = typeof GM_getValue === 'function' && typeof GM_setValue === 'function';

        const lsMain = typeof window !== 'undefined' && window && window.localStorage ? window.localStorage : null;
        const lsTarg =
          typeof targetWindow !== 'undefined' && targetWindow && targetWindow.localStorage
            ? targetWindow.localStorage
            : null;

        const readLS = (ls, k) => {
          if (!ls) return null;
          try {
            return ls.getItem(k);
          } catch (e) {
            return null;
          }
        };
        const writeLS = (ls, k, v) => {
          try {
            if (ls) ls.setItem(k, v);
          } catch (e) {}
        };

        const toStr = val => (val == null ? null : typeof val === 'string' ? val : JSON.stringify(val));
        const tryParse = s => {
          if (s == null) return null;
          try {
            const first = JSON.parse(s);
            if (typeof first === 'string') {
              try {
                return JSON.parse(first);
              } catch (e) {
                return first;
              }
            }
            return first;
          } catch (e) {
            return null;
          }
        };
        const score = obj => {
          if (!obj) return -1;
          if (Array.isArray(obj)) return obj.length;
          if (typeof obj === 'object') return Object.keys(obj).length;
          return 0;
        };
        const isEmpty = obj => {
          if (!obj) return true;
          if (Array.isArray(obj)) return obj.length === 0;
          if (typeof obj === 'object') return Object.keys(obj).length === 0;
          return false;
        };

        keys.forEach(key => {
          try {
            const gmRaw = gmAvailable ? GM_getValue(key, null) : null;
            const mainRaw = readLS(lsMain, key);
            const targRaw = readLS(lsTarg, key);

            const gmParsed = (typeof gmRaw === 'string' ? tryParse(gmRaw) : gmRaw) || tryParse(toStr(gmRaw));
            const mainParsed = tryParse(mainRaw) || tryParse(toStr(mainRaw));
            const targParsed = tryParse(targRaw) || tryParse(toStr(targRaw));

            let best = null;
            // Prioritize GM storage, reject empty data
            if (gmParsed && !isEmpty(gmParsed)) best = gmParsed;
            else if (mainParsed && !isEmpty(mainParsed)) best = mainParsed;
            else if (targParsed && !isEmpty(targParsed)) best = targParsed;

            if (best && (typeof best === 'object' || Array.isArray(best))) {
              const stable = JSON.stringify(best);
              try {
                if (gmAvailable) GM_setValue(key, stable);
              } catch (e) {}
              writeLS(lsMain, key, stable);
              writeLS(lsTarg, key, stable);
              productionLog(`[STORAGE-SYNC] ${key}: canonicalized across GM/WIN/TGT`);
            }
          } catch (innerErr) {
            console.error('[STORAGE-SYNC] Error while syncing key', key, innerErr);
          }
        });
      } catch (err) {
        console.error('[STORAGE-SYNC] Sync failed:', err);
      }
    }

    function MGA_saveJSON(key, value, retryCount = 0) {
      let keyLocal = key;
      let valueLocal = value;
      // Dedupe guard for ability logs (same pet, ability, timestamp)
      try {
        if (keyLocal === 'MGA_petAbilityLogs' && Array.isArray(valueLocal)) {
          const fp = l => {
            const t = (l && l.abilityType) || '',
              p = (l && l.petName) || '',
              ts = (l && l.timestamp) || 0;
            return t + '|' + p + '|' + String(ts);
          };
          const map = new Map();
          for (const l of valueLocal) {
            const id = l.id || fp(l);
            if (!map.has(id)) map.set(id, Object.assign({ id }, l));
          }
          valueLocal = Array.from(map.values()).sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        }
      } catch {}

      // CRITICAL: Ensure we never use external script keys
      if (keyLocal && !keyLocal.startsWith('MGA_')) {
        console.error(`‚ùå [MGA-ISOLATION] CRITICAL: Attempted to save with non-MGA key: ${keyLocal}`);
        console.error(`‚ùå [MGA-ISOLATION] This would conflict with external scripts! Adding MGA_ prefix.`);
        console.trace();
        keyLocal = 'MGA_' + keyLocal;
      }

      // PERSISTENCE GUARD v3.8.6: BLOCK premature saves during initialization (prevents data loss)
      if (window.MGA_PERSISTENCE_GUARD?.initializationSavesBlocked && keyLocal === 'MGA_data') {
        const stack = new Error().stack;
        if (stack && stack.includes('loadSavedData')) {
          productionLog('[PERSISTENCE-GUARD] Blocked premature save during initialization');
          productionLog('[PERSISTENCE-GUARD] This protects user data from being overwritten');
          productionLog('[PERSISTENCE-GUARD] Save will execute after initialization completes');
          if (UnifiedState?.data?.settings?.debugMode) {
            console.trace('Blocked save location:');
          }
          return false; // BLOCK THE SAVE
        }
      }

      const MAX_RETRIES = 3;
      const RETRY_DELAY = 100;

      try {
        // Enhanced GM API availability check
        if (!isGMApiAvailable()) {
          // Warning already shown by isGMApiAvailable(), just use fallback silently
          return MGA_saveJSON_localStorage_fallback(keyLocal, valueLocal);
        }

        // Enhanced logging for critical operations
        if (keyLocal === 'MGA_petPresets' || keyLocal === 'MGA_seedsToDelete') {
          productionLog(
            `[GM-STORAGE] Attempting to save critical data: ${keyLocal} (attempt ${retryCount + 1}/${MAX_RETRIES})`
          );
          productionLog(`[GM-STORAGE] Data type:`, typeof valueLocal);
          productionLog(`[GM-STORAGE] Data content:`, valueLocal);
        }

        // GM can store objects directly, but let's use JSON for consistency and debugging
        const jsonString = JSON.stringify(valueLocal);

        // Save using GM_setValue for reliable persistence
        GM_setValue(keyLocal, jsonString);
        productionLog(`[GM-STORAGE] GM_setValue executed for ${keyLocal}`);

        // Also write to localStorage to keep in sync
        // This prevents stale localStorage data from overriding newer GM data on load
        try {
          if (typeof localStorage !== 'undefined' && localStorage) {
            localStorage.setItem(keyLocal, jsonString);
            productionLog(`[GM-STORAGE] Also synced to localStorage for consistency`);
          }
        } catch (lsErr) {
          // Non-fatal - GM storage is source of truth
          productionWarn(`‚ö†Ô∏è [GM-STORAGE] Could not sync to localStorage (non-fatal):`, lsErr.message);
        }

        // Enhanced verification with deep check
        const verification = GM_getValue(keyLocal, null);
        if (!verification) {
          console.error(`‚ùå [GM-STORAGE] Save verification failed for ${keyLocal} - no data retrieved!`);

          // Retry logic
          if (retryCount < MAX_RETRIES - 1) {
            productionLog(`üîÑ [GM-STORAGE] Retrying save for ${keyLocal} in ${RETRY_DELAY}ms...`);
            return new Promise(resolve => {
              setTimeout(() => {
                resolve(MGA_saveJSON(key, value, retryCount + 1));
              }, RETRY_DELAY);
            });
          }

          // Final attempt failed - show user alert
          console.error(`‚ùå [GM-STORAGE] All retry attempts failed for ${keyLocal}`);
          if (keyLocal === 'MGA_petPresets' || keyLocal === 'MGA_seedsToDelete') {
            alert(`‚ö†Ô∏è Failed to save ${keyLocal.replace('MGA_', '')}! Your changes may not persist.`);
          }
          return false;
        }

        // Deep verification for critical data
        if (keyLocal === 'MGA_petPresets' || keyLocal === 'MGA_seedsToDelete') {
          try {
            const parsedVerification = JSON.parse(verification);
            const originalKeys = Object.keys(valueLocal || {}).sort();
            const savedKeys = Object.keys(parsedVerification || {}).sort();

            if (JSON.stringify(originalKeys) !== JSON.stringify(savedKeys)) {
              productionWarn(`‚ö†Ô∏è [GM-STORAGE] Data structure mismatch for ${keyLocal}, but save likely succeeded`);
            }

            productionLog(`‚úÖ [GM-STORAGE] Critical data verification passed for ${keyLocal}`);
          } catch (e) {
            productionWarn(`‚ö†Ô∏è [GM-STORAGE] Could not deep verify ${keyLocal}, but data exists`);
          }
        }

        // Success logging
        if (keyLocal === 'MGA_petPresets') {
          productionLog('[GM-STORAGE] Pet presets saved successfully');
        } else if (keyLocal.startsWith('MGA_')) {
          productionLog(`[GM-STORAGE] Saved ${keyLocal}`);
        }

        return true;
      } catch (error) {
        console.error(`‚ùå [GM-STORAGE] Failed to save ${keyLocal}:`, error);
        console.error(`‚ùå [GM-STORAGE] Error details:`, {
          name: error.name,
          message: error.message,
          gmApiAvailable: typeof GM_setValue !== 'undefined',
          retryCount: retryCount
        });

        // BUGFIX: Auto-cleanup on storage quota errors (from v1.11.3)
        const errorString = ('' + error).toLowerCase();
        if (errorString.indexOf('quota') >= 0 || errorString.indexOf('exceeded') >= 0) {
          productionLog('üßπ [STORAGE-CLEANUP] Quota exceeded - auto-cleaning debug caches...');
          const dropKeys = ['console-history', 'mga-debug-cache', 'mga-temp-cache'];
          for (let i = 0; i < dropKeys.length; i++) {
            try {
              localStorage.removeItem(dropKeys[i]);
              productionLog(`üßπ [STORAGE-CLEANUP] Removed: ${dropKeys[i]}`);
            } catch (_e) {}
          }
          // Retry save after cleanup (one time only)
          if (retryCount === 0) {
            productionLog(`üîÑ [STORAGE-CLEANUP] Retrying save after cleanup...`);
            return MGA_saveJSON(key, value, 1);
          }
        }

        // Retry on error
        if (retryCount < MAX_RETRIES - 1) {
          productionLog(`üîÑ [GM-STORAGE] Retrying save for ${keyLocal} after error...`);
          return new Promise(resolve => {
            setTimeout(() => {
              resolve(MGA_saveJSON(key, value, retryCount + 1));
            }, RETRY_DELAY);
          });
        }

        return false;
      }
    }

    // Fallback function for when GM API is not available
    function MGA_saveJSON_localStorage_fallback(key, value) {
      let valueLocal = value;
      // Dedupe for ability logs in fallback path too
      try {
        if (key === 'MGA_petAbilityLogs' && Array.isArray(valueLocal)) {
          const fp = l => {
            const t = (l && l.abilityType) || '',
              p = (l && l.petName) || '',
              ts = (l && l.timestamp) || 0;
            return t + '|' + p + '|' + String(ts);
          };
          const map = new Map();
          for (const l of valueLocal) {
            const id = l.id || fp(l);
            if (!map.has(id)) map.set(id, Object.assign({ id }, l));
          }
          valueLocal = Array.from(map.values()).sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        }
      } catch {}

      try {
        const jsonString = JSON.stringify(valueLocal);
        StorageManager.setItem(key, jsonString);

        // Simple verification
        const verification = StorageManager.getItem(key);
        if (verification === jsonString) {
          productionLog(`[FALLBACK] Successfully saved ${key} to ${StorageManager.storageType}`);
          return true;
        } else {
          console.error(`[FALLBACK] ${StorageManager.storageType} save verification failed for ${key}`);
          return false;
        }
      } catch (error) {
        // Check if it's a quota exceeded error
        const isQuotaError =
          error.name === 'QuotaExceededError' || error.message.includes('quota') || error.message.includes('exceeded');

        if (isQuotaError) {
          console.error(`[FALLBACK] localStorage quota exceeded for ${key}!`);
          console.error(`[FALLBACK] Try clearing browser console history or other localStorage data`);
          console.error(`[FALLBACK] In Chrome DevTools: Application > Storage > Clear site data`);

          // Alert user for critical data
          if (key === 'MGA_petPresets' || key === 'MGA_seedsToDelete' || key === 'MGA_data') {
            alert(
              `‚ö†Ô∏è localStorage quota exceeded!\n\nYour ${key.replace('MGA_', '')} cannot be saved.\n\nFix:\n1. Open DevTools (F12)\n2. Go to Application tab\n3. Click "Clear site data"\n4. Reload the page`
            );
          }
        } else {
          console.error(`[FALLBACK] localStorage save failed for ${key}:`, error);
        }
        return false;
      }
    }

    // ==================== STORAGE RECOVERY & BACKUP SYSTEM ====================
    // Emergency data recovery, export/import, and health checks

    /**
     * Emergency Storage Scanner - Checks ALL possible storage locations for lost data
     * @param {string} key - The storage key to search for (e.g., 'MGA_petPresets')
     * @returns {Object} - Report of what was found where
     */
    function emergencyStorageScan(key) {
      const report = {
        key: key,
        timestamp: new Date().toISOString(),
        locations: {}
      };

      // Check GM storage
      try {
        if (typeof GM_getValue === 'function') {
          const gmValue = GM_getValue(key, null);
          if (gmValue) {
            const parsed = typeof gmValue === 'string' ? JSON.parse(gmValue) : gmValue;
            const itemCount = Array.isArray(parsed) ? parsed.length : Object.keys(parsed || {}).length;
            report.locations.GM = {
              found: true,
              itemCount: itemCount,
              dataType: Array.isArray(parsed) ? 'array' : typeof parsed,
              preview: JSON.stringify(parsed).substring(0, 200)
            };
          } else {
            report.locations.GM = { found: false };
          }
        }
      } catch (e) {
        report.locations.GM = { error: e.message };
      }

      // Check window.localStorage
      try {
        if (typeof window !== 'undefined' && window.localStorage) {
          const lsValue = window.localStorage.getItem(key);
          if (lsValue) {
            try {
              const parsed = JSON.parse(lsValue);
              const itemCount = Array.isArray(parsed) ? parsed.length : Object.keys(parsed || {}).length;
              report.locations.windowLocalStorage = {
                found: true,
                itemCount: itemCount,
                dataType: Array.isArray(parsed) ? 'array' : typeof parsed,
                preview: lsValue.substring(0, 200)
              };
            } catch (parseErr) {
              report.locations.windowLocalStorage = {
                found: true,
                corrupted: true,
                rawValue: lsValue.substring(0, 200)
              };
            }
          } else {
            report.locations.windowLocalStorage = { found: false };
          }
        }
      } catch (e) {
        report.locations.windowLocalStorage = { error: e.message };
      }

      // Check targetWindow.localStorage (if different from window)
      try {
        if (
          typeof targetWindow !== 'undefined' &&
          targetWindow &&
          targetWindow !== window &&
          targetWindow.localStorage
        ) {
          const tgValue = targetWindow.localStorage.getItem(key);
          if (tgValue) {
            try {
              const parsed = JSON.parse(tgValue);
              const itemCount = Array.isArray(parsed) ? parsed.length : Object.keys(parsed || {}).length;
              report.locations.targetLocalStorage = {
                found: true,
                itemCount: itemCount,
                dataType: Array.isArray(parsed) ? 'array' : typeof parsed,
                preview: tgValue.substring(0, 200)
              };
            } catch (parseErr) {
              report.locations.targetLocalStorage = {
                found: true,
                corrupted: true,
                rawValue: tgValue.substring(0, 200)
              };
            }
          } else {
            report.locations.targetLocalStorage = { found: false };
          }
        }
      } catch (e) {
        report.locations.targetLocalStorage = { error: e.message };
      }

      return report;
    }

    /**
     * Export pet presets to JSON file for backup
     */
    function exportPetPresets() {
      try {
        const presets = UnifiedState.data.petPresets || {};
        const presetCount = Object.keys(presets).length;

        if (presetCount === 0) {
          alert('‚ö†Ô∏è No pet presets to export!\n\nCreate some presets first.');
          return;
        }

        // Create export object with metadata
        const exportData = {
          version: '3.8.8',
          exportDate: new Date().toISOString(),
          presetCount: presetCount,
          presets: presets,
          presetsOrder: UnifiedState.data.petPresetsOrder || []
        };

        // Create downloadable JSON file
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `mgtools-presets-${new Date().toISOString().split('T')[0]}.json`;
        link.click();

        // Cleanup
        URL.revokeObjectURL(url);

        productionLog(`‚úÖ [EXPORT] Successfully exported ${presetCount} pet presets`);
        alert(`‚úÖ Exported ${presetCount} pet presets!\n\nFile saved to Downloads folder.`);
      } catch (error) {
        console.error('‚ùå [EXPORT] Failed to export presets:', error);
        alert(`‚ùå Export failed!\n\nError: ${error.message}`);
      }
    }

    /**
     * Import pet presets from JSON file
     */
    function importPetPresets() {
      try {
        // Create file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';

        input.onchange = async e => {
          try {
            const file = e.target.files[0];
            if (!file) return;

            const text = await file.text();
            const importData = JSON.parse(text);

            // Validate import data
            if (!importData.presets || typeof importData.presets !== 'object') {
              throw new Error('Invalid preset file format');
            }

            const importCount = Object.keys(importData.presets).length;
            const currentCount = Object.keys(UnifiedState.data.petPresets || {}).length;

            // Ask for confirmation
            const confirmed = confirm(
              `üì• Import ${importCount} presets?\n\n` +
                `Current presets: ${currentCount}\n` +
                `Import date: ${importData.exportDate || 'Unknown'}\n` +
                `Version: ${importData.version || 'Unknown'}\n\n` +
                `‚ö†Ô∏è This will OVERWRITE your current presets!`
            );

            if (!confirmed) {
              productionLog('‚è∏Ô∏è [IMPORT] User cancelled import');
              return;
            }

            // Perform import
            UnifiedState.data.petPresets = importData.presets;
            UnifiedState.data.petPresetsOrder = importData.presetsOrder || [];

            // Save to storage
            MGA_saveJSON('MGA_petPresets', importData.presets);
            MGA_saveJSON('MGA_petPresetsOrder', importData.presetsOrder || []);

            productionLog(`‚úÖ [IMPORT] Successfully imported ${importCount} pet presets`);
            alert(`‚úÖ Imported ${importCount} presets!\n\nPage will reload to apply changes.`);

            // Reload to refresh UI
            setTimeout(() => window.location.reload(), 1000);
          } catch (error) {
            console.error('‚ùå [IMPORT] Failed to import presets:', error);
            alert(
              `‚ùå Import failed!\n\nError: ${error.message}\n\nMake sure you're importing a valid MGTools preset file.`
            );
          }
        };

        input.click();
      } catch (error) {
        console.error('‚ùå [IMPORT] Failed to create import dialog:', error);
        alert(`‚ùå Import failed!\n\nError: ${error.message}`);
      }
    }

    /**
     * Comprehensive storage health check on startup
     * @returns {Object} Health report
     */
    function performStorageHealthCheck() {
      const report = {
        timestamp: new Date().toISOString(),
        gmAvailable: false,
        localStorageAvailable: false,
        writeTest: {},
        quotaCheck: {},
        issues: []
      };

      // Check GM API availability
      try {
        if (typeof GM_setValue === 'function' && typeof GM_getValue === 'function') {
          report.gmAvailable = true;

          // Test GM write/read
          const testKey = 'MGA_health_check_test';
          const testValue = { test: true, timestamp: Date.now() };
          GM_setValue(testKey, JSON.stringify(testValue));
          const retrieved = GM_getValue(testKey, null);

          if (retrieved) {
            report.writeTest.GM = 'PASS';
            GM_deleteValue(testKey); // Cleanup
          } else {
            report.writeTest.GM = 'FAIL';
            report.issues.push('GM_setValue/GM_getValue not working properly');
          }
        } else {
          report.issues.push('GM API not available - will use localStorage fallback');
        }
      } catch (e) {
        report.writeTest.GM = 'ERROR: ' + e.message;
        report.issues.push('GM API error: ' + e.message);
      }

      // Check localStorage availability
      try {
        if (typeof localStorage !== 'undefined') {
          report.localStorageAvailable = true;

          // Test localStorage write/read
          const testKey = 'MGA_health_check_test';
          const testValue = JSON.stringify({ test: true, timestamp: Date.now() });
          localStorage.setItem(testKey, testValue);
          const retrieved = localStorage.getItem(testKey);

          // Parse and compare objects to handle serialization differences
          try {
            const retrievedObj = JSON.parse(retrieved);
            const testObj = JSON.parse(testValue);
            if (retrievedObj && retrievedObj.test === testObj.test) {
              report.writeTest.localStorage = 'PASS';
              localStorage.removeItem(testKey); // Cleanup
            } else {
              report.writeTest.localStorage = 'FAIL';
              report.issues.push('localStorage read/write mismatch');
            }
          } catch (e) {
            // If parsing fails but string matches, still pass
            if (retrieved === testValue) {
              report.writeTest.localStorage = 'PASS';
              localStorage.removeItem(testKey);
            } else {
              report.writeTest.localStorage = 'FAIL';
              report.issues.push('localStorage read/write mismatch');
            }
          }

          // Estimate quota usage (if available)
          if ('storage' in navigator && 'estimate' in navigator.storage) {
            navigator.storage.estimate().then(estimate => {
              const percentUsed = ((estimate.usage / estimate.quota) * 100).toFixed(2);
              report.quotaCheck = {
                used: estimate.usage,
                quota: estimate.quota,
                percentUsed: percentUsed,
                warning: percentUsed > 80
              };

              if (percentUsed > 80) {
                report.issues.push(`Storage ${percentUsed}% full - may cause save failures`);
              }
            });
          }
        } else {
          report.issues.push('localStorage not available');
        }
      } catch (e) {
        report.writeTest.localStorage = 'ERROR: ' + e.message;
        report.issues.push('localStorage error: ' + e.message);
      }

      return report;
    }

    // ==================== ABILITY NAME NORMALIZATION ====================
    // Fix malformed ability names (e.g., "Seed FinderII" ‚Üí "Seed Finder II")

    function normalizeAbilityName(name) {
      if (!name || typeof name !== 'string') return name;

      // Fix missing spaces before roman numerals
      const normalized = name
        .replace(/([a-z])III$/i, '$1 III') // "FinderIII" ‚Üí "Finder III"
        .replace(/([a-z])II$/i, '$1 II') // "FinderII" ‚Üí "Finder II"
        .replace(/([a-z])I$/i, '$1 I') // "FinderI" ‚Üí "Finder I"
        .replace(/produce\s*scale\s*boost/gi, 'Crop Size Boost') // Game renamed this ability
        .trim();

      // Log normalization if name was changed
      if (normalized !== name && UnifiedState.data.settings?.debugMode) {
        logDebug('ABILITY-LOGS', `üìù Normalized ability name: "${name}" ‚Üí "${normalized}"`);
      }

      return normalized;
    }

    // List of all known ability types for validation
    const KNOWN_ABILITY_TYPES = [
      // XP Boosts
      'XP Boost I',
      'XP Boost II',
      'XP Boost III',
      'Hatch XP Boost I',
      'Hatch XP Boost II',

      // Crop Size Boosts
      'Crop Size Boost I',
      'Crop Size Boost II',

      // Selling
      'Sell Boost I',
      'Sell Boost II',
      'Sell Boost III',
      'Coin Finder I',
      'Coin Finder II',

      // Harvesting
      'Harvesting',
      'Auto Harvest',

      // Growth Speed
      'Plant Growth Boost I',
      'Plant Growth Boost II',
      'Plant Growth Boost III',
      'Egg Growth Boost I',
      'Egg Growth Boost II',

      // Seeds
      'Seed Finder I',
      'Seed Finder II',
      'Special Mutations',

      // Other
      'Hunger Boost I',
      'Hunger Boost II',
      'Max Strength Boost I',
      'Max Strength Boost II'
    ];

    function isKnownAbilityType(abilityType) {
      if (!abilityType) return false;
      return KNOWN_ABILITY_TYPES.includes(abilityType);
    }

    // ==================== ABILITY LOGS DIAGNOSTIC SYSTEM ====================
    // Comprehensive diagnostic function to identify persistent ability log sources

    function MGA_diagnoseAbilityLogStorage() {
      logDebug('ABILITY-LOGS', 'üîç Starting comprehensive ability log storage diagnostic...');

      const report = {
        timestamp: new Date().toISOString(),
        sources: {}
      };

      // Helper to safely get storage
      const safeGet = (fn, label) => {
        try {
          return fn();
        } catch (e) {
          logDebug('ABILITY-LOGS', `  ‚ùå ${label}: Error - ${e.message}`);
          return null;
        }
      };

      // Helper to parse and count logs with detailed fingerprinting
      const parseAndCount = (raw, label) => {
        if (!raw) return { exists: false, count: 0, logs: [] };
        try {
          const parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;
          const count = Array.isArray(parsed) ? parsed.length : 0;

          if (Array.isArray(parsed)) {
            // Create detailed log fingerprints for identification
            const logs = parsed.map(l => {
              const abilityType = l.abilityType || 'unknown';
              const normalizedAbility = normalizeAbilityName(abilityType);
              const isKnown = isKnownAbilityType(normalizedAbility);
              const isMalformed = abilityType !== normalizedAbility;

              return {
                ability: abilityType,
                normalizedAbility: isMalformed ? normalizedAbility : null,
                isKnown,
                isMalformed,
                pet: l.petName || l.petSpecies || 'unknown',
                timestamp: l.timestamp,
                time: new Date(l.timestamp).toLocaleString(),
                // Create a unique fingerprint for this log
                fingerprint: `${abilityType}_${l.petName}_${l.timestamp}`.substring(0, 50)
              };
            });

            const malformedCount = logs.filter(l => l.isMalformed).length;
            const unknownCount = logs.filter(l => !l.isKnown).length;

            return {
              exists: true,
              count,
              logs,
              malformedCount,
              unknownCount
            };
          } else {
            return { exists: true, count: 'not-an-array', logs: [] };
          }
        } catch (e) {
          return { exists: true, count: 'parse-error', logs: [], error: e.message };
        }
      };

      // 1. GM Storage (Tampermonkey)
      const gmMain = safeGet(() => GM_getValue('MGA_petAbilityLogs', null), 'GM Main');
      const gmArchive = safeGet(() => GM_getValue('MGA_petAbilityLogs_archive', null), 'GM Archive');
      report.sources.gmStorage = {
        main: parseAndCount(gmMain, 'GM Main'),
        archive: parseAndCount(gmArchive, 'GM Archive')
      };

      // 2. Window localStorage
      const lsMain = safeGet(() => window.localStorage?.getItem('MGA_petAbilityLogs'), 'LS Main');
      const lsArchive = safeGet(() => window.localStorage?.getItem('MGA_petAbilityLogs_archive'), 'LS Archive');
      const lsClearFlag = safeGet(() => window.localStorage?.getItem('MGA_logs_manually_cleared'), 'LS Clear Flag');
      report.sources.windowLocalStorage = {
        main: parseAndCount(lsMain, 'LS Main'),
        archive: parseAndCount(lsArchive, 'LS Archive'),
        clearFlag: lsClearFlag
      };

      // 3. TargetWindow localStorage (if different from window)
      if (typeof targetWindow !== 'undefined' && targetWindow && targetWindow !== window) {
        const tgMain = safeGet(() => targetWindow.localStorage?.getItem('MGA_petAbilityLogs'), 'TG Main');
        const tgArchive = safeGet(() => targetWindow.localStorage?.getItem('MGA_petAbilityLogs_archive'), 'TG Archive');
        report.sources.targetWindowLocalStorage = {
          main: parseAndCount(tgMain, 'TG Main'),
          archive: parseAndCount(tgArchive, 'TG Archive')
        };
      }

      // 4. MGA_data nested logs
      const mgaData = safeGet(() => GM_getValue('MGA_data', null), 'MGA_data');
      if (mgaData) {
        try {
          const parsed = typeof mgaData === 'string' ? JSON.parse(mgaData) : mgaData;
          const nestedLogs = parsed?.petAbilityLogs;
          report.sources.mgaDataNested = {
            logs: parseAndCount(nestedLogs, 'MGA_data nested')
          };
        } catch (e) {
          report.sources.mgaDataNested = { error: e.message };
        }
      }

      // 5. Window compatibility array
      if (typeof window.petAbilityLogs !== 'undefined') {
        report.sources.compatibilityArray = {
          count: Array.isArray(window.petAbilityLogs) ? window.petAbilityLogs.length : 'not-an-array',
          sample: Array.isArray(window.petAbilityLogs) ? window.petAbilityLogs.slice(0, 3) : null
        };
      }

      // 6. Current memory state
      const memoryLogs = (UnifiedState.data?.petAbilityLogs || []).map(l => {
        const abilityType = l.abilityType || 'unknown';
        const normalizedAbility = normalizeAbilityName(abilityType);
        const isKnown = isKnownAbilityType(normalizedAbility);
        const isMalformed = abilityType !== normalizedAbility;

        return {
          ability: abilityType,
          normalizedAbility: isMalformed ? normalizedAbility : null,
          isKnown,
          isMalformed,
          pet: l.petName || l.petSpecies || 'unknown',
          timestamp: l.timestamp,
          time: new Date(l.timestamp).toLocaleString(),
          fingerprint: `${abilityType}_${l.petName}_${l.timestamp}`.substring(0, 50)
        };
      });

      report.sources.memory = {
        unifiedState: {
          count: memoryLogs.length,
          sample: memoryLogs // Now includes all logs with fingerprints
        }
      };

      // Calculate total across all sources
      const totals = {
        gmMain: report.sources.gmStorage.main.count || 0,
        gmArchive: report.sources.gmStorage.archive.count || 0,
        lsMain: report.sources.windowLocalStorage.main.count || 0,
        lsArchive: report.sources.windowLocalStorage.archive.count || 0,
        memory: report.sources.memory.unifiedState.count
      };

      report.summary = {
        totalLocationsWithLogs: Object.values(totals).filter(c => c > 0).length,
        totals,
        suspectSources: Object.entries(totals)
          .filter(([k, v]) => v > 0)
          .map(([k]) => k)
      };

      // Output report
      console.log('üîç ========== ABILITY LOGS STORAGE DIAGNOSTIC ==========');
      console.log('üìä Summary:', report.summary);
      console.log('');

      // Show counts for each storage location
      console.log('üìÅ GM Storage:');
      console.log('  Main:', report.sources.gmStorage.main.count, 'logs');
      console.log('  Archive:', report.sources.gmStorage.archive.count, 'logs');

      console.log('üìÅ Window localStorage:');
      console.log('  Main:', report.sources.windowLocalStorage.main.count, 'logs');
      console.log('  Archive:', report.sources.windowLocalStorage.archive.count, 'logs');
      console.log('  Clear flag:', report.sources.windowLocalStorage.clearFlag);

      if (report.sources.targetWindowLocalStorage) {
        console.log('üìÅ Target Window localStorage:');
        console.log('  Main:', report.sources.targetWindowLocalStorage.main.count, 'logs');
        console.log('  Archive:', report.sources.targetWindowLocalStorage.archive.count, 'logs');
      }

      if (report.sources.mgaDataNested) {
        console.log('üìÅ MGA_data nested:', report.sources.mgaDataNested);
      }

      if (report.sources.compatibilityArray) {
        console.log('üìÅ Compatibility array:', report.sources.compatibilityArray);
      }

      console.log('üíæ Memory:', report.sources.memory.unifiedState.count, 'logs');
      console.log('');

      // DETAILED LOG LISTING - Show individual logs from each source
      console.log('üìã ========== DETAILED LOG LISTING ==========');

      const showLogs = (title, logs) => {
        if (logs && logs.length > 0) {
          console.log(`\n${title}:`);
          logs.forEach((log, i) => {
            const prefix = log.isMalformed ? '‚ö†Ô∏è MALFORMED' : log.isKnown ? '‚úÖ' : '‚ùì UNKNOWN';
            console.log(`  ${i + 1}. ${prefix} [${log.fingerprint}]`);
            console.log(`     ${log.ability} - ${log.pet}`);
            if (log.isMalformed) {
              console.log(`     ‚Üí Should be: "${log.normalizedAbility}"`);
            }
            console.log(`     ${log.time}`);
          });
        }
      };

      showLogs('GM Storage (Main)', report.sources.gmStorage.main.logs);
      showLogs('GM Storage (Archive)', report.sources.gmStorage.archive.logs);
      showLogs('Window localStorage (Main)', report.sources.windowLocalStorage.main.logs);
      showLogs('Window localStorage (Archive)', report.sources.windowLocalStorage.archive.logs);
      if (report.sources.targetWindowLocalStorage) {
        showLogs('TargetWindow localStorage (Main)', report.sources.targetWindowLocalStorage.main.logs);
        showLogs('TargetWindow localStorage (Archive)', report.sources.targetWindowLocalStorage.archive.logs);
      }
      if (report.sources.mgaDataNested?.logs?.logs) {
        showLogs('MGA_data nested', report.sources.mgaDataNested.logs.logs);
      }
      showLogs('Memory (UnifiedState)', report.sources.memory.unifiedState.sample);

      // Count total malformed and unknown logs
      const allSources = [
        report.sources.gmStorage.main,
        report.sources.gmStorage.archive,
        report.sources.windowLocalStorage.main,
        report.sources.windowLocalStorage.archive
      ];
      if (report.sources.targetWindowLocalStorage) {
        allSources.push(report.sources.targetWindowLocalStorage.main);
        allSources.push(report.sources.targetWindowLocalStorage.archive);
      }

      const totalMalformed = allSources.reduce((sum, src) => sum + (src.malformedCount || 0), 0);
      const totalUnknown = allSources.reduce((sum, src) => sum + (src.unknownCount || 0), 0);

      console.log('\n=======================================================');
      console.log('üí° TIPS:');
      console.log('  ‚Ä¢ Look for logs with identical fingerprints across multiple storage locations');
      console.log('  ‚Ä¢ If a log persists after clear, check which storage still contains it');
      if (totalMalformed > 0) {
        console.log(`  ‚Ä¢ ‚ö†Ô∏è Found ${totalMalformed} MALFORMED ability name(s) - missing spaces before roman numerals`);
        console.log('  ‚Ä¢ Malformed logs may not clear properly. Enable Debug Mode and click "Clear Logs".');
      }
      if (totalUnknown > 0) {
        console.log(`  ‚Ä¢ ‚ùì Found ${totalUnknown} UNKNOWN ability type(s) - not in known abilities list`);
      }
      console.log('=======================================================');

      logDebug('ABILITY-LOGS', '‚úÖ Diagnostic complete - see console for full report');

      return report;
    }

    // ==================== DATA MIGRATION SYSTEM ====================
    // Migrate existing localStorage data to GM storage for better reliability

    function MGA_migrateFromLocalStorage() {
      try {
        productionLog('üîÑ [MIGRATION] Starting data migration from localStorage to GM storage...');

        // Check if migration has already been completed (handle both boolean and string values)
        const migrationComplete = GM_getValue('MGA_migration_completed', false);
        if (migrationComplete === true || migrationComplete === 'true') {
          productionLog('‚úÖ [MIGRATION] Migration already completed, skipping...');
          return;
        }

        // List of keys to migrate
        const keysToMigrate = [
          'MGA_petPresets',
          'MGA_seedsToDelete',
          'MGA_autoDeleteEnabled',
          'MGA_petAbilityLogs',
          'MGA_settings',
          'MGA_mainHUDPosition',
          'MGA_toggleButtonPosition',
          'MGA_overlayDimensions',
          'MGA_overlayPositions',
          'MGA_overlayStates',
          'MGA_abilityFilters',
          'MGA_petFilters',
          'MGA_customMode',
          'MGA_filterMode',
          'MGA_timerStates'
        ];

        let migratedCount = 0;
        let totalDataSize = 0;

        // Use requestIdleCallback to avoid blocking the main thread during migration
        const migrateKeys = (keyIndex = 0) => {
          if (keyIndex >= keysToMigrate.length) {
            // Migration complete
            GM_setValue('MGA_migration_completed', true);
            GM_setValue('MGA_migration_timestamp', Date.now());
            GM_setValue('MGA_migration_stats', {
              migratedCount,
              totalDataSize,
              timestamp: Date.now()
            });

            productionLog(`‚úÖ [MIGRATION] Data migration completed!`);
            productionLog(`üìä [MIGRATION] Statistics:`, {
              migratedKeys: migratedCount,
              totalDataSize: totalDataSize + ' chars',
              timestamp: new Date().toISOString()
            });
            return;
          }

          const key = keysToMigrate[keyIndex];
          try {
            const localStorageData = localStorage.getItem(key);
            if (localStorageData) {
              // Data exists in localStorage, migrate it
              GM_setValue(key, localStorageData);
              migratedCount++;
              totalDataSize += localStorageData.length;

              productionLog(`üì¶ [MIGRATION] Migrated ${key} (${localStorageData.length} chars)`);

              // Verify the migration worked
              const verification = GM_getValue(key, null);
              if (verification === localStorageData) {
                productionLog(`‚úÖ [MIGRATION] Successfully verified ${key}`);

                // Only remove from localStorage after successful verification
                localStorage.removeItem(key);
                productionLog(`üóëÔ∏è [MIGRATION] Removed ${key} from localStorage`);
              } else {
                console.error(`‚ùå [MIGRATION] Verification failed for ${key} - keeping localStorage version`);
              }
            } else {
              // No data in localStorage for this key
              productionLog(`üìù [MIGRATION] No data found for ${key} in localStorage`);
            }
          } catch (error) {
            console.error(`‚ùå [MIGRATION] Failed to migrate ${key}:`, error);
          }

          // Process next key with a small delay to avoid blocking
          if (typeof requestIdleCallback !== 'undefined') {
            requestIdleCallback(() => migrateKeys(keyIndex + 1));
          } else {
            setTimeout(() => migrateKeys(keyIndex + 1), 0);
          }
        };

        // Start migration
        migrateKeys();

        return { success: true, migratedCount, totalDataSize };
      } catch (error) {
        console.error(`‚ùå [MIGRATION] Migration process failed:`, error);
        return { success: false, error: error.message };
      }
    }

    // Function to check migration status for debugging
    function MGA_getMigrationStatus() {
      const migrationComplete = GM_getValue('MGA_migration_completed', false);
      const migrationStats = GM_getValue('MGA_migration_stats', null);
      const migrationTimestamp = GM_getValue('MGA_migration_timestamp', null);

      return {
        completed: migrationComplete,
        stats: migrationStats,
        timestamp: migrationTimestamp ? new Date(migrationTimestamp).toISOString() : null
      };
    }

    // Export migration functions for debugging
    targetWindow.MGA_migrateFromLocalStorage = MGA_migrateFromLocalStorage;
    targetWindow.MGA_getMigrationStatus = MGA_getMigrationStatus;
    targetWindow.MGA_saveJSON = MGA_saveJSON;
    targetWindow.MGA_loadJSON = MGA_loadJSON;

    // Export startIntervals for debugging and emergency use
    targetWindow.startIntervals = startIntervals;

    // Pet hunger state tracking
    const lastPetHungerStates = {};

    // ==================== COMPREHENSIVE DEBUG COLLECTION ====================
    targetWindow.collectMGADebug = function () {
      productionLog('üîç Starting comprehensive MGA debug collection...');

      const debugData = {
        timestamp: new Date().toISOString(),
        version: typeof GM_info !== 'undefined' ? GM_info?.script?.version || 'Unknown' : 'Unknown',
        userAgent: navigator.userAgent,

        // Script State
        scriptState: {
          mainScriptDetected:
            (typeof MGAIsolationSystem !== 'undefined' ? MGAIsolationSystem?.mainScriptDetected : false) || false,
          protectedGlobals:
            (typeof MGAIsolationSystem !== 'undefined' ? MGAIsolationSystem?.protectedGlobals : []) || [],
          globalFunctions: {
            hasLoadJSON: typeof targetWindow.loadJSON !== 'undefined',
            hasSaveJSON: typeof targetWindow.saveJSON !== 'undefined',
            loadJSONOwner:
              typeof targetWindow.loadJSON !== 'undefined' && targetWindow.loadJSON === MGA_loadJSON ? 'MGA' : 'Other',
            saveJSONOwner:
              typeof targetWindow.saveJSON !== 'undefined' && targetWindow.saveJSON === MGA_saveJSON ? 'MGA' : 'Other'
          }
        },

        // Pet Hunger System
        petHungerSystem: {
          enabled: UnifiedState?.data?.settings?.notifications?.petHungerEnabled || false,
          threshold: UnifiedState?.data?.settings?.notifications?.petHungerThreshold || 25,
          activePets:
            UnifiedState?.atoms?.activePets?.map(pet => ({
              id: pet?.id,
              species: pet?.petSpecies,
              hunger: pet?.hunger,
              health: pet?.health,
              slot: pet?.slot
            })) || [],
          // eslint-disable-next-line no-use-before-define
          lastStates:
            typeof lastPetHungerStates !== 'undefined'
              ? Object.keys(lastPetHungerStates || {}).map(id => ({
                  petId: id,
                  lastHunger: lastPetHungerStates[id]
                }))
              : []
        },

        // Shop System
        shopSystem: {
          firebaseEnabled: UnifiedState?.data?.settings?.notifications?.shopFirebaseEnabled || false,
          watchedSeeds: UnifiedState?.data?.settings?.notifications?.watchedSeeds || [],
          watchedEggs: UnifiedState?.data?.settings?.notifications?.watchedEggs || [],
          shopData: {
            globalShop: typeof targetWindow.globalShop !== 'undefined' ? 'Present' : 'Missing',
            quinoaData: UnifiedState?.atoms?.quinoaData ? 'Present' : 'Missing',
            seedTimer: UnifiedState?.data?.timers?.seed,
            eggTimer: UnifiedState?.data?.timers?.egg,
            toolTimer: UnifiedState?.data?.timers?.tool
          },
          lastCheck: new Date().toISOString()
        },

        // Weather System
        weatherSystem: {
          enabled: UnifiedState?.data?.settings?.notifications?.weatherNotificationsEnabled || false,
          watchedEvents: UnifiedState?.data?.settings?.notifications?.watchedWeatherEvents || [],
          currentWeather: targetWindow.roomState?.child?.data?.weather || targetWindow.roomState?.weather || 'Unknown',
          // eslint-disable-next-line no-use-before-define
          lastWeatherState: typeof lastWeatherState !== 'undefined' ? lastWeatherState : null
        },

        // Performance Metrics
        performance: {
          memoryUsage: performance?.memory
            ? {
                usedJSHeapSize: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + ' MB',
                totalJSHeapSize: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + ' MB',
                jsHeapSizeLimit: (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2) + ' MB'
              }
            : 'Not available',
          intervals: {
            notificationInterval: typeof notificationInterval !== 'undefined' ? 'Active' : 'Inactive',
            firebaseInterval: UnifiedState?.firebase?.reportInterval ? 'Active' : 'Inactive',
            timerManagerActive: typeof timerManager !== 'undefined' ? timerManager?.isRunning || false : false,
            activeTimers: typeof timerManager !== 'undefined' ? timerManager?.activeTimers?.size || 0 : 0
          }
        },

        // Storage Status
        storageStatus: {
          gmApiAvailable: typeof isGMApiAvailable !== 'undefined' ? isGMApiAvailable() : false,
          migrationStatus: typeof MGA_getMigrationStatus !== 'undefined' ? MGA_getMigrationStatus() : 'N/A',
          storedData:
            typeof GM_getValue !== 'undefined'
              ? {
                  petPresets: GM_getValue('MGA_petPresets') ? 'Present' : 'Missing',
                  seedsToDelete: GM_getValue('MGA_seedsToDelete') ? 'Present' : 'Missing',
                  settings: GM_getValue('MGA_data') ? 'Present' : 'Missing'
                }
              : 'GM API not available'
        },

        // External Feed Protection
        autoFeedStatus: {
          autoFeedEnabled: targetWindow.autoFeedEnabled,
          autoFeedState: targetWindow.autoFeedState,
          autoFeedSkipFavorited: targetWindow.autoFeedSkipFavorited,
          protection:
            typeof MGAIsolationSystem !== 'undefined' ? MGAIsolationSystem?.isAutofeedProtected || false : false
        },

        // Errors and Warnings
        recentErrors: []
      };

      productionLog('üìä Collecting performance data for 10 seconds...');
      productionLog('‚è≥ Monitoring for errors and performance issues...');

      // Note: Error capturing disabled due to browser security restrictions
      const errors = [];

      // Create performance monitor
      let frameCount = 0;
      let lastFrameTime = performance.now();
      const fpsData = [];

      function measureFPS() {
        const currentTime = performance.now();
        const delta = currentTime - lastFrameTime;
        if (delta > 0) {
          const fps = 1000 / delta;
          fpsData.push({
            time: new Date().toISOString(),
            fps: Math.round(fps),
            weather: window.roomState?.child?.data?.weather || window.roomState?.weather || 'None'
          });
        }
        lastFrameTime = currentTime;
        frameCount++;

        if (frameCount < 600) {
          // Run for ~10 seconds at 60fps
          requestAnimationFrame(measureFPS);
        } else {
          finishDebugCollection();
        }
      }

      requestAnimationFrame(measureFPS);

      function finishDebugCollection() {
        // Add collected data
        debugData.recentErrors = errors;
        debugData.performance.fpsAnalysis = {
          samples: fpsData.length,
          averageFPS: Math.round(fpsData.reduce((a, b) => a + b.fps, 0) / fpsData.length),
          minFPS: Math.min(...fpsData.map(d => d.fps)),
          maxFPS: Math.max(...fpsData.map(d => d.fps)),
          weatherDuringTest: [...new Set(fpsData.map(d => d.weather))]
        };

        // Create downloadable file
        const debugText = JSON.stringify(debugData, null, 2);
        const blob = new Blob([debugText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `mga-debug-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);

        productionLog('‚úÖ Debug collection complete!');
        productionLog('üìÅ Debug file downloaded');
        productionLog('üìä Debug Summary:', {
          petHungerEnabled: debugData.petHungerSystem.enabled,
          activePets: debugData.petHungerSystem.activePets.length,
          weatherEnabled: debugData.weatherSystem.enabled,
          currentWeather: debugData.weatherSystem.currentWeather,
          averageFPS: debugData.performance.fpsAnalysis?.averageFPS,
          errors: debugData.recentErrors.length
        });

        // Also log to console for immediate viewing
        productionLog('üîç Full Debug Data:', debugData);

        return debugData;
      }

      // Also set a timeout in case FPS monitoring doesn't complete
      setTimeout(() => {
        if (frameCount < 600) {
          productionLog('‚è±Ô∏è Timeout reached, finishing collection early...');
          finishDebugCollection();
        }
      }, 12000);

      return 'Debug collection started... Will complete in 10 seconds.';
    };

    // ==================== MEMORY MANAGEMENT SYSTEM ====================
    // Prevent memory leaks and accumulation that requires tab restarts

    const mgaCleanupHandlers = [];
    let mgaIntervals = [];
    let mgaTimeouts = [];

    // Register cleanup handler
    function MGA_addCleanupHandler(handler) {
      if (typeof handler === 'function') {
        mgaCleanupHandlers.push(handler);
      }
    }

    // Register interval for automatic cleanup
    function MGA_addInterval(interval) {
      mgaIntervals.push(interval);
      return interval;
    }

    // Register timeout for automatic cleanup
    function MGA_addTimeout(timeout) {
      mgaTimeouts.push(timeout);
      return timeout;
    }

    // Clean up all MGA resources
    function MGA_cleanup() {
      productionLog('üßπ [MEMORY] Starting MGA cleanup...');

      try {
        // Clear all intervals
        mgaIntervals.forEach(interval => {
          if (interval) {
            clearInterval(interval);
          }
        });
        productionLog(`üßπ [MEMORY] Cleared ${mgaIntervals.length} intervals`);
        mgaIntervals = [];

        // Clear all timeouts
        mgaTimeouts.forEach(timeout => {
          if (timeout) {
            clearTimeout(timeout);
          }
        });
        productionLog(`üßπ [MEMORY] Cleared ${mgaTimeouts.length} timeouts`);
        mgaTimeouts = [];

        // Run custom cleanup handlers
        mgaCleanupHandlers.forEach((handler, index) => {
          try {
            handler();
            productionLog(`üßπ [MEMORY] Executed cleanup handler ${index + 1}`);
          } catch (error) {
            console.error(`‚ùå [MEMORY] Cleanup handler ${index + 1} failed:`, error);
          }
        });

        // Clear event listeners
        if (window.MGA_Internal && window.MGA_Internal.eventListeners) {
          window.MGA_Internal.eventListeners.forEach(({ element, event, handler }) => {
            try {
              element.removeEventListener(event, handler);
            } catch (error) {
              productionWarn(`‚ö†Ô∏è [MEMORY] Failed to remove event listener:`, error);
            }
          });
          productionLog(`üßπ [MEMORY] Removed ${window.MGA_Internal.eventListeners.length} event listeners`);
          window.MGA_Internal.eventListeners = [];
        }

        // Clear large data structures
        if (window.UnifiedState) {
          // Save critical data before cleanup
          const criticalData = {
            petPresets: window.UnifiedState.data?.petPresets,
            seedsToDelete: window.UnifiedState.data?.seedsToDelete,
            settings: window.UnifiedState.data?.settings
          };

          // Save critical data
          Object.keys(criticalData).forEach(key => {
            if (criticalData[key] !== undefined) {
              MGA_saveJSON(`MGA_${key}`, criticalData[key]);
            }
          });

          // BUGFIX v3.7.7: Don't clear ability logs during cleanup - they're persisted to storage
          // The logs are automatically saved via debounced save system when new logs are added
          // Clearing them here causes loss of logs on page refresh
          // (Removed: window.UnifiedState.data.petAbilityLogs = [])
        }

        productionLog('‚úÖ [MEMORY] MGA cleanup completed successfully');
      } catch (error) {
        console.error('‚ùå [MEMORY] MGA cleanup failed:', error);
      }
    }

    // Set up automatic cleanup on page unload
    window.addEventListener('beforeunload', () => {
      productionLog('üîÑ [MEMORY] Page unloading, starting cleanup...');
      MGA_cleanup();
    });

    // Set up cleanup on page hide (for mobile/tab switching)
    window.addEventListener('pagehide', () => {
      productionLog('üîÑ [MEMORY] Page hiding, starting cleanup...');
      MGA_cleanup();
    });

    // Export memory management functions
    window.MGA_cleanup = MGA_cleanup;
    window.MGA_addCleanupHandler = MGA_addCleanupHandler;
    window.MGA_addInterval = MGA_addInterval;
    window.MGA_addTimeout = MGA_addTimeout;

    // ==================== MEMORY OPTIMIZATION SYSTEM ====================
    // Smart memory management to reduce footprint while preserving user data

    // Configuration for memory limits
    const MGA_MemoryConfig = {
      maxLogsInMemory: 1000, // Keep latest 1000 logs in memory
      maxLogsInStorage: 10000, // Archive up to 10000 logs in storage
      saveDebounceMs: 2000, // Debounce saves by 2 seconds
      domPoolSize: 50 // Pool size for DOM elements
    };

    // Debounced save system to reduce I/O operations
    const saveTimeouts = new Map();
    function MGA_debouncedSave(key, data) {
      // Clear existing timeout for this key
      if (saveTimeouts.has(key)) {
        clearTimeout(saveTimeouts.get(key));
      }

      // Set new debounced timeout
      const timeout = setTimeout(() => {
        try {
          MGA_saveJSON(key, data);
          productionLog(`üíæ [MEMORY] Debounced save completed for ${key}`);
        } catch (error) {
          console.error(`‚ùå [MEMORY] Debounced save failed for ${key}:`, error);
        }
        saveTimeouts.delete(key);
      }, MGA_MemoryConfig.saveDebounceMs);

      saveTimeouts.set(key, timeout);
    }

    // Smart log management system
    function MGA_manageLogMemory(logs) {
      if (!Array.isArray(logs) || logs.length <= MGA_MemoryConfig.maxLogsInMemory) {
        return logs; // No management needed
      }

      productionLog(
        `üß† [MEMORY] Managing log memory: ${logs.length} logs, keeping ${MGA_MemoryConfig.maxLogsInMemory} in memory`
      );

      // Keep the most recent logs in memory
      const recentLogs = logs.slice(0, MGA_MemoryConfig.maxLogsInMemory);

      // Archive older logs to separate storage
      const archivedLogs = logs.slice(MGA_MemoryConfig.maxLogsInMemory);
      if (archivedLogs.length > 0) {
        // Save archived logs to separate storage key
        const existingArchive = MGA_loadJSON('MGA_petAbilityLogs_archive', []);
        const combinedArchive = [...archivedLogs, ...existingArchive].slice(0, MGA_MemoryConfig.maxLogsInStorage);
        MGA_debouncedSave('MGA_petAbilityLogs_archive', combinedArchive);
        productionLog(`üì¶ [MEMORY] Archived ${archivedLogs.length} logs to storage`);
      }

      return typeof wrapLogsArray === 'function' ? wrapLogsArray(recentLogs) : recentLogs;
    }

    // DOM element pooling for performance
    const MGA_DOMPool = {
      pools: new Map(),

      getElement: function (tagName, className = '') {
        const key = `${tagName}:${className}`;
        if (!this.pools.has(key)) {
          this.pools.set(key, []);
        }

        const pool = this.pools.get(key);
        if (pool.length > 0) {
          const element = pool.pop();
          // Reset element state
          element.innerHTML = '';
          element.removeAttribute('style');
          element.className = className;
          return element;
        }

        // Create new element if pool is empty (using target context)
        const element = targetDocument.createElement(tagName);
        if (className) element.className = className;
        return element;
      },

      returnElement: function (element) {
        if (!element || !element.tagName) return;

        const key = `${element.tagName.toLowerCase()}:${element.className || ''}`;
        if (!this.pools.has(key)) {
          this.pools.set(key, []);
        }

        const pool = this.pools.get(key);
        if (pool.length < MGA_MemoryConfig.domPoolSize) {
          // Clean element before returning to pool
          element.innerHTML = '';
          element.removeAttribute('style');
          element.onclick = null;
          element.onmouseover = null;
          element.onmouseout = null;
          pool.push(element);
        }
      },

      cleanup: function () {
        productionLog('üßπ [MEMORY] Cleaning DOM element pools');
        this.pools.clear();
      }
    };

    // Add DOM pool cleanup to main cleanup handler
    MGA_addCleanupHandler(() => {
      MGA_DOMPool.cleanup();
      // Clear save timeouts
      saveTimeouts.forEach(timeout => clearTimeout(timeout));
      saveTimeouts.clear();
    });

    // Function to retrieve all logs (memory + archived) when needed
    function MGA_getAllLogs() {
      const memoryLogs = UnifiedState.data?.petAbilityLogs || [];
      const archivedLogs = MGA_loadJSON('MGA_petAbilityLogs_archive', []);

      // Combine and sort by timestamp (newest first)
      const allLogs = [...memoryLogs, ...archivedLogs];
      allLogs.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

      productionLog(
        `üìú [MEMORY] Retrieved ${memoryLogs.length} memory logs + ${archivedLogs.length} archived logs = ${allLogs.length} total`
      );
      return allLogs;
    }

    // Export memory optimization functions
    window.MGA_debouncedSave = MGA_debouncedSave;
    window.MGA_manageLogMemory = MGA_manageLogMemory;
    window.MGA_getAllLogs = MGA_getAllLogs;
    window.MGA_DOMPool = MGA_DOMPool;

    // ==================== DOM QUERY CACHE SYSTEM ====================
    // Performance optimization: Cache frequently accessed DOM queries
    const elementCache = new WeakMap();
    const CACHE_DURATION = 1000; // 1 second cache

    function getCachedElement(selector, context = document) {
      const now = Date.now();
      const key = `${selector}_${context.id || 'document'}`;

      let cached = elementCache.get(context);
      if (cached && cached[key] && now - cached[key].time < CACHE_DURATION) {
        return cached[key].element;
      }

      const element = context.querySelector(selector);
      if (!cached) cached = {};
      cached[key] = { element, time: now };
      elementCache.set(context, cached);

      return element;
    }

    function getCachedElements(selector, context = document) {
      const now = Date.now();
      const key = `${selector}_all_${context.id || 'document'}`;

      let cached = elementCache.get(context);
      if (cached && cached[key] && now - cached[key].time < CACHE_DURATION) {
        return cached[key].elements;
      }

      const elements = context.querySelectorAll(selector);
      if (!cached) cached = {};
      cached[key] = { elements, time: now };
      elementCache.set(context, cached);

      return elements;
    }

    // Invalidate cache for a specific context (useful after DOM changes)
    function invalidateCache(context = document) {
      elementCache.delete(context);
    }

    window.MGA_DOMCache = { getCachedElement, getCachedElements, invalidateCache };

    // ==================== NAMESPACE ISOLATION ====================
    // Keep MGA functions completely isolated to prevent conflicts with external scripts

    // Export MGA functions to global scope for direct access (MGA_ prefix prevents conflicts)
    window.MGA_loadJSON = MGA_loadJSON;
    window.MGA_saveJSON = MGA_saveJSON;

    // External Script Conflict Detection and Protection
    window.MGA_ConflictDetection = {
      mainScriptDetected: false,
      protectedGlobals: ['autoFeedEnabled', 'autoFeedState', 'autoFeedSkipFavorited', 'petAbilityLogs'],

      // Ensure MGA never accesses external script globals
      preventAccess: function () {
        if (!this.mainScriptDetected) return;

        // Create safe accessors that prevent MGA from accidentally touching external script variables
        this.protectedGlobals.forEach(globalVar => {
          if (window[globalVar] !== undefined) {
            productionLog(`üîí [MGA-ISOLATION] Ensuring MGA cannot access external script global: ${globalVar}`);

            // Define a read-only accessor for debugging
            Object.defineProperty(window, `MGA_SAFE_${globalVar}`, {
              get: function () {
                productionWarn(`‚ö†Ô∏è [MGA-ISOLATION] MGA attempted to access external script global: ${globalVar}`);
                productionWarn(`‚ö†Ô∏è [MGA-ISOLATION] This access was blocked to prevent interference`);
                console.trace();
                return undefined; // Always return undefined to MGA
              },
              configurable: false,
              enumerable: false
            });
          }
        });

        // Specifically protect external feed variables
        productionLog(`üîí [MGA-ISOLATION] External script feed protection active`);
        productionLog(`üîí [MGA-ISOLATION] MGA will not interfere with external feed functionality`);
      },

      detectMainScript: function () {
        const hasMainScriptFunctions = typeof window.loadJSON === 'function' || typeof window.saveJSON === 'function';
        const hasMainScriptVars =
          typeof window.petAbilityLogs !== 'undefined' || typeof window.autoFeedEnabled !== 'undefined';
        const hasVisibilityOverride =
          document.hidden === false && typeof Object.getOwnPropertyDescriptor === 'function';

        this.mainScriptDetected = hasMainScriptFunctions || hasMainScriptVars || hasVisibilityOverride;

        if (this.mainScriptDetected) {
          // productionLog('üîç [MGA-ISOLATION] External scripts detected - enabling full isolation mode');
          productionLog('üîí [MGA-ISOLATION] MGA will NOT modify global functions or external script variables');
          productionLog('üìù [MGA-ISOLATION] Protected variables:', this.protectedGlobals);
        } else {
          productionLog('üìù [MGA-ISOLATION] No external scripts detected - running in standalone mode');
        }

        return this.mainScriptDetected;
      },

      checkGlobalIntegrity: function () {
        if (!this.mainScriptDetected) return true;

        const violations = [];

        // Check if we accidentally modified protected globals
        this.protectedGlobals.forEach(globalVar => {
          if (window[globalVar] !== undefined) {
            // External script global exists - make sure we don't interfere
            // productionLog(`üîç [MGA-ISOLATION] External script global '${globalVar}' is active - ensuring no interference`);
          }
        });

        // Check if global loadJSON/saveJSON are external script's versions
        if (window.loadJSON && window.loadJSON !== MGA_loadJSON) {
          productionLog(
            'üîí [MGA-ISOLATION] Global loadJSON belongs to external script - MGA using isolated MGA_loadJSON'
          );
        }
        if (window.saveJSON && window.saveJSON !== MGA_saveJSON) {
          productionLog(
            'üîí [MGA-ISOLATION] Global saveJSON belongs to external script - MGA using isolated MGA_saveJSON'
          );
        }

        return violations.length === 0;
      },

      createIsolationBarrier: function () {
        if (!this.mainScriptDetected) return;

        // Light protection - just store original values for monitoring
        this.protectedGlobals.forEach(globalVar => {
          if (window[globalVar] !== undefined) {
            const originalValue = window[globalVar];

            // Store original value for later comparison
            try {
              Object.defineProperty(window, `_MGA_ORIGINAL_${globalVar}`, {
                value: originalValue,
                writable: true,
                configurable: true
              });
              productionLog(`üõ°Ô∏è [MGA-ISOLATION] Stored original value for external script global: ${globalVar}`);
            } catch (protectionError) {
              productionWarn(
                `‚ö†Ô∏è [MGA-ISOLATION] Could not store original value for ${globalVar}:`,
                protectionError.message
              );
            }
          }
        });

        // Simple function protection - just save references without modifying
        if (window.loadJSON && window.loadJSON !== window.MGA_loadJSON) {
          productionLog(`üîí [MGA-ISOLATION] External script loadJSON detected - storing reference`);
          window._MGA_MAINSCRIPT_loadJSON = window.loadJSON;
        }
        if (window.saveJSON && window.saveJSON !== window.MGA_saveJSON) {
          productionLog(`üîí [MGA-ISOLATION] External script saveJSON detected - storing reference`);
          window._MGA_MAINSCRIPT_saveJSON = window.saveJSON;
        }
      },

      // New method to verify isolation integrity
      validateIsolation: function () {
        const violations = [];

        // Check that MGA never modified protected globals
        this.protectedGlobals.forEach(globalVar => {
          const original = window[`_MGA_ORIGINAL_${globalVar}`];
          const current = window[globalVar];

          if (original !== undefined && current !== original) {
            violations.push({
              global: globalVar,
              expected: original,
              actual: current,
              type: 'global_modification'
            });
          }
        });

        // Check that MGA uses its own storage functions
        if (window.MGA_loadJSON && window.loadJSON && window.MGA_loadJSON === window.loadJSON) {
          violations.push({
            issue: 'MGA_loadJSON is assigned to global loadJSON',
            type: 'function_collision'
          });
        }
        if (window.MGA_saveJSON && window.saveJSON && window.MGA_saveJSON === window.saveJSON) {
          violations.push({
            issue: 'MGA_saveJSON is assigned to global saveJSON',
            type: 'function_collision'
          });
        }

        if (violations.length > 0) {
          console.error(`‚ùå [MGA-ISOLATION] Isolation violations detected:`, violations);
          return false;
        }

        productionLog(`‚úÖ [MGA-ISOLATION] Isolation validation passed - no violations detected`);
        return true;
      }
    };

    // NEVER set global window.loadJSON or window.saveJSON - this prevents conflicts
    // MGA ALWAYS uses MGA_loadJSON and MGA_saveJSON exclusively

    // ==================== SAVE OPERATION WRAPPER ====================
    // Wrapper function to handle new MGA_saveJSON return format and provide user feedback

    window.MGA_safeSave = function (key, value, options = {}) {
      let keyLocal = key;
      const { showUserAlert = true, criticalData = false, description = keyLocal, silent = false } = options;

      // CRITICAL: Ensure we never use external script keys
      if (keyLocal && !keyLocal.startsWith('MGA_')) {
        console.error(`‚ùå [MGA-ISOLATION] CRITICAL: Attempted to save with non-MGA key: ${keyLocal}`);
        console.error(`‚ùå [MGA-ISOLATION] This would conflict with external scripts! Adding MGA_ prefix.`);
        console.trace();
        keyLocal = 'MGA_' + keyLocal;
      }

      try {
        // Simple synchronous save
        const success = MGA_saveJSON(keyLocal, value);

        if (success) {
          if (!silent) {
            productionLog(`‚úÖ [MGA-SAFE-SAVE] Successfully saved ${description}`);
          }
          return { success: true };
        } else {
          // Save failed
          const errorMsg = `Failed to save ${description}`;
          console.error(`‚ùå [MGA-SAFE-SAVE] ${errorMsg}`);

          // REMOVED: Alert on save failure - causes modal spam
          // Save failures are logged to console instead

          return { success: false, error: 'save_failed' };
        }
      } catch (error) {
        console.error(`‚ùå [MGA-SAFE-SAVE] Exception during save of ${description}:`, error);
        return { success: false, error: error.message, exception: true };
      }
    };

    // Helper function for backward compatibility with legacy save calls
    window.MGA_legacySave = function (key, value, description) {
      const result = MGA_safeSave(key, value, {
        description: description || key,
        showUserAlert: true,
        criticalData: key.includes('petPresets') || key.includes('seedsToDelete')
      });
      return result.success;
    };

    // Validation helper for critical data types
    window.MGA_validateSaveData = function (key, value) {
      if (key === 'MGA_petPresets') {
        if (!value || typeof value !== 'object') {
          return { valid: false, error: 'Pet presets must be an object' };
        }
        for (const [presetName, preset] of Object.entries(value)) {
          if (!Array.isArray(preset)) {
            return { valid: false, error: `Preset '${presetName}' must be an array` };
          }
          if (!preset.every(pet => pet && pet.id && pet.petSpecies)) {
            return { valid: false, error: `Preset '${presetName}' contains invalid pet data` };
          }
        }
        return { valid: true };
      }

      if (key === 'MGA_seedsToDelete') {
        if (!Array.isArray(value)) {
          return { valid: false, error: 'Seeds to delete must be an array' };
        }
        if (!value.every(seed => typeof seed === 'string' && seed.trim())) {
          return { valid: false, error: 'All seeds must be non-empty strings' };
        }
        return { valid: true };
      }

      return { valid: true }; // Default: assume valid for other data types
    };

    // Diagnostic function for localStorage issues
    window.MGA_debugStorage = function () {
      productionLog('üîç [MGA-STORAGE] localStorage Diagnostic Report');
      productionLog('=====================================');

      try {
        // Check basic availability
        productionLog('üìä Basic Info:');
        productionLog('  localStorage available:', typeof localStorage !== 'undefined');
        productionLog('  Total items in localStorage:', localStorage.length);

        // Check MGA-specific keys
        const mgaKeys = Object.keys(localStorage).filter(k => k.startsWith('MGA_'));
        productionLog('  MGA-specific keys found:', mgaKeys.length);
        productionLog('  MGA keys:', mgaKeys);

        // Check each MGA key
        productionLog('\nüìù MGA Data Status:');
        mgaKeys.forEach(key => {
          try {
            const value = localStorage.getItem(key);
            const parsed = JSON.parse(value);
            productionLog(`  ${key}:`, {
              exists: true,
              size: value.length + ' chars',
              type: typeof parsed,
              itemCount: Array.isArray(parsed) ? parsed.length : Object.keys(parsed || {}).length
            });
          } catch (e) {
            productionLog(`  ${key}: ‚ùå Invalid JSON - ${e.message}`);
          }
        });

        // Check conflicts
        productionLog('\n‚ö†Ô∏è Potential Conflicts:');
        productionLog('  window.loadJSON defined by:', window.loadJSON === MGA_loadJSON ? 'MGA' : 'Other script');
        productionLog('  window.saveJSON defined by:', window.saveJSON === MGA_saveJSON ? 'MGA' : 'Other script');

        // Storage space test
        productionLog('\nüíæ Storage Test:');
        const testKey = 'MGA_storageTest';
        const testData = { test: true, timestamp: Date.now() };
        try {
          MGA_saveJSON(testKey, testData);
          const retrieved = MGA_loadJSON(testKey, null);
          productionLog('  Storage test result:', retrieved && retrieved.test === true ? '‚úÖ PASSED' : '‚ùå FAILED');
          localStorage.removeItem(testKey);
        } catch (e) {
          productionLog('  Storage test result: ‚ùå FAILED -', e.message);
        }
      } catch (error) {
        console.error('‚ùå [MGA-STORAGE] Diagnostic failed:', error);
      }
    };

    function safeSendMessage(message) {
      try {
        // Check for connection availability
        if (!targetWindow.MagicCircle_RoomConnection) {
          productionWarn('‚ö†Ô∏è MagicCircle_RoomConnection not available');
          return false;
        }

        // Validate that sendMessage exists and is a function
        if (typeof targetWindow.MagicCircle_RoomConnection.sendMessage !== 'function') {
          productionWarn('‚ö†Ô∏è sendMessage is not a function or not available');
          return false;
        }

        // Send the message
        targetWindow.MagicCircle_RoomConnection.sendMessage(message);
        return true;
      } catch (error) {
        console.error('‚ùå Error sending message:', error);
        return false;
      }
    }

    // ==================== PROPER GAME MESSAGE SENDER ====================
    function sendToGame(payloadObj) {
      const msg = { scopePath: ['Room', 'Quinoa'], ...payloadObj };
      try {
        if (!targetWindow.MagicCircle_RoomConnection || !targetWindow.MagicCircle_RoomConnection.sendMessage) {
          productionWarn('‚ö†Ô∏è MagicCircle_RoomConnection not available for sendToGame');
          return false;
        }

        productionLog('üéÆ sendToGame:', msg);
        targetWindow.MagicCircle_RoomConnection.sendMessage(msg);
        return true;
      } catch (error) {
        console.error('‚ùå sendToGame error:', error);
        return false;
      }
    }

    // --- Unified atom access helper (recommended) ---
    function readAtom(atomName) {
      const gw = (typeof unsafeWindow !== 'undefined' && unsafeWindow) || window;
      try {
        if (gw.MGTools?.store?.getAtomValue) return gw.MGTools.store.getAtomValue(atomName);
      } catch {}
      return null;
    }

    // --- Tiered readers for atoms with UnifiedState fallback ---
    const readMyPetSlots = () => {
      try {
        return getAtomValue('myPrimitivePetSlotsAtom');
      } catch {
        /* atom unavailable */
      }
      return UnifiedState?.atoms?.activePets ?? null;
    };

    const readMyInventory = () => {
      try {
        return getAtomValue('myCropInventoryAtom');
      } catch {
        /* atom unavailable */
      }
      return UnifiedState?.atoms?.inventory ?? null;
    };

    // --- RoomConnection wiring ---
    const RC =
      targetWindow.MagicCircle_RoomConnection ||
      window.RoomConnection?.instance ||
      targetWindow?.MagicCircle_RoomConnection ||
      null;

    // Install bulletproof WebSocket tap (doesn't rely on RC._socket)
    (function installWsTap() {
      const WS = targetWindow.WebSocket || window.WebSocket;
      if (!WS || WS.prototype.__mgaTapInstalled) return;
      const origAdd = WS.prototype.addEventListener;
      const subs = new Set();

      function fanout(evt) {
        try {
          let d = evt.data;
          try {
            d = JSON.parse(d);
          } catch {}
          const arr = Array.isArray(d) ? d : [d];
          for (const msg of arr)
            for (const fn of subs) {
              try {
                fn(msg);
              } catch {}
            }
        } catch {}
      }

      WS.prototype.addEventListener = function (type, listener, opts) {
        if (type === 'message') {
          const wrapped = evt => {
            fanout(evt);
            return listener.call(this, evt);
          };
          return origAdd.call(this, type, wrapped, opts);
        }
        return origAdd.call(this, type, listener, opts);
      };

      // Also hook onmessage setter so we still see messages when code uses ws.onmessage =
      Object.defineProperty(WS.prototype, 'onmessage', {
        set(fn) {
          this.__mgaOnMsg = fn;
          this.addEventListener('message', evt => fn.call(this, evt));
        },
        get() {
          return this.__mgaOnMsg || null;
        }
      });

      targetWindow.__mgaSubscribeServer = fn => {
        subs.add(fn);
        return () => subs.delete(fn);
      };
      window.__mgaSubscribeServer = fn => {
        subs.add(fn);
        return () => subs.delete(fn);
      };
      WS.prototype.__mgaTapInstalled = true;
    })();

    // Detect native feed button clicks to debug message format
    (function detectNativeFeed() {
      const targetWin = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;

      // Hook into React event system to catch native feed clicks
      document.addEventListener(
        'click',
        function (e) {
          // Check if clicked element looks like a feed button
          const elem = e.target;
          if (elem && (elem.textContent?.includes('Feed') || elem.className?.includes('feed'))) {
            console.log('[NATIVE-FEED] Possible native feed button clicked:', elem);

            // Set flag to capture next FeedPet message
            targetWin.__captureNextFeedPet = true;
            setTimeout(() => {
              targetWin.__captureNextFeedPet = false;
            }, 2000);
          }
        },
        true
      );
    })();

    // Wait for one matching server message using the bulletproof tap
    async function waitForServer(predicate, timeoutMs = 3500) {
      return new Promise((resolve, reject) => {
        const unsub = (window.__mgaSubscribeServer || targetWindow.__mgaSubscribeServer)(msg => {
          try {
            if (predicate(msg)) {
              unsub();
              resolve(msg);
            }
          } catch {}
        });
        const to = setTimeout(() => {
          unsub();
          reject(new Error('timeout'));
        }, timeoutMs);
      });
    }

    // Add debug helper to peek at incoming messages
    async function peekNextMessages(count = 10, windowMs = 1500) {
      const seen = [];
      const unsub = (window.__mgaSubscribeServer || targetWindow.__mgaSubscribeServer)(m => {
        if (seen.length < count) seen.push(m?.type || typeof m);
      });
      await new Promise(res => setTimeout(res, windowMs));
      unsub();
      console.log('[WS-TAP] next msgs after send:', seen);
    }

    // Resolve a concrete inventory item id for the given species name
    function resolveInventoryItemIdForSpecies(species, inventoryObj) {
      const items = Array.isArray(inventoryObj?.items) ? inventoryObj.items : [];

      const it = items.find(i => {
        const sp = i?.species || i?.item?.species;
        const fav = !!(i?.favorite || i?.isFavorited);
        const count = i?.count ?? i?.quantity ?? 1;
        return sp === species && !fav && count > 0;
      });

      // CRITICAL FIX: Game uses 'id' field, not 'inventoryItemId' or 'itemId'
      // Check actual field structure and prioritize correctly
      const resolvedId = it?.id || it?.inventoryItemId || it?.itemId || null;
      if (it && !resolvedId) {
        console.error('[Feed] Item has no valid ID field:', it);
      }
      return resolvedId;
    }

    // Build-and-send FeedPet (simplified - uses new rcSend)
    async function sendFeedPet(petItemId, cropItemId) {
      const payload = {
        type: 'FeedPet',
        petItemId: petItemId,
        cropItemId: cropItemId
      };
      console.log('[MGA] Feed payload:', payload);
      return rcSend(payload);
    }

    // Send with server ack verification
    async function sendWithAck(type, payload, makePredicate, debugPeek = false) {
      console.log('[Feed-Debug] üöÄ Sending', { type, ...payload });
      await sendFeedPet(payload.petItemId, payload.cropItemId);

      // Debug: peek at next messages to confirm tap is working (remove after verification)
      if (debugPeek) {
        peekNextMessages(10, 1500);
      }

      const ack = await waitForServer(makePredicate({ type, payload })).catch(() => null);
      return !!ack;
    }

    // Feed pet with server event verification (no atom polling)
    async function feedPetEnsureSync(petItemId, cropItemId, petIndex, enableDebugPeek = false) {
      // Predicate matching server events that confirm feed success
      const makePredicate =
        ({ payload }) =>
        msg => {
          if (!msg || typeof msg !== 'object') return false;

          // Option A: Explicit ack with matching petItemId
          if (msg.type === 'FeedPetAck' && msg.ok && msg.petItemId === payload.petItemId) {
            return true;
          }

          // Option B: Domain event (PetFed)
          if (msg.type === 'PetFed' && msg.petItemId === payload.petItemId) {
            return true;
          }

          // Option C: InventoryDelta removing the crop
          if (msg.type === 'InventoryDelta' && msg.removed) {
            if (Array.isArray(msg.removed)) {
              return msg.removed.some(r => r.id === payload.cropItemId || r === payload.cropItemId);
            }
          }

          // Fallback: Check if message JSON contains our IDs (less precise)
          const msgStr = JSON.stringify(msg);
          if (msgStr.includes(payload.petItemId) && msgStr.includes(payload.cropItemId)) {
            console.log('[Feed-Verify] üîç Fallback match on IDs in:', msg.type || 'unknown');
            return true;
          }

          return false;
        };

      const ok = await sendWithAck('FeedPet', { petItemId, cropItemId }, makePredicate, enableDebugPeek);

      if (ok) {
        console.log('[Feed-Verify] ‚úÖ verified by server event');
        return { verified: true };
      }

      console.warn('[Feed-Verify] ‚ùå no ack/delta in 3.5s');
      return { verified: false };
    }

    // One-off test snippet (keep behind a debug toggle or run in console)
    async function __mga_testSingleFeed() {
      const pets = readAtom('myPetInfosAtom') || [];
      const pet = pets?.[0];
      const items = readAtom('myCropItemsAtom') || readAtom('myCropInventoryAtom') || [];
      const produce = items.find(x => x?.itemType === 'Produce');

      if (!pet?.petItemId) throw new Error('No pet found');
      if (!produce?.id) throw new Error('No produce item found');

      await sendFeedPet(pet.petItemId, produce.id);
      console.log('[MGA] Test feed sent.');
    }

    // Expose test function to global scope for console access
    if (typeof unsafeWindow !== 'undefined' && unsafeWindow) {
      unsafeWindow.__mga_testSingleFeed = __mga_testSingleFeed;
    }
    window.__mga_testSingleFeed = __mga_testSingleFeed;

    // Function to get FRESH data from a hooked atom (bypasses cached data)
    function getAtomValueFresh(windowKey) {
      const ref = atomReferences.get(windowKey);
      if (!ref) {
        console.warn(`[MGTools] No atom reference stored for '${windowKey}'`);
        return null;
      }

      try {
        // Force a fresh read from the atom cache
        const currentState = ref.atomCache.get(ref.atomPath);
        if (!currentState || !currentState.v) {
          console.warn(`[MGTools] Atom '${windowKey}' has no current state`);
          return null;
        }

        // Return the current value directly from the atom cache
        console.log(`[MGTools] üîÑ Got fresh data for '${windowKey}' from atom cache`);
        return currentState.v;
      } catch (error) {
        console.error(`[MGTools] Error getting fresh atom value for '${windowKey}':`, error);
        return null;
      }
    }

    function hookAtom(atomPath, windowKey, callback, retryCount = 0) {
      const maxRetries = 60; // Max 30 seconds (was 20/10s)
      const hookKey = `${atomPath}_${windowKey}`;

      // Prevent duplicate hooks - only check if retryCount is 0 (first attempt)
      if (retryCount === 0 && hookedAtoms.has(hookKey)) {
        productionLog(`[HOOK] Already hooked: ${windowKey} - skipping duplicate`);
        return;
      }

      // DIAGNOSTIC: Check multiple possible locations for jotaiAtomCache
      if (retryCount === 0) {
        console.log(
          '  - targetWindow.jotaiAtomCache:',
          typeof targetWindow.jotaiAtomCache,
          targetWindow.jotaiAtomCache
        );
        console.log('  - isUserscript:', isUserscript, '(using unsafeWindow:', isUserscript ? 'YES' : 'NO)');
        const jotaiKeys = Object.keys(targetWindow).filter(k => k.toLowerCase().includes('jotai'));
        console.log('  - Keys with "jotai" on targetWindow:', jotaiKeys);
      }

      // Try multiple contexts for jotaiAtomCache (cascading fallback)
      let atomCache = null;

      // Priority 1: Check targetWindow (should be window in page context)
      if (targetWindow.jotaiAtomCache) {
        atomCache = targetWindow.jotaiAtomCache.cache || targetWindow.jotaiAtomCache;
      }
      // Priority 2: Check window directly
      if (!atomCache && window.jotaiAtomCache) {
        atomCache = window.jotaiAtomCache.cache || window.jotaiAtomCache;
      }
      // Priority 3: Check window.top (in case we're in iframe)
      if (!atomCache && window.top && window.top.jotaiAtomCache) {
        atomCache = window.top.jotaiAtomCache.cache || window.top.jotaiAtomCache;
      }
      if (!atomCache || !atomCache.get) {
        if (retryCount >= maxRetries) {
          console.error(
            `‚ùå [ATOM-HOOK] Gave up waiting for atom store for ${windowKey} after ${maxRetries} retries (${maxRetries / 2}s)`
          );
          console.error(`‚ùå [ATOM-HOOK] Final check - targetWindow.jotaiAtomCache:`, targetWindow.jotaiAtomCache);
          console.error(`‚ùå [ATOM-HOOK] Using unsafeWindow:`, isUserscript);
          console.error(`‚ùå [ATOM-HOOK] Script will continue with reduced functionality`);
          productionWarn(`‚ö†Ô∏è [ATOM-HOOK] Gave up waiting for atom store for ${windowKey} after ${maxRetries} retries`);
          productionWarn(`‚ö†Ô∏è [ATOM-HOOK] Script will continue with reduced functionality`);
          return;
        }
        // Exponential backoff: 50ms ‚Üí 100ms ‚Üí 200ms ‚Üí 500ms (cap at 500ms)
        const delay = Math.min(50 * Math.pow(2, Math.min(retryCount, 3)), 500);

        // Log every 5th retry to avoid console spam
        if (retryCount % 5 === 0) {
        }

        setTimeout(() => hookAtom(atomPath, windowKey, callback, retryCount + 1), delay);
        return;
      }

      // Success - atomCache found!
      if (retryCount > 0) {
      }

      productionLog(`üîó Attempting to hook atom: ${windowKey} at path: ${atomPath}`);

      try {
        const atom = atomCache.get(atomPath);
        if (!atom || !atom.read) {
          productionWarn(`‚ùå Could not find atom for ${atomPath}`);
          // List available atoms for debugging
          const allAtoms = Array.from(atomCache.keys());
          const petAtoms = allAtoms.filter(key => key.includes('Pet') || key.includes('pet') || key.includes('Slot'));
          productionLog('üîç Pet-related atoms:', petAtoms);
          productionLog('üîç All atoms (first 20):', allAtoms.slice(0, 20));
          return;
        }

        const originalRead = atom.read;
        atom.read = function (get) {
          const rawValue = originalRead.call(this, get);

          // Enhanced debugging for activePets
          if (windowKey === 'activePets' && UnifiedState.data.settings?.debugMode) {
            productionLog(`üêæ [ATOM-DEBUG] ${windowKey} raw value:`, {
              value: rawValue,
              type: typeof rawValue,
              isArray: Array.isArray(rawValue),
              length: rawValue?.length,
              firstItem: rawValue?.[0]
            });
          }

          // Allow callback to transform the value before storing
          let finalValue = rawValue;
          if (callback) {
            const callbackResult = callback(rawValue);
            // If callback returns a value, use it; otherwise use raw value
            if (callbackResult !== undefined) {
              finalValue = callbackResult;
              if (windowKey === 'activePets' && UnifiedState.data.settings?.debugMode) {
                productionLog(`üêæ [ATOM-DEBUG] ${windowKey} transformed by callback:`, finalValue);
              }
            }
          }

          // Store the final (possibly transformed) value
          UnifiedState.atoms[windowKey] = finalValue;
          window[windowKey] = finalValue;

          if (windowKey === 'activePets' && UnifiedState.data.settings?.debugMode) {
            productionLog(`üêæ [ATOM-DEBUG] ${windowKey} stored in UnifiedState:`, {
              count: finalValue?.length || 0,
              value: finalValue
            });
          }

          return rawValue; // Return raw value to game
        };

        productionLog(`‚úÖ hookAtom: Successfully hooked ${windowKey}`);

        // Mark this hook as successful to prevent duplicates
        hookedAtoms.add(hookKey);

        // Store atom reference for later re-querying (CRITICAL for fresh data)
        atomReferences.set(windowKey, {
          atom: atom,
          atomCache: atomCache,
          atomPath: atomPath
        });
        productionLog(`üì¶ Stored atom reference for ${windowKey} (can now re-query for fresh data)`);

        // Don't force an initial read - it might trigger game modals
        // Instead, wait for the game to naturally read the atom
        // Or use the periodic check in updateActivePetsFromRoomState
      } catch (error) {
        console.error(`‚ùå Error hooking ${atomPath}:`, error);
      }
    }

    // ==================== SLOT INDEX TRACKING - ADVANCED ====================
    // Hook directly into the atom cache to track slot changes
    function listenToSlotIndexAtom() {
      productionLog('üîç [SLOT-ATOM] Starting slot index atom listener...');

      // Initialize the slot index
      if (typeof window._mgtools_currentSlotIndex === 'undefined') {
        window._mgtools_currentSlotIndex = 0;
        console.log('üéØ [SLOT-ATOM] Initialized slot index to 0');
      }

      // Method 1: Try to hook via jotaiAtomCache
      const tryHookingViaCache = () => {
        const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
        if (!atomCache || !atomCache.get) {
          productionLog('‚è≥ [SLOT-ATOM] Waiting for jotaiAtomCache...');
          return false;
        }

        // Look for the slot index atom path
        const possiblePaths = [
          '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotIndexAtom',
          'myCurrentGrowSlotIndexAtom',
          'myCurrentGrowSlotIndex'
        ];

        for (const path of possiblePaths) {
          const atom = atomCache.get(path);
          if (atom && atom.read) {
            productionLog(`‚úÖ [SLOT-ATOM] Found slot atom at: ${path}`);

            // Hook the read function
            const originalRead = atom.read;
            atom.read = function (get) {
              const value = originalRead.call(this, get);
              const idx = Number.isFinite(value) ? value : 0;

              // Only update if changed
              if (window._mgtools_currentSlotIndex !== idx) {
                window._mgtools_currentSlotIndex = idx;
                console.log(`üéØ [SLOT-ATOM-CACHE] Slot index changed to: ${idx}`);

                // Update display
                if (typeof insertTurtleEstimate === 'function') {
                  requestAnimationFrame(() => insertTurtleEstimate());
                }
              }

              return value;
            };

            return true;
          }
        }

        // List all atoms to find the right one
        const allAtoms = Array.from(atomCache.keys());
        const slotAtoms = allAtoms.filter(
          key => key.includes('Slot') || key.includes('slot') || key.includes('Index') || key.includes('index')
        );

        productionLog('üîç [SLOT-ATOM] Slot-related atoms found:', slotAtoms);

        // Try to find it in the list
        const slotIndexAtom = slotAtoms.find(
          key => key.includes('GrowSlotIndex') || key.includes('CurrentGrowSlotIndex')
        );

        if (slotIndexAtom) {
          productionLog(`üéØ [SLOT-ATOM] Found potential slot atom: ${slotIndexAtom}`);
          return tryHookingViaCache(); // Retry with the found path
        }

        return false;
      };

      // Method 2: Watch for X/C keypresses and arrow clicks
      const setupKeyWatcher = () => {
        productionLog('üéÆ [SLOT-ATOM] Setting up X/C key and arrow click watcher as fallback...');

        let lastCropCount = 0;
        let lastCropHash = '';

        // Helper to get crop hash for change detection
        const getCropHashSimple = crops => {
          if (!crops || !crops.length) return '';
          return crops.map(c => `${c.species}_${c.endTime}`).join('|');
        };

        // ==================== MULTI-HARVEST SYNC HELPERS ====================

        // Define target context for consistent access
        const targetWindow = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;
        const targetDocument = targetWindow.document;

        // Polyfill queueMicrotask for older embeds
        // eslint-disable-next-line no-undef
        const qmt = typeof queueMicrotask === 'function' ? queueMicrotask : fn => Promise.resolve().then(fn);

        // Robust atom finder
        function findAtom(cache, names = ['myCurrentGrowSlotIndexAtom']) {
          if (!cache) return null;

          if (cache.get) {
            // Try direct lookup first
            for (const n of names) {
              if (cache.get(n)) return cache.get(n);
            }
            // Suffix match fallback
            for (const [k, v] of cache.entries?.() ?? []) {
              if (names.some(n => k.endsWith(n))) return v;
            }
          } else {
            // Plain object fallback
            for (const k of Object.keys(cache)) {
              if (names.some(n => k === n || k.endsWith(n))) return cache[k];
            }
          }
          return null;
        }

        // Safe atom value reader
        function readAtomValue(atom) {
          try {
            // Prefer cached "last seen" value if atom watcher tracks it
            if (typeof atom?.lastValue !== 'undefined') return atom.lastValue;

            // Otherwise, attempt safe read only if API matches
            if (typeof atom?.read === 'function' && typeof atom?.init !== 'undefined') {
              const ctx = { get: a => (a === atom ? atom.init : undefined) };
              return atom.read(ctx);
            }
          } catch {}
          return undefined;
        }

        // Centralized state setter
        function setSlotIndex(idx) {
          window._mgtools_currentSlotIndex = idx;

          if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
            console.log('[FIX_SLOT] Set slot index to:', idx);
          }
        }

        // Main sync function - sync from game's Jotai atom state
        function syncSlotIndexFromGame() {
          const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
          if (!atomCache) return null;

          const slotAtom = findAtom(atomCache, ['myCurrentGrowSlotIndexAtom']);
          if (!slotAtom) return null;

          const gameIndex = readAtomValue(slotAtom);
          if (!Number.isFinite(gameIndex)) return null;

          const currentIndex = window._mgtools_currentSlotIndex || 0;

          // Only update if changed
          if (gameIndex !== currentIndex) {
            setSlotIndex(gameIndex);

            // Trigger value refresh using consistent scheduling
            qmt(() => {
              requestAnimationFrame(() => {
                if (typeof insertTurtleEstimate === 'function') {
                  insertTurtleEstimate();
                }
              });
            });

            if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
              window._mgtools_syncCount = (window._mgtools_syncCount || 0) + 1;
              console.log('[FIX_HARVEST] Synced to game slot:', {
                from: currentIndex,
                to: gameIndex,
                syncCount: window._mgtools_syncCount
              });
            }

            return gameIndex;
          }

          return null;
        }

        // Expose sync function globally for harvest handler
        window.syncSlotIndexFromGame = syncSlotIndexFromGame;

        // ==================== END MULTI-HARVEST SYNC HELPERS ====================

        // Update function
        const updateSlotIndex = direction => {
          const currentCrop = UnifiedState.atoms.currentCrop || window.currentCrop || [];
          const sortedIndices = UnifiedState.atoms.sortedSlotIndices || window.sortedSlotIndices;

          if (!currentCrop || currentCrop.length <= 1) return;

          // Get the max valid index based on sorted indices or crop length
          const maxIndex = sortedIndices?.length || currentCrop.length;

          if (direction === 'forward') {
            window._mgtools_currentSlotIndex = (window._mgtools_currentSlotIndex + 1) % maxIndex;
          } else if (direction === 'backward') {
            window._mgtools_currentSlotIndex = (window._mgtools_currentSlotIndex - 1 + maxIndex) % maxIndex;
          }

          console.log(
            `üéØ [SLOT-KEY] Cycled ${direction} - slot index: ${window._mgtools_currentSlotIndex}/${maxIndex}`
          );

          // Update display immediately
          setTimeout(() => {
            if (typeof insertTurtleEstimate === 'function') {
              insertTurtleEstimate();
            }
          }, 100);
        };

        // Key listener
        targetDocument.addEventListener(
          'keydown',
          e => {
            // Skip if typing in input
            const active = targetDocument.activeElement;
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) return;

            const currentCrop = UnifiedState.atoms.currentCrop || window.currentCrop || [];
            if (!currentCrop || currentCrop.length <= 1) return;

            // Check if crop changed (new tile)
            const currentHash = getCropHashSimple(currentCrop);
            if (currentHash !== lastCropHash) {
              window._mgtools_currentSlotIndex = 0;
              lastCropHash = currentHash;
              lastCropCount = currentCrop.length;
              console.log(`üîÑ [SLOT-KEY] New crop detected, reset index to 0`);
            }

            if (e.key.toLowerCase() === 'x') {
              updateSlotIndex('forward');
            } else if (e.key.toLowerCase() === 'c') {
              updateSlotIndex('backward');
            }
          },
          true
        );

        // Arrow button click detection
        targetDocument.addEventListener(
          'click',
          e => {
            const target = e.target;
            if (!target) return;

            // Check for arrow buttons in the tooltip
            const button = target.closest('button');
            if (!button) return;

            // Look for chevron icons or arrow text
            const hasLeftArrow =
              button.querySelector('svg[data-icon="chevron-left"]') ||
              button.innerHTML.includes('chevron-left') ||
              button.getAttribute('aria-label')?.includes('Previous');

            const hasRightArrow =
              button.querySelector('svg[data-icon="chevron-right"]') ||
              button.innerHTML.includes('chevron-right') ||
              button.getAttribute('aria-label')?.includes('Next');

            if (hasLeftArrow) {
              console.log('‚¨ÖÔ∏è [SLOT-ARROW] Left arrow clicked');
              updateSlotIndex('backward');
            } else if (hasRightArrow) {
              console.log('‚û°Ô∏è [SLOT-ARROW] Right arrow clicked');
              updateSlotIndex('forward');
            }
          },
          true
        );

        console.log('‚úÖ [SLOT-ATOM] Key and arrow watchers installed');
      };

      // Install key watcher immediately as backup
      setupKeyWatcher();

      // Also try cache hooking for better integration
      let attempts = 0;
      const checkInterval = setInterval(() => {
        attempts++;

        if (tryHookingViaCache()) {
          clearInterval(checkInterval);
          productionLog('‚úÖ [SLOT-ATOM] Successfully hooked slot index atom via cache!');
          // Key watcher remains as backup
        } else if (attempts >= 10) {
          clearInterval(checkInterval);
          productionLog('‚ÑπÔ∏è [SLOT-ATOM] Using key watcher for slot tracking');
        }
      }, 1000);
    }

    // ==================== DRAGGABLE & RESIZABLE ====================
    // OPTIMIZED MAIN HUD DRAGGING SYSTEM - Professional and smooth
    function makeDraggable(element, handle) {
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let startLeft = 0;
      let startTop = 0;
      const animationFrame = null;
      let currentX = 0;
      let currentY = 0;

      handle.style.cursor = 'grab';

      // Shared drag start logic for both mouse and touch
      const startDrag = (clientX, clientY, event) => {
        if (event.target.tagName === 'BUTTON') return;
        // Don't start drag if clicking resize handle
        if (event.target.classList && event.target.classList.contains('mga-resize-handle')) return;

        event.preventDefault();
        event.stopPropagation();

        isDragging = true;
        startX = clientX;
        startY = clientY;
        currentX = startX;
        currentY = startY;

        const rect = element.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;

        // Professional drag start effects with will-change for performance
        element.style.willChange = 'transform';
        element.style.transition = 'none';
        element.style.transform = 'scale(1.01)';
        element.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';
        element.style.zIndex = '999999';
        handle.style.cursor = 'grabbing';

        targetDocument.body.style.userSelect = 'none';

        debugLog('OVERLAY_LIFECYCLE', 'Started dragging main HUD', {
          elementClass: element.className,
          startPosition: { left: startLeft, top: startTop }
        });
      };

      // Shared drag move logic
      const handleDragMove = (clientX, clientY) => {
        if (!isDragging) return;

        const deltaX = clientX - startX;
        const deltaY = clientY - startY;

        // Enhanced boundary constraints with snap zones
        const snapZone = 15;
        let newLeft = startLeft + deltaX;
        let newTop = startTop + deltaY;

        // Viewport constraints
        newLeft = Math.max(0, Math.min(window.innerWidth - element.offsetWidth, newLeft));
        newTop = Math.max(0, Math.min(window.innerHeight - element.offsetHeight, newTop));

        // Snap to edges with visual feedback
        if (newLeft < snapZone) {
          newLeft = 0;
          element.style.borderLeft = '2px solid rgba(74, 158, 255, 0.5)';
        } else if (newLeft > window.innerWidth - element.offsetWidth - snapZone) {
          newLeft = window.innerWidth - element.offsetWidth;
          element.style.borderRight = '2px solid rgba(74, 158, 255, 0.5)';
        } else {
          element.style.borderLeft = '';
          element.style.borderRight = '';
        }

        if (newTop < snapZone) {
          newTop = 0;
          element.style.borderTop = '2px solid rgba(74, 158, 255, 0.5)';
        } else if (newTop > window.innerHeight - element.offsetHeight - snapZone) {
          newTop = window.innerHeight - element.offsetHeight;
          element.style.borderBottom = '2px solid rgba(74, 158, 255, 0.5)';
        } else {
          element.style.borderTop = '';
          element.style.borderBottom = '';
        }

        // Use direct positioning for more reliable movement
        element.style.left = `${newLeft}px`;
        element.style.top = `${newTop}px`;
      };

      // Shared drag end logic
      const endDrag = () => {
        if (isDragging) {
          isDragging = false;

          // Clean up styles
          element.style.transition = 'all 0.2s ease';
          element.style.transform = 'scale(1)';
          element.style.boxShadow = 'var(--panel-shadow, 0 4px 12px rgba(0, 0, 0, 0.40))';
          element.style.zIndex = '';
          element.style.borderTop = '';
          element.style.borderBottom = '';
          element.style.borderLeft = '';
          element.style.borderRight = '';
          element.style.willChange = 'auto';

          handle.style.cursor = 'grab';
          targetDocument.body.style.userSelect = '';

          // Save position
          const finalPosition = {
            left: element.style.left,
            top: element.style.top
          };

          saveMainHUDPosition(finalPosition);

          debugLog('OVERLAY_LIFECYCLE', 'Finished dragging main HUD', {
            elementClass: element.className,
            finalPosition
          });
        }
      };

      // Mouse event handlers
      handle.addEventListener('mousedown', e => {
        startDrag(e.clientX, e.clientY, e);
      });

      document.addEventListener('mousemove', e => {
        handleDragMove(e.clientX, e.clientY);
      });

      document.addEventListener('mouseup', e => {
        endDrag();
      });

      // Touch event handlers
      handle.addEventListener(
        'touchstart',
        e => {
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            startDrag(touch.clientX, touch.clientY, e);
          }
        },
        { passive: false }
      );

      document.addEventListener(
        'touchmove',
        e => {
          if (isDragging && e.touches.length === 1) {
            const touch = e.touches[0];
            handleDragMove(touch.clientX, touch.clientY);
            e.preventDefault(); // Prevent scrolling while dragging
          }
        },
        { passive: false }
      );

      document.addEventListener('touchend', e => {
        endDrag();
      });

      document.addEventListener('touchcancel', e => {
        endDrag();
      });
    }

    // Save main HUD position
    function saveMainHUDPosition(position) {
      try {
        MGA_saveJSON('MGA_mainHUDPosition', position);
        debugLog('OVERLAY_LIFECYCLE', 'Saved main HUD position', { position });
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to save main HUD position', error, { position });
      }
    }

    // Load main HUD position on startup
    function loadMainHUDPosition(element) {
      try {
        const savedPosition = MGA_loadJSON('MGA_mainHUDPosition', null);
        if (savedPosition && savedPosition.left && savedPosition.top) {
          const leftPx = parseInt(savedPosition.left);
          const topPx = parseInt(savedPosition.top);

          if (
            !isNaN(leftPx) &&
            !isNaN(topPx) &&
            leftPx >= 0 &&
            topPx >= 0 &&
            leftPx < window.innerWidth &&
            topPx < window.innerHeight
          ) {
            element.style.left = savedPosition.left;
            element.style.top = savedPosition.top;

            debugLog('OVERLAY_LIFECYCLE', 'Restored main HUD position', { position: savedPosition });
          }
        }
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to load main HUD position', error);
      }
    }

    // ==================== UNIFIED RESIZE SYSTEM ====================
    function makeElementResizable(element, options = {}) {
      const {
        minWidth = 300,
        minHeight = 250,
        maxWidth = window.innerWidth * 0.9,
        maxHeight = window.innerHeight * 0.9,
        handleSize = 12,
        showHandleOnHover = true
      } = options;

      // Check if element already has a resize handle - remove it to prevent duplicates
      const existingHandle = element.querySelector('.mga-resize-handle');
      if (existingHandle) {
        existingHandle.remove();
      }

      // Create resize handle
      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'mga-resize-handle';
      resizeHandle.title = 'Drag to resize';
      resizeHandle.style.cssText = `
          position: absolute;
          bottom: 0;
          right: 0;
          width: ${handleSize}px;
          height: ${handleSize}px;
          cursor: se-resize;
          background: linear-gradient(-45deg, transparent 35%, rgba(74, 158, 255, 0.7) 45%, rgba(74, 158, 255, 0.9) 50%, rgba(74, 158, 255, 0.7) 55%, transparent 65%);
          border-radius: 0 0 4px 0;
          opacity: ${showHandleOnHover ? '0.5' : '0.7'};
          transition: opacity 0.2s ease, background 0.2s ease;
          z-index: 10;
          pointer-events: auto;
      `;
      element.appendChild(resizeHandle);

      if (showHandleOnHover) {
        element.addEventListener('mouseenter', () => {
          resizeHandle.style.opacity = '1.0';
        });
        element.addEventListener('mouseleave', () => {
          if (!element.hasAttribute('data-resizing')) {
            resizeHandle.style.opacity = '0.5';
          }
        });
      }

      let isResizing = false;
      let startX, startY, startWidth, startHeight;
      let rafId = null;

      const onMouseMove = e => {
        if (!isResizing) return;

        // Throttle with rAF for smoothness
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + (e.clientX - startX)));
          const newHeight = Math.max(minHeight, Math.min(maxHeight, startHeight + (e.clientY - startY)));
          element.style.width = `${newWidth}px`;
          element.style.height = `${newHeight}px`;
        });
      };

      const stopResizing = () => {
        if (!isResizing) return;
        isResizing = false;
        element.removeAttribute('data-resizing');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        resizeHandle.style.opacity = showHandleOnHover ? '0.5' : '0.7';

        // Unbind listeners safely
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', stopResizing);
      };

      resizeHandle.addEventListener('mousedown', e => {
        e.preventDefault();
        e.stopPropagation();

        isResizing = true;
        element.setAttribute('data-resizing', 'true');

        startX = e.clientX;
        startY = e.clientY;
        startWidth = element.offsetWidth;
        startHeight = element.offsetHeight;

        document.body.style.cursor = 'se-resize';
        document.body.style.userSelect = 'none';

        // Bind move/up only for duration of resize
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', stopResizing);
      });

      return resizeHandle;
    }

    // Legacy function for backward compatibility
    function makeResizable(element, handle) {
      // If a handle is provided, we're using the old system - just add simple resize
      if (handle) {
        return makeElementResizable(element, { showHandleOnHover: false });
      }
      return makeElementResizable(element);
    }

    // ==================== TOGGLE BUTTON DRAGGING ====================
    function makeToggleButtonDraggable(toggleBtn) {
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let startLeft = 0;
      let startTop = 0;
      let clickStarted = false;
      const animationFrame = null;
      let currentX = 0;
      let currentY = 0;

      toggleBtn.addEventListener('pointerdown', e => {
        e.preventDefault();
        e.stopPropagation();

        clickStarted = true;
        isDragging = false; // Don't start dragging immediately
        startX = e.clientX;
        startY = e.clientY;
        currentX = startX;
        currentY = startY;

        const rect = toggleBtn.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;

        // Add will-change for better performance
        toggleBtn.style.willChange = 'transform';
        toggleBtn.style.cursor = 'grabbing';
      });

      document.addEventListener('pointermove', e => {
        if (!clickStarted) return;

        // Once dragging starts, don't check for MGA events to prevent dropping
        if (!isDragging) {
          // Only check isMGAEvent before drag starts
          if (!isMGAEvent(e)) {
            return;
          }
        }

        currentX = e.clientX;
        currentY = e.clientY;

        const deltaX = Math.abs(currentX - startX);
        const deltaY = Math.abs(currentY - startY);

        // Only start dragging if mouse moved more than 3px (more responsive)
        if (!isDragging && (deltaX > 3 || deltaY > 3)) {
          isDragging = true;
          toggleBtn.style.transition = 'none';
          toggleBtn.style.boxShadow = '0 8px 32px rgba(74, 158, 255, 0.6)';
          toggleBtn.style.zIndex = '999999';
          // Capture pointer for reliable tracking
          toggleBtn.setPointerCapture(e.pointerId);
        }

        if (isDragging) {
          // Direct position update without transform
          const moveX = currentX - startX;
          const moveY = currentY - startY;

          let newLeft = startLeft + moveX;
          let newTop = startTop + moveY;

          // Constrain within viewport with padding
          const padding = 10;
          newLeft = Math.max(padding, Math.min(window.innerWidth - toggleBtn.offsetWidth - padding, newLeft));
          newTop = Math.max(padding, Math.min(window.innerHeight - toggleBtn.offsetHeight - padding, newTop));

          // Use direct positioning instead of transform for more reliable movement
          toggleBtn.style.right = '';
          toggleBtn.style.bottom = '';
          toggleBtn.style.left = `${newLeft}px`;
          toggleBtn.style.top = `${newTop}px`;
        }
      });

      document.addEventListener('pointerup', e => {
        if (clickStarted) {
          // Once drag is active, don't check MGA event
          if (!isDragging && !isMGAEvent(e)) {
            return;
          }

          if (isDragging) {
            // Release pointer capture
            toggleBtn.releasePointerCapture(e.pointerId);

            // Finish dragging
            isDragging = false;
            toggleBtn.style.transition = 'all 0.2s ease';
            toggleBtn.style.boxShadow = '0 4px 20px rgba(74, 158, 255, 0.4)';
            toggleBtn.style.zIndex = '999998';
            toggleBtn.style.cursor = 'grab';
            toggleBtn.style.willChange = 'auto';

            // Save position (already applied directly)
            const finalPosition = {
              left: toggleBtn.style.left,
              top: toggleBtn.style.top,
              right: '', // Clear right positioning
              bottom: '' // Clear bottom positioning
            };
            saveToggleButtonPosition(finalPosition);

            debugLog('OVERLAY_LIFECYCLE', 'Toggle button dragged to new position', finalPosition);
          } else {
            // This was a click, not a drag - trigger the toggle functionality
            toggleBtn.style.willChange = 'auto';
            toggleBtn.style.cursor = 'grab';

            const panel = UnifiedState.panels.main;
            const isCurrentlyVisible = panel.style.display !== 'none';
            const newVisibility = !isCurrentlyVisible;

            panel.style.display = newVisibility ? 'block' : 'none';

            // Hide any stuck tooltips when panel is toggled
            if (window.MGA_Tooltips && window.MGA_Tooltips.hide) {
              window.MGA_Tooltips.hide();
            }

            // Save visibility state
            UnifiedState.data.settings.panelVisible = newVisibility;
            MGA_saveJSON('MGA_data', UnifiedState.data);

            debugLog('OVERLAY_LIFECYCLE', `Panel toggled: ${newVisibility ? 'visible' : 'hidden'}`);
          }

          clickStarted = false;
        }
      });
    }

    // Save toggle button position
    function saveToggleButtonPosition(position) {
      try {
        MGA_saveJSON('MGA_toggleButtonPosition', position);
        debugLog('OVERLAY_LIFECYCLE', 'Saved toggle button position', { position });
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to save toggle button position', error, { position });
      }
    }

    // Load toggle button position on startup
    function loadToggleButtonPosition(toggleBtn) {
      try {
        const savedPosition = MGA_loadJSON('MGA_toggleButtonPosition', null);
        if (savedPosition) {
          if (savedPosition.left && savedPosition.top) {
            const leftPx = parseInt(savedPosition.left);
            const topPx = parseInt(savedPosition.top);

            if (
              !isNaN(leftPx) &&
              !isNaN(topPx) &&
              leftPx >= 0 &&
              topPx >= 0 &&
              leftPx < window.innerWidth &&
              topPx < window.innerHeight
            ) {
              toggleBtn.style.right = '';
              toggleBtn.style.bottom = '';
              toggleBtn.style.left = savedPosition.left;
              toggleBtn.style.top = savedPosition.top;

              debugLog('OVERLAY_LIFECYCLE', 'Restored toggle button position', { position: savedPosition });
            }
          }
        }
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to load toggle button position', error);
      }
    }

    // ==================== VERSION CHECKER ====================
    async function checkVersion(indicatorElement) {
      // Skip version check on Discord to avoid CSP violations
      if (isDiscordPage) {
        const branchLabel = IS_LIVE_BETA ? 'BETA' : 'STABLE';
        indicatorElement.style.color = IS_LIVE_BETA ? '#ff9500' : '#00ff00'; // Orange for beta, green for stable

        const tooltipLines = [
          `CURRENT VERSION: v${CURRENT_VERSION} (${branchLabel})`,
          `STATUS: Version check disabled on Discord`,
          '',
          'Shift+Click: Install Stable',
          'Shift+Alt+Click: Install Beta'
        ];

        indicatorElement.title = tooltipLines.join('\n');
        indicatorElement.style.cursor = 'pointer';

        indicatorElement.addEventListener('click', e => {
          e.stopPropagation();
          if (e.shiftKey && e.altKey) {
            window.open(BETA_DOWNLOAD_URL, '_blank');
          } else if (e.shiftKey) {
            window.open(STABLE_DOWNLOAD_URL, '_blank');
          }
        });
        return;
      }

      // Fetch BOTH stable and beta versions
      const cacheBust = `?t=${Date.now()}`;

      async function fetchVersion(branch) {
        const urls = [
          `https://raw.githubusercontent.com/Myke247/MGTools/${branch}/MGTools.user.js${cacheBust}`,
          `https://api.github.com/repos/Myke247/MGTools/contents/MGTools.user.js`
        ];

        for (const url of urls) {
          try {
            const isGitHubAPI = url.includes('api.github.com');
            const response = await fetch(url, {
              method: 'GET',
              cache: 'no-cache',
              headers: isGitHubAPI ? { Accept: 'application/vnd.github.v3.raw' } : {}
            });

            if (response.ok) {
              const text = await response.text();
              const match = text.match(/@version\s+([\d.]+)/);
              if (match) return match[1];
            }
          } catch (e) {
            continue;
          }
        }
        return null;
      }

      try {
        const [stableVersion, betaVersion] = await Promise.all([fetchVersion('main'), fetchVersion('Live-Beta')]);

        if (!stableVersion && !betaVersion) {
          // Both failed
          const branchLabel = IS_LIVE_BETA ? 'BETA' : 'STABLE';
          indicatorElement.style.color = IS_LIVE_BETA ? '#ff9500' : '#ffa500';

          const tooltipLines = [
            `CURRENT VERSION: v${CURRENT_VERSION} (${branchLabel})`,
            `STATUS: Version check failed`,
            '',
            'Click: Retry',
            'Shift+Click: Install Stable',
            'Shift+Alt+Click: Install Beta'
          ];

          indicatorElement.title = tooltipLines.join('\n');
          indicatorElement.style.cursor = 'pointer';

          const newIndicator = indicatorElement.cloneNode(true);
          indicatorElement.parentNode.replaceChild(newIndicator, indicatorElement);

          newIndicator.addEventListener('click', e => {
            e.stopPropagation();
            if (e.shiftKey && e.altKey) {
              window.open(BETA_DOWNLOAD_URL, '_blank');
            } else if (e.shiftKey) {
              window.open(STABLE_DOWNLOAD_URL, '_blank');
            } else {
              newIndicator.style.color = '#888';
              newIndicator.title = 'Checking for updates...';
              checkVersion(newIndicator);
            }
          });
          return;
        }

        // Compare current version with the appropriate branch version
        const relevantVersion = IS_LIVE_BETA ? betaVersion : stableVersion;
        const versionComparison = compareVersions(CURRENT_VERSION, relevantVersion);

        // Determine color and status
        let color, statusMsg;
        const branchLabel = IS_LIVE_BETA ? 'BETA' : 'STABLE';

        if (IS_LIVE_BETA) {
          // On Live Beta branch - use orange/yellow colors
          if (versionComparison === 0) {
            color = '#ff9500'; // Orange for up-to-date beta
            statusMsg = 'UP TO DATE';
          } else if (versionComparison > 0) {
            color = '#ffff00'; // Yellow for dev beta
            statusMsg = 'DEV VERSION';
          } else {
            color = '#ff00ff'; // Magenta for outdated beta
            statusMsg = 'UPDATE AVAILABLE';
          }
        } else {
          // On Stable branch - use green colors
          if (versionComparison === 0) {
            color = '#00ff00'; // Bright green for up-to-date stable
            statusMsg = 'UP TO DATE';
          } else if (versionComparison > 0) {
            color = '#90ee90'; // Light green for dev stable
            statusMsg = 'DEV VERSION';
          } else {
            color = '#ff0000'; // Red for outdated stable
            statusMsg = 'UPDATE AVAILABLE';
          }
        }

        // Build clear, easy-to-read tooltip
        const tooltipLines = [
          `CURRENT VERSION: v${CURRENT_VERSION} (${branchLabel})`,
          `STATUS: ${statusMsg}`,
          '',
          `GitHub Versions:`,
          IS_LIVE_BETA
            ? `  Your Branch (Beta): v${betaVersion || 'Loading...'}`
            : `  Your Branch (Stable): v${stableVersion || 'Loading...'}`,
          IS_LIVE_BETA
            ? `  Other Branch (Stable): v${stableVersion || 'Loading...'}`
            : `  Other Branch (Beta): v${betaVersion || 'Loading...'}`,
          '',
          'Click: Recheck',
          'Shift+Click: Install Stable',
          'Shift+Alt+Click: Install Beta'
        ];

        indicatorElement.style.color = color;
        indicatorElement.title = tooltipLines.join('\n');
        indicatorElement.style.cursor = 'pointer';

        // Add click handler
        const newIndicator = indicatorElement.cloneNode(true);
        indicatorElement.parentNode.replaceChild(newIndicator, indicatorElement);

        newIndicator.addEventListener('click', e => {
          e.stopPropagation();
          if (e.shiftKey && e.altKey) {
            window.open(BETA_DOWNLOAD_URL, '_blank');
          } else if (e.shiftKey) {
            window.open(STABLE_DOWNLOAD_URL, '_blank');
          } else {
            newIndicator.style.color = '#888';
            newIndicator.title = `v${CURRENT_VERSION} - Checking for updates...`;
            checkVersion(newIndicator);
          }
        });
      } catch (e) {
        // Unexpected error
        const branchLabel = IS_LIVE_BETA ? 'BETA' : 'STABLE';
        indicatorElement.style.color = IS_LIVE_BETA ? '#ff9500' : '#ffa500';

        const tooltipLines = [
          `CURRENT VERSION: v${CURRENT_VERSION} (${branchLabel})`,
          `STATUS: Version check failed`,
          '',
          'Click: Retry',
          'Shift+Click: Install Stable',
          'Shift+Alt+Click: Install Beta'
        ];

        indicatorElement.title = tooltipLines.join('\n');
        indicatorElement.style.cursor = 'pointer';

        const newIndicator = indicatorElement.cloneNode(true);
        indicatorElement.parentNode.replaceChild(newIndicator, indicatorElement);

        newIndicator.addEventListener('click', e => {
          e.stopPropagation();
          if (e.shiftKey && e.altKey) {
            window.open(BETA_DOWNLOAD_URL, '_blank');
          } else if (e.shiftKey) {
            window.open(STABLE_DOWNLOAD_URL, '_blank');
          } else {
            newIndicator.style.color = '#888';
            newIndicator.title = 'Checking for updates...';
            checkVersion(newIndicator);
          }
        });
        console.log('[VERSION CHECK] Error:', e);
      }
    }

    /* ============================================================================
     * 10. UI FRAMEWORK MODULE - MAIN UI CREATION
     * ============================================================================
     * Main UI components, panels, and interface creation
     */

    /**
     * Creates the main unified UI interface
     * Initializes all panels, buttons, and UI components
     * @function createUnifiedUI
     * @returns {void}
     */
    function createUnifiedUI() {
      // Guard against duplicate UI creation
      if (targetDocument.getElementById('mgh-dock') || targetDocument.getElementById('mgh-sidebar')) {
        productionLog('üé® UI already exists, skipping creation');
        return;
      }

      // Critical: Ensure body exists before creating UI
      if (!targetDocument.body) {
        console.error('[MGTools] ‚ö†Ô∏è Body not ready, retrying UI creation in 100ms...');
        setTimeout(() => createUnifiedUI(), 100);
        return;
      }

      productionLog('üé® Creating Hybrid Dock UI...');

      // Add hybrid styles
      const styleSheet = targetDocument.createElement('style');
      styleSheet.textContent = UNIFIED_STYLES;
      targetDocument.head.appendChild(styleSheet);

      // Create hybrid dock
      const dock = targetDocument.createElement('div');
      dock.id = 'mgh-dock';
      dock.className = 'horizontal';

      // Primary tabs
      const primaryTabs = ['pets', 'abilities', 'seeds', 'values', 'timers', 'rooms', 'shop'];

      // Tail group tabs (Tools, Settings, Hotkeys, Protect, Notifications, Help)
      const tailTabs = ['tools', 'settings', 'hotkeys', 'protect', 'notifications', 'help'];

      // Icon mapping
      const icons = {
        pets: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAADkCAMAAADaZIrAAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAACXBIWXMAAC4jAAAuIwF4pT92AAAC/VBMVEVHcEz5nVv5jGPnqWjcqnb3nlf6tGXC1apD6bJE6878nV33Z+H6t1P9jIDuzW+9mdig4V261+D+hFvsnKHx0VO0PL7ygrJD7pFs7HyP8syy5kGkNaS0y1quMbLlski6TOHR6Gdc6UfSapulr+/iSvxJQy/+4X//yIH+1Hn+24D86XD+8H20NMr923j943f8+3j+z4H6+mn+1oH86mf88G7+6H/+zHr96nj+xXn98XbV+2f/uH7G+2fj+2jv+2fy/XbjUvwtad/9zHP/wID91m40SS8reN0s35Bk+rIsht7kW/1Q97Vk+sVm+6dQ+KZl+rvo/Xb88WVp+423+2Zj+tCq/GtP98QtV+As34JOtfYskt9jeO9qY+/8wFaB+Pwt4J2e+2RR1vemRu1i+tyxRe1P9fT/3cos33Jx+2d+5vxS+JAs315P99T84Gn9tVZPxvZ6M+Fi+por3raP+2Yw3jAs36na/Xb/fllBm+os38+7SOpl+3OA+2VO5vZ+1fz74VR17bRRjPjL/XVO9uT/rYCaSe0u394tRt8snt9S+Xgt30hh+un711Rg9/hvM+FBqupi+oNK4DAyNOHt2nj9qVf+jllqovNu/H5Rofgs3sP5zFFmjfEsqd9wtfaB/fLKXP1RcviA3SssyN9rSfHdS/jWVfx1xvhg+mX/18ksvd+HM+E/uellMuAstN9l3StUV/i/Yf1GMOHWyqqZ3SqHXe1ASS8t0+Cw3ixZ+FNAjeruTfxXMeCMRe7G3izWYv25/HWP/+D/4sr9m1hbSO/t03hBy+px+FL+zFeZ/HKDtv6I+VH861V6Re+q+VE/futf5flt+5t+dv1D6Zl27J/Z3SyB/ub0W/oveeKD/HHfzi1L8WBBbOyW8ElD4eeL/9KWNOFKRvD5+VSwZPx6mf7U+1RD6Hzo+1To2EPB+lO8OtpJWu0hLdOz6EVx6EUm2Kni50OyO9pYXjv/x6nM6UQfXNKQi1rJP+Zwc036d7TIsF7ox0VhtVmzqoypu5JHcExw1ESbAAAA/3RSTlMAnGIQIDx9/v7+vvzf/lv+/P7b+rp9uXxClpFP+bP3w/rC+7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAoptLHAAAycklEQVR42uSbPWtbaRbHR7alwtghBBfLEoZpolfulaLEV/eOkhgkfQBv4dKQygwBp7SKXTAYNQIVU1jkI0RfIODORIVtZNwH4cZgggs31hLM7G5gz9vzduXpdB0vex4pyxZT/Pid8z/PlaWffvp/r/n03FwmlVpcXFpa2qd6jwX/b2llcSWVymQepdPz/yswc3OpJ/3+EAtI6J/3Upt8sOB/EXExBWwPGW2BaICHiYb7QzG0r4HsOt485tpcST1KP0CedIZwCGmKaD+m6ZiPhurBeyXzoLDmM0/a7Xa/3Xeo4pboX8uRxQRQvV7veOXRwgMRtMg8TDTsUA2FR0+S9N175hEkzQNECNXrPQQqAmozVGcy2NqC19bW58+T5v6+bcmZpmMZpc1pJqBKPwQgdLQ8ARrh+YxvoILKcVVyuSAMG2FjM9S9F+s7U0uPftwMpdqq+h3GISQCEiaFZFe+0Wg4imiSWvDPdm+3twv1o6DmDFC7PxEkzYNlHFU0VFVVvtXQioylXWI63V1a+FGKlvsIBMkwMIo01MRCqtC7yoerUC0UWq1jsYQ4CLS9S3W6m7n3xQq5vTwZDAYTirqOIH22q6LnqCKWDBDyUGULnlHU291VRLv3LQqJEAgLgDqdieo6Q5XLNZ2uqzpImgiPt01AoKgnQKdQvUf3S7Q8UDWhTbQVHyUh4nDIqUGyu46ZpDyS1LMsQWV+iCPFNHH7Duao6YyR03aaKEuWoFZXs/621XanVL17Y3KItgaDaaRKUzmq6ARnnoqtSHiACM/qKkG9QCBhui9PmbbVdrhglSatKGcRVawAryhFVYdIgFYFCrvu9PQ+mRYgvDsWEVyCOp16vT7YMj3nxLdF47RdVkvCvhOmosGBuji9yNxP27UHjqUt0FTvNAdiCIGasWC4O7+z2ZilErxe6LZDoouL5HMPLw3LjiQoIAJPkwHd6+yumyZSTNnYIBkomwnqdOE+JFnhsMXTVCeoZlMhNd27HRPpnVQlJJtJFWoqFU9tSxcr93GzmxhHrGkCjupNQKobSRU7HAxRQaedDgftiICgasJDRBdJj9OiiySXVUISS9aKtcPB5IOzklbtbCjhwdcL3XZU80nHnaTDlilCaqq2iydDZXrFWtlgtR0TUf0NeBjpK5xENaUMks4GuAU1se0cSZWcdbdTkqyNZHBcIsUkigAIanc+4XCQxnMk8RTZbWc981Xv7rmCy2TxlErlSJC4EtSU5me+ZafzPutwsPrOuYJLhBesJRtfSaVVNUdSuusQKcFpUo/mk4EOO7gt0CARU040WfegqqXJfqKI3YTctiuXys+NpcskNT1RHzWoB3NeSfXptrsjG8RS9k9myTKESGWL6PLrSsJ911/uyGMsANG9QUYppx05RJX4E8VdWVcyfYdAZdSkiKDSSe7Zdr9NN+/BZNLki5BO8Dvu3/ZDUvyyakHZ2VBmprULA3T59a+J7Vn+WLWjy+Kx8jt2Ac/Hn82nbkF2Liii8htNdHV5+UtCSKSo3R4qHiGqx8KOmAJhyss9KK9vqybrsvbVzooGqrU3ytJVcp2Xlk+4Ogapw0D2ljWSgmqAOzYPxwMejyR505fV0lQ0ABDUV1T0lSxdXWYSG6W+jJKxFJcU5IIKvAKRpNOOrt9efCXVdONpS5qJLBEQ1EpCW8kZpbpuPO0IcMBQIB8Uc9OBpIJX9Qp47OdYnxXV3FEqS9dhveZouOKaT2grIdHQnSSd3yEcajxUFCASNx1SqWck0ORlfSDyGaoWZ5JJAqD19deXBunsKp1MOtDfkGLZwIrCkHsOYIKKAOWrcgrsCHGo/KxWREA1J+sg7BAISvNAXWUSSYc+NZ4V39YzEjkKeJTgaKKqhAMgYdd5WZIEmuDQINWcjcRAFtIlKQKmJIZpTv5uqbJOgPCNikIGqkgy4CBVmIkniZuOFGV9miRkAiI8JEptJIAiop1fVdOhpZ+TSIc+//XS7ju9Z0MJO2g9ajzMhjx3HW8k6TuEAhY1SXBKq7U/syRI1Hhn/0rgY5XFvv5zrL4HkaYw5K4LFU/ATFVgYkVkCWk8kkRdR9EAeggogrOmk4GAdnZ2fjVAZ2f/TODTryfTfVdvhvBq8iShIcoHViTZIMlQEEXYdFmeI0SCzoOei8iQIVojInjptnsL7wSQzCjpJdskIJYUStzBKx9w1yFQHiXhW5JBDRIy0QyJpVLZpDe8EEiQoEYINfuba5q/etLXYYfXBgRqhjJF1HdqjJCImQoCxE2H+Y1dV6tRNpAjPDq/11Xb7ezsiaOzt6Pz0ehpEkjDPiMpS00CQkeh4qH8pnsDdp26NmQLNhEwUTDURFEpKlvJsG6I9l6dMdDobJQE0hxLGuqdFMIhKNizQMRUgWOpyj2n2466zpdR0gke6ZuQZtphplck6RyBRqPrhQQynDTpJYtMUE0KvEBdHYIgj4eBrHuD0uRj49XIEWritivrhSSSgGnPWDonS9fpJDIcvxuk0y7kLYtEgfSdclTJsyZsPCztCIlqPjLxPpJJKjv5TdGARHt7hHQ+YktzCSANqe+0IsIJOcADaDyGUjyUdXmPA9zHF7Uc84ikGgFFZXchGaJDdoR1NLrOJLCW8BtcVt9x2mHXqTlCnEAM5T0cJRojz/dYEEFJNMgURZG5fdthtydI5wrp6Do1+7XEX0rTY9TkORIazrt8gI7w7VHT8RQhTnyMSrUIHUU0SbKQ1kwwENDh4VuOhiOsx7NGWpCvQ3aYSBoPDQFUKFT5gByRJmw6GSTPtB2MUs0XRzVUFMWyzkg63EMkknSEUNdPZr2WBMmeJAk7BcRZx7OEQDRI0HQeOiKoGlgST6WINZXxqGtDnAiRjKVhApuWA09WkqQDAoVakYQDzRFfhejaAFAsqearYIBoQEtl7jtXEmWDIJ0rooOZI83J1zt120kJEGWd8GA48I7F8vFQ3/nsiNou4qwraUVmxTIQl3F0cHA9nPGuzchXpUmSpANupFClAzmivPP4yELyOBngXfN1eGPTUd2V3yobDg83BOkAiMDSjHdtSr6BK10XxizxGEnpZMAx4qbzfTLk63XEjmLPE3bYQZ1snLCkA6zr4dzMkYiJJIkjDWQpynMu5K2m84hn1bcMiaPoTxaSEB2enBxpIrA0Y6RF/lZxB4GUpkCnHUeDkaQ0EVNWSfKFyAHirltziIhpA4hORkcJIw3339OjrO46JGrACfINY8ltPNV1yOPbYSdQd2ykPZG0EbM04xvRkuo7siRAypIFRJ1nO/KsUVLBQJrKkfOhnbuQGAiQhGg8BqQZXx/k2+zv63XbUYiGGtR1DThQLSSy+k5LMqOkiKI7F9KhcoSjdMJEY2R6/POMkeQHBxZRA4gYiGiCeNxZhlTXFa1oIElrzvOE2UgbmHZQX8TRwbh7MJox0rxC0m1ngNiRKGoZItcSA9WiYjwa1uznCZUMBIRIRPRx3B13//F0th+4LsjPDTRQA4CQSRM1UBAOUsskg6fHqAiHiKwV+9y5NDgrVoC+fPlIcwRI3e5vjx/P9oonP6Gwl2yDw64hQC0n7Xy+r3IV/dhCeglA7seQ6qFPJG0IE1kiSQkg8U/GxFKDjgBZUNh54snXNwcEKvrgiTZS0Uo79aGdk3bYdRuupW5SlvDnVQKkJeVpJ03fhHxv24RDkTqvpoGi6LluPPsipAfp0G287scu1u+/z/YiLj9Hsiwhkeo7FMR+8qRoGyVtsyKSBK+oqIBQkhmk1/jpt7k1bIijL1gfPiIROuq+g/fMkfCnSKbtOOxEkM45AVJtV+R4QCIMPLT0svyS5+g5Eb1ej88R7aOTLyeCNCYgRprpHzcz8pMxC6gBhSPUaEl4S9S1fGo7LQlhipwLReuqyo5QETt6xUQm7ADow4e/j7np3r0DpPHCzJHEkjARVssMEjNty6O5SoYi53cRuq72kohQEipaW3+jPs4nR69U1m0opN8QidruHb7GCSBZlhgK56jR+HZ7c/Ps5vbbHwTEUKRoWzNFPEvRSzgqGd6gpV/wP/4E//HjvSlLHwhprC0lg7RpWyKiP26f3f4H6vbZs2c3AuVj72kgju+iCTs8/EDx9PbT7bfv379/u/n06ebfzkLSjcdA+Op2/zLTJ0CWtBmKov/Scj4hbadpHGeoU6el1IbuDivMYWAJDAFbQgLbBpOCJBAwMRqj0IPiIgVTjIMIUoiGUHvYxYqBLLrIxsMeLMvchCz0ZA6RmpOhIshCc5E9ziELQVxb2Off+yfRFqPd52eHYWBgPny+z/d9fz8YYaC8+8oNZ/3jNg1BnZSx6HrMIunoYTHgQ46ACELnbxSLHzt5TorF4sk9yxEqgslxMzyn+XP37zr+H0gMxZYe1TURjIiy65twXBqI6w5u3xi6H0HNJ6DZJibAC9XvWY6mECqek9TxRLO1zs7ur/R/qn7D/yup8Dzi0JXrTqch2v7oFKYUQrkEykWZ81I3uB8/lG4YDCBRQ3hw6qEQMCmgNDmKx+OaaAAmVuPJdn+FCN6e0cHj2FEvAMG2NQ1iKqt7HfKwpj94WRLeg+iMhdgBUbFTSwJNIWSa013XjPT++QBAhWs1RVXr7rg2Eg23nSCdAkDDRiJNzgYoQkkpJnJh0XE5uCl2kDqIXQOXp9OaT6EiMJ2pEwmh4lVAem4kaUu1Wgme7rtfx5KGCvbVL0ZynipLogl4vCDJy/fvJwQFsXMC0raVPCQKhRYsS/H1qgnec4WU0FT/eXX3upbGZrQjkXQhUuOBK0U8uEheF3ryEhD1Nx+xPxRbLXWGWJNFFK9W2dL7gRZLh/CUSg6Ho7PjWkhj8NNnoLDgnCcXIDnzapFcqhzwoaudEA2ipGK9OXg8R1NHU1PKUXWWBTFRf1anrlQ7LNE4bl714nenxVKwr4//822kulMlj4Co7bxeMsShkwMpMOgr0nyykE4EaWqK9wgcgaWqRTQwEBEkmsPDw81NYLqqqDv8uwCUIbjbnUrKWgqPkFx6jagYiEmA6Izl3DUlT0kKnaWnWNE6ALElAervj6lmEKbN0ubmeMnRfUUk/N0GGumnYFCQDJOKHfwjlTrvY5dX1khdVgODfv+8X5AM06e6RuI9IkXVahSB3gsRIpWUpFJpEy2N43RfJ3iSup+0JVinj82OECnlkvFai+RmRyBJI4XqlL1PjWLIIHHumCmqLfXDT0RtElsCpnFgKl2N6c4M/Waad48UlLaEp+vJSd3pdDZZQk/gCI4k9IRAfPsGS/P+eYVUDBXxXzZAYkkTRXXs2JJOXWmTkCB4MFASV7M0NjamyyEY7HN+dk5dtiS1SA+VJHhB+rGomWiKoWILkuQuqruhH5giliPKnSCNj2+3f0L9RX5RiADhm2z9s0hlDcSb5GZJAbyt4ib55n3KUaho0dCkDVA1i0hKUT8i2Y4sonHHdkf7SDR9GikYbHyOqC5Ej5GJTlncIzd3HTgCIt+JYQo1MdWx7YQoGo2GzSIhkjKEDW5LAqbbV0BqkgSWTr+cO7g2eHlIkUXkgxfzHxRPCxHkLm5Sl42GdehgRiMiaVMBaaJxh+Pu9S0FT74kyWugqBmoGAY5dS99L3uVppbYheJCFEVH0XBUYvcdEo1GzCF7eNgEND6eTN64EtI7vUkw5S+Wg5dWCXKHRxJKeoJIfogdEr28ZzTZUP9eN0zgKBsWSQNiSTInlsYNVDKZ7L6ypaDWdGH0GroZyBECud3q1oBEJKn35dlFjs40EUiqgqSwVQ6j/QkkqhHQoSFK8pN0dFwNSeHQND5HpNrO637sVmdsAMsONgkU9fbu9A6fsZ+WM0lOJExdNsyW+oVodDQBigyRKEIa+tPm4TSjgidIkLyeizwRkQceqQZd33zE+pjoZe/wzvDwWehcNZj+hmqAVYoR0ndCNBphoPNEMJmkw3GjXaT/jm3wKcueUsEHwVS5SdTJKcCQIyUJ5qE0A+2Rbx4y17uzM7wzMjJyr24D1c/Wc6bs0FIsFo5pR2TJ2qMWIgdAZW5ewRJdGyR1PSmgQqi6uhZxMXikGbi+n6CkQbysDvpYEoZuZxiIRvb2fj2xgPQaUX+HYQBKFzjM9EVIbChDf9luE2kDHrNHPcDTk0KsVOqUJkU4qEjFzo2WnrgDBISpm6diQKYRQprYmzv69QzmX2/S63zGxqW/wwAVi8XYEikavTU6qYlUM8hkECqT2f62XUsbTZYwekgUTLkAC4BSHrVHQGUsqSOJNoktce5GJvb25uaOjhamYNJ8syMiOZLCYYXElqZV8PQpmyQoxsG/2b7dFtIGIRkgQAFTKAq/CLn4fcJDufMYR243VoOfFolPJOAhIPyaT0BAlE4bIpKUjcZAEuQuxjicu+lJLcneIwTicWzfuEbwaJd6UjIufojIdIOXqoHLDm8NPqxvKjtK3QQiLRyRorQm4mrATYrp4DHRqIW02dR1zJPJVNrp8Rki2tCWUsF8GSePH1YJCX+QBxR5VNeBI0qdn652yINlx5L29phoQYhy8QOa7AEC4SKBpEhEeGCTpsmSytyKWqSMNRXH9+1a2tChK8vkAarJkT6RvOrSgEesz+8jR3AgkSJeozlZI/paLEQIZRzFDNK0QlreRJ7xZkVbgvSqoz1LuEs85bLFlMduYEm0SB52hHvEa+RXd1XsBSGamzOpA0XrBghHAYElVkRE08vmZpdskrQFTwXD9+rmFS3ZQIAEjedRkhBoSK7f7oAcSdR1WHW9vEdU3yIpDUy59fWDdYkdPVmOHQXP5G5p8tB03QoC7bMkRQSWbrdpSZDyZcsSMUnwPOqQHWJLTwL+gJQdWMJqkNhRM1i5yx0YS+yJLNViYmnaWFqmPVpJNm3S1hYxVRz37186eTOUu41352MHRPmUh0LnodQNAZA6YwN4xuIeoSSKHVTDxIghSjNRXCQx0IFCUsHj3C0tLQMQS6LcoaN9cgQ/SJSpdHX9ti0ktpRqBcrnH7g0knUgSdmZ2/fwsNS37jo8kdK67PQqMRIARRIqdEgESLBIK4ooqdcIJFWAqYLz+8sjbSiklm6gISBmGgIgr33EgiQKHaQOu2FCHUj6jIXLqtmkrIIiIkKC1N0ySOhoJbmPjnTocCoZeiqVG21b0gWe10B5ApJiGNJlR464vnvZEe/R3J5qBqpvvH43rRFNjYASCalvBFpaWtnERdJrJKFjR1tAg0Rdd9u3lLIUlRUStrdAqWsQNQPdvunS0Gs1wxwpombI8RuFqTs1SBQhpFsK6dkynUhJKTuJHU+hIsGrfNMmUsqyZHJnWTKSBglJrqpGkpxIU8pSLof3oHNECW2JJQHTsyUEWsE92qcjdkshgaKCsuS4f9mvrdYu5VuJ8maPRBKVHa2SlJ3V3wYJT6Qc3+3OBS8rSFzfSLT0DC3hgbRPTKBpX0kqbBUKytJla1yQ6PUo2FwN+bzXI5ZsSX4FJI7o2jAhRyxt0hvMHcZutjpbPbBxsgmyBESJiEX0bEXdGuiExcNINqlQKVTUXHaZBOk1vVTkRVG5OXbqQHIHFBItkhyxTDRBi3Q0JSdSjt9kgSnbnLtagokSquwECf0YQxkxBI4KlLxK5bhS+b4NpNcbQX7ps0OHqUMiCt2QKjvtyCKa0NWwoA8kdDQ7S18abE0KaHIyYYCeLS4u7u/v84G0r9sbiSpG0/FxV1tIFDyYpmrQ1wZT3wG7vrHr2NHchErdm7RKHcSOv6zaseO2QyRJHTAtPlv88OGfu7u7f9/d/fnnLQ0EWwR/1goFkVTputEG0uvXKYF6YCvyeIY8uhkuIrIOpAUpBnhH4j1CJHnpM4uUEEcwtqQPAARQv/A8fVqQZkBHawIElr69NNJrLnE18E6RQhxeJMCyLKnY2ZZU1yEUNoPKXZWDh58a4N08oiahLSHREiMh064wrdI8LdCsFY4pewB13HWzHUv8+QTHAzgp4tGWmuv7fHvTiaTO2HSOcjcLlvSbeVjdVTWQWBKixQ8G6JfVv62uvlh9AbMmTJVjIjruutxh+xuUBI92pJg8quyGdDfoakCm4V677ISI61v6e7ZqvgedJ7K7gZH+gUyrKOnFn5Do7du3f10rrK2Ro2NEun1ZJCIKniPykiOWFLDeY1nSsC67CdV1U28sIgG6gGgSkZaXJw3Rhz/+j7Jz+YkyS+NwWsVg04xJm7gbF67dTJxVhzZhU1JiY9AesKhKoMYYO4ABujWh0+1UjOOoILeFFR0wXkggXGNiRa2oLMbAAptiihAIt/QAJUVqQCaRBWE17+1cvg+V4i35A548v/N7zylsm7qBFPU1iaMoz9VwmHngZ//f0/vbKdwOxpJSpEKnibbcGTSR3Oyw7LAaKHb//q6GFeFBUkQntaP6+noiuoJIwSsmdTjoqKQ2WgJEsVisNcxAYCm9LyDE0m2No4D+TI4Eyd5IObiRTOjK3ESnNZHrHH1vAwESE81dCQaDdjFQ6FhSzAtIsavEg0gHMtJGMpKI6KKRVPiZjYSWfiqzz5FcVjF2NfpLO2TCLxv0RhImaQYgmgva1dBEjpAphpYmwdOiQkrrv7D7wgoeS7qoY3fULUnXt74HKUm/0kH6Ra8k4KlhSZ+zdIVPksMSl11UxS4Wm4nFFu8L0t40kW4nb98OaUnmJFHu3PVt97e77JioRkvSX9uxJAdSQ71UA1gaDA4qR7Vcd9Fajh1CzUzOsKb4/vRaXCyFeL0qHi67TxBR2ZX9ZcQmQkfNzY7UuapBA9WTpIYGWrGYOyUJ+7u2TSsiR5NINBNjpPj+gztDOnrRcY4U0bw7dbKQXPXdyTu2mYiAKe+jO/Z7Q0RIV+AcBeFipxZSE1cDHySKHQDBAA9+0kPai0RJtyXj6BgUuOP2fcZd33gN6vxBSaoRSS6gk3ohnWMgQKL6JiIYA1RLiqJedsSz2IpE8f0H0kYKMZK7GAqlGZak7PRCOkNEWpIcI9xIyKPLTjO5uo6ZsO0G8SBVVQ3K3dt3V/c3O4KTlAufFAK17gDpn4RkNcNRdlSoUgeaEt+KpGUiGrEdAVKntWSJyRBt3bFQDYKE/R2sUi+KKn7xhe/WMtGkil0xB29Hlm6HQiIppC05+vsbDF4iJ2dr7qz6lm6wLJn+Pumw1MBIQepvjF2wowoeEx33ZcLh8FXShN1QDFCgqDW+GEkP6Q+8lhCJePRJAqL5P0ns1FU1Zznn42XHRDWn7fZ21bfLUcMolR3GrqrHp958woM/4XDrVTpKKfhA6HAW0vpGhZDwf6xhYsdE8+xoSbVdQpfdiL2Qhri/f3E4KlC5c98azimiUUBiIrTUQ0BV9JQI32egcCt+/IBUnHroB0l+YNoBEp4lnrdc34VS31R2Cbu+y5zN0Gk2kiq7gjxrIxXZG8lyNDqqy87n8yFNhzz5wjKLQATj96dSKf9OLGVgOyTRUgh5jiqi+WOSuiWu74Q0w4i1kIZkITFSje5vfWsocixZ099INKoc9fh64GFepYAUEgItaqZ4/OHOkGAuHnXv2GPzsmLBkvProI9KKheiAqsYTjmfSA4iQArSQgJJPnWM7qtzFGZFrZA3vz+QClDsACmdq/gesRRSFztimuf6po30rUgiSyNnXDtWITWftiXl553Khw86KlJIFtMoBw8cDVb5IHg9JMlnSwIodsSWAvH0kTI22ZIEr5CBpL6XcCEluBqW3Tt2yC67Zoldgb2RKHjKUr2LaFSaocrX4/Pdd54jpQgktfrjHLw4UD1JBynj0CYWXlJJAqh57G9M3ZI8kRL6iTSi6nuY6nvIIJXrtsuzfmsubVdpCtzkbjSogXxNmL2wk4kcgSIK3n/YUlpIX20SUigEzfBWHSSOHRAtqbJb5tSp9wQSDUk13AIieU8U8EnKz4PQiaIix3vC8IwGCQlT52u6S5c7K3KiCc4RSgqkUm8IaWHhwPavi12bm5vJEDeeugfNq6/slvgVm8AFm0Ndx46Gf1LHqJMXEqSu3HrHkqST6hzJ90HO1AX/FuwAJB+2HTji66qzGVAPQAX8gUDqDSJFgOnw4W3ftV8CURItrfE5eltIF7t5KYYlCJ25BpXZ9W0VQ/lpdY7I0SmshpPqGFHq6reEDscnoburv+FyEXHqFFJ8Ib7w+/+ObFfjhwBpM7nGwUMg7Dp+9MlGovpePgO5GxGkYey6oU6LiRwV6IWUz/1dhJIq9auvwYEElmjHwtyVN0U0ykBh7jmBQktvUm/aUVK8sbq7+4/bNDgjJZOMJCvpGGpa4mtDIifBFzvZsWWYumFd37ea4SjVmLYrQEun8vJN2dGrz4qdOkhBYKLcqWdftNZjHSR/1G+QxFLkN0Q6nLFd3yUJKWlbkts31bdaSCOO3DkklTOTtpRnXxvOVTrKTuobT1JHkBxZ71iPLga/v9XKXeDNG7AUj7T39lZXVx85uM1S2tycmkrSmNSBIrkIJfTtmyUNYzUM/TCkHTkuQvkgCbsun2KHZVeJC+maq75ZEZaDz7xko15AatUHiYhmAgSESIH2SKS3t7exGpl2b4M0pZAQir9roPYmIGo7dOS8ffNCuiULiQ6SXrK8kIrk+i2Oztc3nNdlhx84SJA79Q0XKJr0eCY9UbVh/TEAgsz5FVN7exyJGpHpSMb2SJS85FpybW1tfl5dgxKq7Ggh0ROJHKGkTr2RoOykGgpoH+FJKqK6A0lUDddcGyk42iH9bb49iUa9HpjcqNwazCnSRI29hESWDh+EydjzKaSpKda0hj88S0vY3ujom2XrXkfHaFjq26SOX30F+tYgzVDJxXDt3DnXXXU0qHl06JjIsx5TkjB1aIigIoH29l5D1P37kwGciYO7PoNE0VtbCxHRB5pEIiE3O6rvET5I0gyYu1u4ZMvLtaTvyBG++qi/sb4r1Y49T18I8Tt2sKfH/M6lSRFB7nI961EhanVYAqSXLxVSt0Ha+NfXH4HaI0hTpEksrX0grJWVFfgZGTkzYiwN/2osYX1jN5TLQSpgSZC7IrkIIVM9Njj+Zgx/0Ue/ReoZNL/pk2ZAIgtJtR28KYgo8JKQGsXSX588GECqrOwD2V9vid9uhTQ1nnTwfEAcmtmVWZjV2dXh1SH9T9rhv3uC9V3Omgrg3gBlZ//1/KJ9Rftk5mTkV5eGiGPnVUS5jGS3t5b0EoFQUnf3q4UnOMiUtZF9Z8u35Ic00pRm4hGg2dmns49mHwESTMtq/4uWlrrp6emK6el30+9oxt6N6ckcy5TZlyk8++auwWdOObJ+jYSxi5Z4vZMeJspdv0qpU7FLCVGEcqccdS8wEqdvY2PDfZH9SoDG4c/4uFKkDIGip+RI5kXLi5bpOvq8q9BACinTABFRJhPtsx1ZoUMgLww1AwABkrkI6bYDIkDS1dDdfd2BhPFzMX2pJPG8HpfUCRQBPZplR6sI1IJM09qRTWRBKUcsyeWoCaHwe+ISIppkRYxk+jtlIaklW81ExDQgTBNZG87rxBcOIJ7nK6/NKcLYrT5SRCQJUlehUvfOmbkx4cn8NBB13c2SEgHyeD0KaX1d94LfAopEGo2khQUlCYgeDAycOHFiYiJr70eQpsQREb1+jvN05bnETkmC3JElPklbcjfmyp0wqYM0J9XQ1NZ28yYhIZPHayQVa0sPA6bA2ZIgEZHUA/QeDBBNTGTbZb7LtsSanjMRzSMYcaQl1QGRdZI0zpjBsWJHRwn/6snjrq6+vr42AkIiLxPJQfIgkbIEV2/d37al6wsLDkuEhJY2svc4kcSR5E5JQiBE6oc//f0tNJfqLrXUVVQ4meyzRFj38HPv3s8w/8B59uwxDBH1MdFNIfJ6uL9ZUvG65G7Gr1JHRICERK+uW46eDDyAYaQTJ7I2rL8QkeFyxEBPbaJ+RXQJpw6mAucCzFmc42ePHz9eery0tPTye/hc/hEGie4JEhF1IVGbcURAXt11CKSRLEkRgqomIlGESLhqVeNh8rI27uyykVjS661ENP02UZ2T6IImYqTSy6WXDRITPUOiri6VujZzjMRRrmG6UTxjVUNAgBDJEPGIIgDiw5SV/bV+ceyZcjSD6xgxEBJdalGK3I5okKcUDAnQj06ix13WOdJEVtcVk6Ti/xbfuEGCEOo34UGk6lecOh26gQcDShJ1HjDtNUifSx0ztfRL6owkdnTBILGk98R0z0gCIJLUx7G72eaI3aQED4jWwdH6DUBCqIDd4JHrkcgrGOsgPXBY4h7fuLPbiQQ842Tp9baWWFKFJjqrLL0vfY/DlojoZ5H02Ird/yk7n9eosiyOCzpDSZiZzcwoDs0g1DJ/RLkxxjhxI8aIELom4hCFsbUDSdEuglQSFCMWNERQjNYrZGK0OhjSplLOpmgXISpTCwMTJUWgGCoxsRYhuJzz69577nsvpr0VE5NVffie8z3nnXvrvVFPJBN0pNIIqjQ9MpKrnDuXP+dEmsmWPZUQh3USIEYyMu37n+d2LvCY6KHSyMXdhYtxiYRI/Zs27oYHOexmJeyeKmsQ/7aZRGE3wisHa1qJBCqVDRKr9OAnR0RMGHmffzQyMdLLl/GZ9DDW7IjojMokJNps20SiTbIGQhr2NHrqF6Sw2THR+sg0AsGachrNpAEom7WZ9IBV+nfBqMRIvzP1lpBeqhr73CXSM9++EeniDZNIvjls9pBEHHaGaNiPOp1GSGQrEiYSE+VAo2lCmp/PG41QJYeEeSTmcFyvlpYWafX2ffLtWxR6TkAPTYWNFKTYqEMeQzS7k9m1t4dKLEvESOtCNI9rjJlWZ7K40lyQeIFCBZLIqERO/nmfIPmNnfM6Y3Zx9h0m2uzvkagzZkfOYCrSPVeQ2Bhc2HVxQeIsIqRpQYImiDXKZsuEpMIOiQqeSIT0W4O0i9cxE/m3q0gXDBFXJKiw7Aymb5gVojiRTF/H1sBR10WJBEjTqNL8vFyZLyLUKgCteCoJkoo8kkm6or2fIp2dL9KvUglrLIukS5JtG7AgubbhqGtWPZVyOUICImCa4uvYMgkFKqVBpYwUpAcFDryISj9y5H2KdW9VkDz7thr5bUOP1zbMDg7vUJDavavYo557I9G6Czu5kAWaVUql1Z+sSBJ2hSgSe94fQ0i6V7Uaxfh3m0ICHkK6q1u7uO7bEZmCtGWYcusiEmnk5kEzHHbpXotUKBSO45evEpZbuWQ/FNJo1+5bVyTxOteret23JbIVSRH5BQmARCQkmldzyMlsGl9paYMKBRRJNEoJD/wsvSthbeJk+lmYqLUj9/5yQdJEbRJ0mgi8bjgadaOeNUiNtXGXQ7cTkeZlHIREkzQ/QaK0zSNcRJRiGn5JP87JdIi9LnI98WwHjZTZWWcQrxscvCvGoJwh1H4fPbolUdfljGGdiKYrzuvGZLI6ObmyAkAQdwYIjaEgLARDXylGkgbi0M/h/nvXa6QdkLTXhZBGVdvgdQ0Sd0hUq1Qq8/5gFddKOstIGUASlVIppw//gLgruSuM3z83K7b7/j7i3l6RDYedV5FUkeXAU0BWpHUKulqlhttIU04kISKZelmkBwbIEqVSrBar5EZ6v4m2DZ7ZWaawf/ebTPKv+rxrpNFw3+DCjpiIqFZDjSr5xZlFtoYxR9QEoowjCqnERClWST1u6+PHLySSfz0RLkhXlH3zBUWMfWtzIKItDyhniPLYrHpRhyvdS6kkRFadlHyn/5XA81rE8jifXr9+/dHG3DNtdhdDRGe8guSI7sYVJG3fEbPbYh4EwqCr5BFpcZGuzBlpxRCBSgVDVGASwRHBUmDiKYi8vQrp42uaFbv5lrXvuAvzNlOQrlyJK7GPIvZ9NnQZa3lGajVDRECwZsozZTE7irsmIFmJmAi+AlxOplSpVEqZZpwcgh+m+P7q+4WNZ4Jj/PuGH3Z+t2r9m+2b3O5fJNK9p9br9IQLNyhwrcNrZGStuFYzQWeZymVoGZBIVNIiARGtQJYieldKlT67bdx9rNLC+6sLCws/vNowKoXdTlekzRBRzNDunmqECGlLFuB0LU9MTBQFqaZEKgNTlqAIqMlxxyIFISLHBMl03EPag08lpWfAXTXPTHtx44a2B9V+94jbRQpS+KrPNatUYQ3P1pFlxEGiCULSIpVRJWhWgWlFRGqySjbwYpEw8ErvNNIhEmmBNHr1+BU+V+MxPuGgXr9gR0La8Xh2oseQgxZIDRpsw4BAcCm79ObN0NAEvogIFxMpkWh4gs13OmsyKcOpZAGCIMJUSkWQ0BwWNhZ+MM+uwq1LemoD7l5Wq231M24xVNumXeR4j+5Gymu7rLNn5wYGBoZ4TQwNWY2QyNj34mLeIwKmpthdL8VcUCjEEwWxKh2UJw8iEUtkn0JB+7F4e75EZ0eiM5Hgyz1LQ373aPARW52ZcD19cvse7fbhQS5aQ0PjQqSAkMlIlF8cY6CyAGWga8Cga2QyXiJFRUrGqbSXkHCD+R/mkTuoEGlE94zF/WW5C9fJ0x0nvPtP0KcU+RNjePb7n3QKlw4Pdo8z0NC4AJmoM0CVoou6sSmLRM03QGV6e5uZDCHh2w/w3Qc+EvwhiX9GlTx72HP4/YLbMn/8Xy0SHgPgG0Me6+g4JrfawWMNly65T5Leks/AGaRuOZimoITJijSBRPkiAWHMTbFKkkfp9B+gEwImINrmuCMeX6US0iSNTLouYTJh3G1I3Mkzd0Slzs7vSCcRCWQ6Qfc9OUV3ELp+8/otIDp//u01eBmRUKX78SrpsCsW80alsampy75KzdUMBJ7EXUBq8Ns3QEn4Tb6SKFLLZ31i6uDDBQKKiPQdZ9LfSKRj5lTD6VOXWKSbJuzeikYMdF9EkuU0MplUBKhaMZ8vchsERLgAhzKJoo7iDkTa3qawK1CI0dtPJQEnEHn4R4kDzzun8vDZxquNF3JQgx5R0ycaubt+cyYhEGQSQgHQzfM3z6NKIBGdSrMaEZEvkgECpDWWqCjOsDhG10gcdojUm0WkDBJh3IFIyWTKvggLCAP6L60S6vTnENIdIXrM7t3Hh0+QCLyh45g9eXJCrAET6aZ1hrfXnEbEc99EnRd0Q64gcRadozxiosuSSECUxhzKoDmASCrGEIRx+Hf0DPwLapSMIsGSiuSefcJ5JLcqPtlx+iTfdBCALl2/JFF36xqG3TVjDd2k0Xgc0ZA1BpKoiEB50Yi6b6NRL8VdBogaIBIEHSoSWKhApFE/KZe8Y1J7EQk6oDsvpMb26ccBkNWZPDol9v13Fgk/pvjWMztt3+NhY6AuCDUqUtDl/wNAY948CIkoiRCpsb29DW4nwRbwP4k5QeS4i3j4nj2C9P0N8xAhiTtUSe7rKyJZldC/b5FKEnemIt13TEOKidaaiFThRFqks3Zy1YcqpY1KHHeNTAOICMOmTZAM/RcAGck/InrYXcgilIm7Pu++vigT322HKpJkki1JWqSdEsmKxNaQVzMuTyXUCBbIFASBfeuOJPDZKO5CB3kPuUtzbFPrfSISxZ24g7vr4HV3bxrr36YgdWsDt/Yd6oPy+Kp4UzsgWmFvMEiN3kaDkUgJ+90Ti/8UTSUoTHfCs5N6Xd1pnm+RbTOJKpKzu2+/vSZu121E8ho7Z99rxu0qtWmZfavpCc3s0iaRms0Gxp0WQ2vkARJS6Lzh3jtxBzXaqlUbdifVLfrkHiH0CWbrDU6k8RCTuZ5Yk+Z72szzIzM7IeK4azRRJPvmAy/gAo+vFK5KlEyWiC6O4GrigplB4rG0Dtc1UEEyvaoH5Pd1LuaIZ3ltba1G28s5NypWJ+0o7qzZERKssEQRhxCR4Cty0vWgv+VC1+X10KABTz3t57s8qe7bMnXbj1EYojn8eCx+kvSI3UWSDWbeoRgLi9Sb7lVx1ySRVKCRUkEol1ikZEv0SPxhN+LCYw11udirtvEMsqc/Ed6g+DD8YRZvH6RPd44OnJ2DV/vS0hL+O7LknQLI5RyTiTs74iIkRYRI0UwKlVj+KsEvMTdu3CdEF0NDu542fTxID0/o9Mms2utTc0gCChMR07RWyc3zOZNs3DWbrZhKgcsiK1GgLcK6QyruLPyByPC7KiIZooSbNAz7AyE1h8QjuG8IaCm8jcQS2U1z4w1q9u28oRWhGpEQiy1QiBR/d80DanBSb9PH0szwG67L9wPTfo/oiZnaDQASAs21CxExLattJAk6tY9k8oh2XSTstjOZVkBqbbQ2tneIOr9IoYPv8BmMA26ab9NIT/OvXPGODs7+gkAYdLf9OeTSkhFp2R1scGnkiC57GxTW7DJNQSKmIBmXUEq6mJqkbI83Y+tq9l11m0iyPzEsU0j/pN0ARx1qpPJITjyNRIim5h0RzlXF6zDstjMN4IHVYCjdJqjUUi1RjIErnep2WoeJZOzbOzpoNHIiyRhyQER60x4i6oogeRVphZ3BqYREBIVM+B3a8WDnyrRTIlkmGtnV1ey7X29R7GeVPrjtyyeIdNsebJhbameiJYi6I13LXtyZE0IhpGxaVyQIu9YVC9QwXPATmoltvNyg1cAXrtbGN1++8+7hvmpVwk6JhESqItm4Y5Fuj4pIczaTwgXJqjQfbhu4V1V9Q7P16xYQ/eXLn3k8UO3rrFarMvvu10S+ff/idsZURdIl9ohvdjl3CsDsXdI8SBFtK412IzE/diUCJnzGWBWwiKiqpvn7vYLERGx2A741KLML2bfaYJ4s23GQ7u2+TqHWv/5pdyLoIw50JjoTHfBK4MA4oeybGyHSyE7Ab+v9WOffSqNciGhMDb/tlTmLBBpNfg3TN7+KiIRKEFVHArpvaFXVZqzbc3Fmd1bySJoG0siZ3f+rO2MUhGEoDBd0MAcQKyI9i5ewuIp71y4ORdDRtZu9RmdX8QLyoKs9gLPvf0lsIigWpOJrL/DxJ2leXt8fd193dOoTzXmQleh2uLbSaMpj7jMg+UKJSnM81m1ebbaKSBa7Zh+09/4e9HZ2s7iO4yqudrvKKTB7NZelIxKYri1xWl4KFo7BxBrpfjFOKAg5xVobKSa8AU+e3dIaS6TicingTlPzW+nQhbF3IkVfvQL6xZwamB44SKSQyhI8+ohglpYASVrn97A3yNM0L1NkSNk5Y6YzMwHIInnl2JN7+G2IoknQSbBULJDw0IaYiIHEog8mIabHnIFyJsrKEq8VSSyEak8jtxz7WL2XmmfYC7qL3mjMQEofCIlDH4lELNICJTFxoBCDA0liWaPCDDwAGSaHyAKZ+sQKPP2g8+iHI0Xi0CdjTuZRYjRqOn4fU+lZI3dl8FbvKBpOfoDzV3EHkd9/KKbWtFYAAAAASUVORK5CYII=',
        abilities:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe59e"/><stop offset="1" stop-color="%23ffc75b"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M68 18 40 70h18l-6 38 38-58H74l6-32z" fill="%23fff7d6" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/></svg>',
        seeds:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23d3f8c6"/><stop offset="1" stop-color="%239be4a3"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><ellipse cx="64" cy="76" rx="20" ry="16" fill="%23a36b3a" stroke="%236b4b2a" stroke-width="6"/><path d="M64 60c0-12 10-22 22-22-3 12-11 20-22 22zM64 60c0-12-10-22-22-22 3 12 11 20 22 22z" fill="%239cd67f" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/></svg>',
        values:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe59e"/><stop offset="1" stop-color="%23ffd24d"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="64" r="30" fill="%23ffd86a" stroke="%236b4b2a" stroke-width="6"/><path d="M64 44v40M52 54h24M52 74h24" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/></svg>',
        timers:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23cde9ff"/><stop offset="1" stop-color="%2387d0ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="72" r="34" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><path d="M64 72V52M64 72l18 12" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/><rect x="50" y="18" width="28" height="12" rx="6" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/></svg>',
        rooms:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe1f0"/><stop offset="1" stop-color="%23ffb6d9"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M28 70l36-26 36 26v30H28z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><rect x="54" y="74" width="20" height="26" rx="4" fill="%23ffd24d" stroke="%236b4b2a" stroke-width="6"/></svg>',
        shop: 'https://cdn.discordapp.com/emojis/1423011042744729700.webp',
        tools:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e5e1ff"/><stop offset="1" stop-color="%23c7c2ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M46 86l36-36-8-8-36 36-2 14 10-6z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><rect x="68" y="34" width="14" height="14" rx="3" fill="%23ffd24d" stroke="%236b4b2a" stroke-width="6"/></svg>',
        settings:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23dff3ff"/><stop offset="1" stop-color="%23bfe6ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="64" r="20" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><path d="M64 30v12M64 86v12M30 64h12M86 64h12M42 42l8 8M78 78l8 8M86 42l-8 8M50 78l-8 8" stroke="%236b4b2a" stroke-width="6" stroke-linecap="round"/></svg>',
        hotkeys:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23fff2c4"/><stop offset="1" stop-color="%23ffd889"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><rect x="30" y="44" width="68" height="40" rx="10" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><text x="64" y="70" font-family="Arial,Helvetica,sans-serif" font-size="28" text-anchor="middle" fill="%236b4b2a">F</text></svg>',
        protect:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e2ffe7"/><stop offset="1" stop-color="%23b7f5c3"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M64 26l32 10v22c0 24-16 36-32 44-16-8-32-20-32-44V36z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><path d="M46 62l12 12 24-24" fill="none" stroke="%2394d36b" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/></svg>',
        notifications:
          'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e3f0ff"/><stop offset="1" stop-color="%23c7dbff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M40 82h48l-6-10V58a18 18 0 10-36 0v14z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><circle cx="84" cy="44" r="10" fill="%23ff6464" stroke="%236b4b2a" stroke-width="6"/></svg>',
        help: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23f1e7ff"/><stop offset="1" stop-color="%23d9ccff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="88" r="6" fill="%236b4b2a"/><path d="M48 54a16 16 0 1132 0c0 10-8 10-10 16" fill="none" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/></svg>'
      };

      // Tooltip text with hotkey info
      const tooltipText = {
        pets: 'Pets ‚Ä¢ Alt+P ‚Ä¢ Shift+Click for widget',
        abilities: 'Abilities ‚Ä¢ Alt+A ‚Ä¢ Shift+Click for widget',
        seeds: 'Seeds ‚Ä¢ Alt+S ‚Ä¢ Shift+Click for widget',
        values: 'Values ‚Ä¢ Alt+V ‚Ä¢ Shift+Click for widget',
        timers: 'Timers ‚Ä¢ Shift+Click for widget',
        rooms: 'Rooms ‚Ä¢ Shift+Click for widget',
        shop: 'Shop ‚Ä¢ Alt+B',
        tools: 'Tools',
        settings: 'Settings ‚Ä¢ Alt+G',
        hotkeys: 'Hotkeys',
        protect: 'Crop Protection ‚Ä¢ Lock/unlock crops',
        notifications: 'Notifications',
        help: 'Help'
      };

      // Create primary dock items
      primaryTabs.forEach(tabName => {
        const item = targetDocument.createElement('div');
        item.className = 'mgh-dock-item';
        item.dataset.tab = tabName;

        const img = document.createElement('img');
        img.src = icons[tabName];
        // FIX: Match scriptwithicons sizing exactly
        img.style.height = '70%';

        // Add fallback for failed icon loads (especially shop icon)
        img.onerror = () => {
          img.style.display = 'none';
          const fallbackEmoji = targetDocument.createElement('span');
          const emojiMap = {
            pets: 'üêæ',
            abilities: '‚ö°',
            seeds: 'üå±',
            values: 'üíé',
            timers: '‚è±Ô∏è',
            rooms: 'üè†',
            shop: 'üõí',
            tools: 'üîß',
            settings: '‚öôÔ∏è',
            hotkeys: '‚å®Ô∏è',
            protect: 'üîí',
            notifications: 'üîî',
            help: '‚ùì'
          };
          fallbackEmoji.textContent = emojiMap[tabName] || 'üìã';
          fallbackEmoji.style.fontSize = '24px';
          item.insertBefore(fallbackEmoji, item.firstChild);
        };

        item.appendChild(img);

        const tooltip = targetDocument.createElement('div');
        tooltip.className = 'mgh-tooltip';
        tooltip.innerHTML = tooltipText[tabName] || tabName.charAt(0).toUpperCase() + tabName.slice(1);

        item.appendChild(tooltip);

        item.addEventListener('click', e => {
          if (e.shiftKey) {
            openPopoutWidget(tabName);
          } else {
            // Special handling for shop - open slide-out windows instead of sidebar
            if (tabName === 'shop') {
              toggleShopWindows();
            } else {
              openSidebarTab(tabName);
            }
          }
        });

        dock.appendChild(item);
      });

      // Create tail group container
      const tailGroup = targetDocument.createElement('div');
      tailGroup.className = 'mgh-tail-group';
      tailGroup.style.display = 'none';

      tailTabs.forEach(tabName => {
        const item = targetDocument.createElement('div');
        item.className = 'mgh-dock-item';
        item.dataset.tab = tabName;

        const img = document.createElement('img');
        img.src = icons[tabName];
        // FIX: Match scriptwithicons sizing exactly
        img.style.height = '70%';

        // Add fallback for failed icon loads (especially shop icon)
        img.onerror = () => {
          img.style.display = 'none';
          const fallbackEmoji = targetDocument.createElement('span');
          const emojiMap = {
            pets: 'üêæ',
            abilities: '‚ö°',
            seeds: 'üå±',
            values: 'üíé',
            timers: '‚è±Ô∏è',
            rooms: 'üè†',
            shop: 'üõí',
            tools: 'üîß',
            settings: '‚öôÔ∏è',
            hotkeys: '‚å®Ô∏è',
            protect: 'üîí',
            notifications: 'üîî',
            help: '‚ùì'
          };
          fallbackEmoji.textContent = emojiMap[tabName] || 'üìã';
          fallbackEmoji.style.fontSize = '24px';
          item.insertBefore(fallbackEmoji, item.firstChild);
        };

        item.appendChild(img);

        const tooltip = targetDocument.createElement('div');
        tooltip.className = 'mgh-tooltip';
        tooltip.innerHTML = tooltipText[tabName] || tabName.charAt(0).toUpperCase() + tabName.slice(1);

        item.appendChild(tooltip);

        item.addEventListener('click', e => {
          if (e.shiftKey) {
            openPopoutWidget(tabName);
          } else {
            openSidebarTab(tabName);
          }
        });

        tailGroup.appendChild(item);
      });

      // Version indicator (added to tail group)
      const versionIndicator = targetDocument.createElement('div');
      versionIndicator.className = 'mgh-dock-item version-indicator';
      versionIndicator.innerHTML = '‚óè';
      versionIndicator.style.fontSize = '12px';
      versionIndicator.style.color = IS_LIVE_BETA ? '#ff9500' : '#00ff00'; // Orange for beta, green for stable
      versionIndicator.style.cursor = 'pointer';
      versionIndicator.title = `v${CURRENT_VERSION} (${IS_LIVE_BETA ? 'BETA' : 'STABLE'}) - Checking for updates... (click to refresh)`;

      // Click to manually refresh version check
      versionIndicator.addEventListener('click', e => {
        e.stopPropagation();
        versionIndicator.style.color = '#888';
        versionIndicator.title = `v${CURRENT_VERSION} - Checking for updates...`;
        checkVersion(versionIndicator);
      });

      tailGroup.appendChild(versionIndicator);

      // Tail trigger
      const tailTrigger = targetDocument.createElement('div');
      tailTrigger.className = 'mgh-dock-item tail-trigger';
      tailTrigger.innerHTML = '‚ãØ';
      tailTrigger.addEventListener('mouseenter', () => (tailGroup.style.display = 'flex'));

      // Close tail group when mouse leaves the dock entirely
      dock.addEventListener('mouseleave', () => {
        tailGroup.style.display = 'none';
      });

      // Orientation toggle
      const flipToggle = targetDocument.createElement('div');
      flipToggle.className = 'mgh-dock-item flip-toggle';
      flipToggle.innerHTML = '‚Üî';
      flipToggle.title = 'Toggle orientation';
      flipToggle.addEventListener('click', e => {
        e.stopPropagation();
        if (dock.classList.contains('horizontal')) {
          dock.classList.remove('horizontal');
          dock.classList.add('vertical');
          // In vertical mode: flip toggle at top, then tabs, tail trigger at bottom
          dock.insertBefore(flipToggle, dock.firstChild);
          saveDockOrientation('vertical');
        } else {
          dock.classList.remove('vertical');
          dock.classList.add('horizontal');
          // In horizontal mode: tabs first, tail trigger, then flip toggle at end
          dock.appendChild(flipToggle);
          saveDockOrientation('horizontal');
        }
      });

      // Add in horizontal order: tabs -> tailTrigger -> tailGroup -> flipToggle
      dock.appendChild(tailTrigger);
      dock.appendChild(tailGroup);
      dock.appendChild(flipToggle);

      // Check version after UI is created
      checkVersion(versionIndicator);

      // Make entire dock draggable (except when clicking icons)
      makeDockDraggable(dock);

      // Create sidebar
      const sidebar = targetDocument.createElement('div');
      sidebar.id = 'mgh-sidebar';

      const sidebarHeader = targetDocument.createElement('div');
      sidebarHeader.className = 'mgh-sidebar-header';

      const sidebarTitle = targetDocument.createElement('div');
      sidebarTitle.className = 'mgh-sidebar-title';
      sidebarTitle.textContent = 'MGTools';

      const sidebarClose = targetDocument.createElement('div');
      sidebarClose.className = 'mgh-sidebar-close';
      sidebarClose.innerHTML = '√ó';
      sidebarClose.addEventListener('click', () => {
        sidebar.classList.remove('open');
        targetDocument.querySelectorAll('.mgh-dock-item').forEach(item => {
          item.classList.remove('active');
        });
      });

      sidebarHeader.appendChild(sidebarTitle);
      sidebarHeader.appendChild(sidebarClose);

      const sidebarBody = targetDocument.createElement('div');
      sidebarBody.className = 'mgh-sidebar-body';

      sidebar.appendChild(sidebarHeader);
      sidebar.appendChild(sidebarBody);

      // Append to DOM
      targetDocument.body.appendChild(dock);
      targetDocument.body.appendChild(sidebar);

      // Discord Fix: Add MutationObserver to detect when React purges UI
      if (isDiscordEnv) {
        let uiRemovalCount = 0;
        const maxReinjections = 10; // Prevent infinite loops

        const observer = new MutationObserver(mutations => {
          const dockMissing = !targetDocument.body.contains(dock);
          const sidebarMissing = !targetDocument.body.contains(sidebar);

          if ((dockMissing || sidebarMissing) && uiRemovalCount < maxReinjections) {
            uiRemovalCount++;
            productionLog(`üîÑ [DISCORD] UI purged by React (${uiRemovalCount}/${maxReinjections}), re-injecting...`);

            // Re-inject missing elements
            if (dockMissing && dock.parentNode !== targetDocument.body) {
              targetDocument.body.appendChild(dock);
            }
            if (sidebarMissing && sidebar.parentNode !== targetDocument.body) {
              targetDocument.body.appendChild(sidebar);
            }
          }
        });

        // Watch for removals in body
        observer.observe(targetDocument.body, {
          childList: true,
          subtree: false
        });

        productionLog('‚úÖ [DISCORD] MutationObserver active for UI persistence');
      }

      // Restore saved orientation
      const savedOrientation = loadDockOrientation();
      if (savedOrientation === 'vertical') {
        dock.classList.remove('horizontal');
        dock.classList.add('vertical');
        dock.insertBefore(flipToggle, dock.firstChild);
      }

      // Restore saved position
      const savedPosition = loadDockPosition();
      if (savedPosition) {
        dock.style.left = savedPosition.left + 'px';
        dock.style.top = savedPosition.top + 'px';
        dock.style.transform = 'none';
        dock.style.bottom = 'auto';
        dock.style.right = 'auto';
      }

      // Store references
      UnifiedState.panels.dock = dock;
      UnifiedState.panels.sidebar = sidebar;
      UnifiedState.panels.sidebarBody = sidebarBody;

      // Apply theme to dock and sidebar immediately after creation
      setTimeout(() => {
        const currentTheme = generateThemeStyles();
        const isBlackTheme = currentTheme.gradientStyle && currentTheme.gradientStyle.startsWith('black-');
        if (isBlackTheme && currentTheme.accentColor) {
          applyAccentToDock(currentTheme);
          applyAccentToSidebar(currentTheme);
        } else {
          // Apply gradient theme for non-black themes
          applyThemeToDock(currentTheme);
          applyThemeToSidebar(currentTheme);
        }
      }, 100);

      productionLog('‚úÖ Hybrid Dock UI created successfully');
    }

    /**
     * TEST VERSION: Enhanced UI Health Check with Retry Logic
     * Ensures UI is visible and accessible, retries if needed
     * Helps fix issues where UI doesn't show in Tampermonkey/Chrome
     */
    function ensureUIHealthy() {
      const maxRetries = 5;
      let retryCount = 0;

      function checkAndRetry() {
        const dock = targetDocument.getElementById('mgh-dock');
        const sidebar = targetDocument.getElementById('mgh-sidebar');

        // Check both existence AND visibility (critical fix for hidden UI bug)
        const dockHidden = dock && (dock.style.display === 'none' || window.getComputedStyle(dock).display === 'none');
        const sidebarHidden =
          sidebar && (sidebar.style.display === 'none' || window.getComputedStyle(sidebar).display === 'none');

        if (!dock || !sidebar || dockHidden || sidebarHidden) {
          // Log the specific issue
          if (!dock) console.warn('[MGTools] Dock element missing');
          if (!sidebar) console.warn('[MGTools] Sidebar element missing');
          if (dockHidden) console.warn('[MGTools] Dock is hidden (display:none)');
          if (sidebarHidden) console.warn('[MGTools] Sidebar is hidden (display:none)');

          // Clear potentially corrupted localStorage state
          if (dockHidden || sidebarHidden) {
            console.warn('[MGTools] Clearing corrupted visibility state...');
            localStorage.removeItem('mgh_toolbar_visible');
          }
          retryCount++;
          if (retryCount < maxRetries) {
            const delay = Math.min(1000 * Math.pow(2, retryCount - 1), 5000); // 1s, 2s, 4s, 5s, 5s

            setTimeout(() => {
              // Retry creating UI
              try {
                cleanupCorruptedDockPosition();
                createUnifiedUI();
                checkAndRetry(); // Check again after creation
              } catch (error) {
                console.error('[MGTools TEST] UI recreation failed:', error);
              }
            }, delay);
          } else {
            console.error('[MGTools TEST] UI failed to load. Please report this issue.');

            // Emergency notification
            try {
              const msg = targetDocument.createElement('div');
              msg.style.cssText =
                'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#ff4444;color:white;padding:20px;border-radius:10px;z-index:999999;font-family:Arial,sans-serif;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.5);';
              msg.innerHTML =
                '<strong>‚ö†Ô∏è MGTools UI Failed to Load</strong><br><br>Please reload the page (F5)<br>or check browser console for details.<br><br><small>Test Version 3.8.9-TEST</small>';
              targetDocument.body.appendChild(msg);

              setTimeout(() => {
                if (msg.parentNode) msg.parentNode.removeChild(msg);
              }, 10000);
            } catch (e) {
              console.error('[MGTools TEST] Emergency notification failed:', e);
            }
          }
        } else {
          // UI confirmed healthy, no need for verbose logging

          // Show success toast
          setTimeout(() => {
            try {
              // eslint-disable-next-line no-undef
              showToast('‚úÖ MGTools TEST Loaded', 'UI Health Check Passed', 3000);
            } catch (e) {
              // Toast might not be ready yet, that's okay
            }
          }, 1000);
        }
      }

      // Initial check after a short delay to let DOM settle
      setTimeout(checkAndRetry, 500);
    }

    /**
     * TEST VERSION: Alt+M Toolbar Toggle
     * Press Alt+M to show/hide the entire MGTools toolbar
     * State is saved and restored across page reloads
     */
    function setupToolbarToggle() {
      // Prevent multiple installations
      if (window.__toolbarToggleInstalled) {
        return;
      }
      window.__toolbarToggleInstalled = true;

      // Version-based state reset to fix UI disappearance after updates
      const STORAGE_KEY = 'mgh_toolbar_visible';
      const VERSION_KEY = 'mgh_ui_version';
      const CURRENT_VERSION = typeof GM_info !== 'undefined' ? GM_info.script.version : '1.1.1';

      const savedVersion = localStorage.getItem(VERSION_KEY);
      if (savedVersion !== CURRENT_VERSION) {
        // New version detected - reset UI visibility to prevent hidden state from carrying over
        productionLog(`üì¶ [UI-VERSION] Version change detected: ${savedVersion} ‚Üí ${CURRENT_VERSION}`);
        productionLog('üì¶ [UI-VERSION] Resetting UI visibility state to default (visible)');
        localStorage.removeItem(STORAGE_KEY);
        localStorage.setItem(VERSION_KEY, CURRENT_VERSION);
      }

      // Load saved visibility state (defaults to true if not set)
      let toolbarVisible = localStorage.getItem(STORAGE_KEY) !== 'false'; // default true

      // Apply initial state
      function applyVisibility(visible, showNotification = false) {
        const dock = targetDocument.getElementById('mgh-dock');
        const sidebar = targetDocument.getElementById('mgh-sidebar');

        if (dock) {
          dock.style.display = visible ? '' : 'none';
        }
        if (sidebar) {
          sidebar.style.display = visible ? '' : 'none';
        }

        // Save state
        localStorage.setItem(STORAGE_KEY, visible.toString());

        if (showNotification) {
          try {
            // eslint-disable-next-line no-undef
            showToast(visible ? 'üé® Toolbar Shown' : 'üëª Toolbar Hidden', 'Alt+M to toggle', 2000);
          } catch (e) {
            // Toast not ready, silent fail
          }
        }
      }

      // Apply saved state on load
      setTimeout(() => applyVisibility(toolbarVisible, false), 100);

      // Enhanced Alt+M listener with better reliability
      // Listen on BOTH document and targetDocument to catch all scenarios
      const toggleHandler = e => {
        // Check for Alt+M (case insensitive)
        if (e.altKey && (e.key === 'm' || e.key === 'M')) {
          e.preventDefault();
          e.stopPropagation();
          toolbarVisible = !toolbarVisible;
          applyVisibility(toolbarVisible, true);
          console.log(`[MGTools] Alt+M: Toolbar ${toolbarVisible ? 'shown' : 'hidden'}`);
        }
      };

      // Add listener to both document contexts for maximum reliability
      document.addEventListener('keydown', toggleHandler, { passive: false, capture: true });
      if (targetDocument !== document) {
        targetDocument.addEventListener('keydown', toggleHandler, { passive: false, capture: true });
      }
    }

    /**
     * Dock Size Control
     * Press Alt+= to increase dock size, Alt+- to decrease
     * Cycles through: Tiny ‚Üí Small ‚Üí Medium ‚Üí Large
     */
    function setupDockSizeControl() {
      // Prevent multiple installations
      if (window.__dockSizeControlInstalled) {
        return;
      }
      window.__dockSizeControlInstalled = true;

      const STORAGE_KEY = 'mgh_dock_size';
      const SIZES = ['micro', 'mini', 'tiny', 'small', 'medium', 'large'];
      const SIZE_LABELS = {
        micro: 'Micro',
        mini: 'Mini',
        tiny: 'Tiny',
        small: 'Small',
        medium: 'Medium',
        large: 'Large'
      };

      // Load saved size (defaults to medium)
      let currentSize = localStorage.getItem(STORAGE_KEY) || 'medium';
      if (!SIZES.includes(currentSize)) {
        currentSize = 'medium';
      }

      // Apply size to dock
      function applyDockSize(size, showNotification = false) {
        const dock = targetDocument.getElementById('mgh-dock');
        if (!dock) return;

        // Remove all size classes
        SIZES.forEach(s => dock.classList.remove(`dock-size-${s}`));

        // Add new size class (except for medium which is default)
        if (size !== 'medium') {
          dock.classList.add(`dock-size-${size}`);
        }

        // Save state
        localStorage.setItem(STORAGE_KEY, size);
        currentSize = size;

        if (showNotification) {
          try {
            // eslint-disable-next-line no-undef
            showToast(`üìè Dock Size: ${SIZE_LABELS[size]}`, 'Alt+= / Alt+- to adjust', 2000);
          } catch (e) {
            // Toast not ready, silent fail
          }
        }
      }

      // Apply saved size on load
      setTimeout(() => applyDockSize(currentSize, false), 150);

      // Hotkey handler for dock size and position
      const sizeHandler = e => {
        // Alt+= to increase size
        if (e.altKey && (e.key === '=' || e.key === '+')) {
          e.preventDefault();
          e.stopPropagation();
          const currentIndex = SIZES.indexOf(currentSize);
          const nextIndex = (currentIndex + 1) % SIZES.length;
          applyDockSize(SIZES[nextIndex], true);
          console.log(`[MGTools] Alt+=: Dock size ‚Üí ${SIZE_LABELS[SIZES[nextIndex]]}`);
        } else if (e.altKey && (e.key === '-' || e.key === '_')) {
          // Alt+- to decrease size
          e.preventDefault();
          e.stopPropagation();
          const currentIndex = SIZES.indexOf(currentSize);
          const prevIndex = (currentIndex - 1 + SIZES.length) % SIZES.length;
          applyDockSize(SIZES[prevIndex], true);
          console.log(`[MGTools] Alt+-: Dock size ‚Üí ${SIZE_LABELS[SIZES[prevIndex]]}`);
        } else if (e.altKey && (e.key === 'x' || e.key === 'X')) {
          // Alt+X to reset dock position
          e.preventDefault();
          e.stopPropagation();
          resetDockPosition();
          console.log(`[MGTools] Alt+X: Dock position reset to default`);
        }
      };

      // Add listener to both document contexts
      document.addEventListener('keydown', sizeHandler, { passive: false, capture: true });
      if (targetDocument !== document) {
        targetDocument.addEventListener('keydown', sizeHandler, { passive: false, capture: true });
      }
    }

    function saveDockPosition(position) {
      try {
        // v3.8.7 - Always stringify for storage consistency
        const serialized = JSON.stringify(position);
        localStorage.setItem('mgh_dock_position', serialized);

        // v3.8.7 - Concise breadcrumb log
        console.log(`[DOCK-SAVE] left=${position.left}, top=${position.top}, typeof=string (len=${serialized.length})`);
      } catch (e) {
        console.warn('[DOCK-SAVE] Exception during save:', e);
      }
    }

    function resetDockPosition() {
      try {
        const dock = targetDocument.getElementById('mgh-dock');
        if (!dock) {
          console.warn('[DOCK-RESET] Dock element not found');
          return;
        }

        // Clear saved position
        localStorage.removeItem('mgh_dock_position');
        console.log('[DOCK-RESET] Cleared saved position');

        // Calculate default position (right side of screen)
        const dockWidth = dock.offsetWidth || 380;
        const defaultLeft = window.innerWidth - dockWidth - 20;
        const defaultTop = 100;

        // Apply default position
        dock.style.left = `${defaultLeft}px`;
        dock.style.top = `${defaultTop}px`;
        dock.style.transform = 'none';
        dock.style.bottom = 'auto';
        dock.style.right = 'auto';

        console.log(`[DOCK-RESET] Reset to default position: left=${defaultLeft}, top=${defaultTop}`);

        // Show toast notification
        try {
          showNotificationToast('üè† Dock Reset - Position reset to default', 'success');
        } catch (e) {
          // Toast not ready, silent fail
          console.log('[DOCK-RESET] Toast notification unavailable');
        }
      } catch (e) {
        console.warn('[DOCK-RESET] Exception during reset:', e);
      }
    }

    // One-time cleanup to detect and clear corrupted dock position data
    function cleanupCorruptedDockPosition() {
      try {
        const saved = localStorage.getItem('mgh_dock_position');
        if (!saved) return;

        // v3.8.7 fix: Accept valid objects (storage layer may auto-parse JSON)
        if (typeof saved === 'object' && saved !== null) {
          // If it has valid shape {left, top}, keep it
          if (typeof saved.left === 'number' && typeof saved.top === 'number') {
            console.log('[DOCK-CLEANUP] Found valid object position, keeping it');
            return; // Valid object, no cleanup needed
          } else {
            console.log('[DOCK-CLEANUP] Detected invalid object shape, clearing');
            localStorage.removeItem('mgh_dock_position');
            return;
          }
        }

        // Check for corrupted string data
        if (typeof saved === 'string' && (saved === '[object Object]' || saved.startsWith('[object'))) {
          console.log('[DOCK-CLEANUP] Detected corrupted position data, clearing');
          localStorage.removeItem('mgh_dock_position');
          return;
        }

        // Try to parse to ensure it's valid JSON
        try {
          JSON.parse(saved);
          console.log('[DOCK-CLEANUP] Position data is valid');
        } catch (parseError) {
          console.log('[DOCK-CLEANUP] Invalid JSON in position data, clearing');
          localStorage.removeItem('mgh_dock_position');
        }
      } catch (e) {
        console.warn('[DOCK-CLEANUP] Error during cleanup:', e);
        localStorage.removeItem('mgh_dock_position');
      }
    }

    function loadDockPosition() {
      try {
        const saved = localStorage.getItem('mgh_dock_position');
        if (!saved) return null;

        // v3.8.7 fix: Accept object directly if storage layer auto-parsed JSON
        if (typeof saved === 'object' && saved !== null) {
          // Validate it has the expected shape {left, top}
          if (typeof saved.left === 'number' && typeof saved.top === 'number') {
            console.log(`[DOCK-LOAD] parsed {left: ${saved.left}, top: ${saved.top}} source=object`);
            return saved;
          } else {
            console.log('[DOCK] Invalid object shape, clearing');
            localStorage.removeItem('mgh_dock_position');
            return null;
          }
        }

        // Handle string (original path)
        if (typeof saved === 'string') {
          // Detect corrupted data (happens if someone saved without stringify)
          if (saved === '[object Object]' || saved.startsWith('[object')) {
            console.log('[DOCK] Clearing corrupted position data');
            localStorage.removeItem('mgh_dock_position');
            return null;
          }

          const parsed = JSON.parse(saved);
          console.log(`[DOCK-LOAD] parsed {left: ${parsed.left}, top: ${parsed.top}} source=string`);
          return parsed;
        }

        // Unknown type
        console.log('[DOCK] Unknown saved type:', typeof saved);
        localStorage.removeItem('mgh_dock_position');
        return null;
      } catch (e) {
        console.warn('[DOCK] Failed to load position, clearing:', e);
        localStorage.removeItem('mgh_dock_position');
        return null;
      }
    }

    function saveDockOrientation(orientation) {
      try {
        localStorage.setItem('mgh_dock_orientation', orientation);
      } catch (e) {
        console.warn('[DOCK] Failed to save orientation:', e);
      }
    }

    function loadDockOrientation() {
      try {
        return localStorage.getItem('mgh_dock_orientation') || 'horizontal';
      } catch (e) {
        console.warn('[DOCK] Failed to load orientation:', e);
        return 'horizontal';
      }
    }

    function makeDockDraggable(dock) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      // Show grab cursor on edges (mouse only)
      dock.addEventListener('mousemove', e => {
        if (isDragging) return;

        // Don't show grab cursor on dock items
        if (e.target.classList.contains('mgh-dock-item') || e.target.closest('.mgh-dock-item')) {
          dock.style.cursor = '';
          return;
        }

        const rect = dock.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const edgeThreshold = 12;

        // Check if near edges
        const nearEdge =
          x < edgeThreshold || x > rect.width - edgeThreshold || y < edgeThreshold || y > rect.height - edgeThreshold;

        dock.style.cursor = nearEdge ? 'grab' : '';
      });

      // Shared drag start logic
      const startDrag = (clientX, clientY, event) => {
        // Don't start drag if clicking/touching on a dock item
        if (event.target.classList.contains('mgh-dock-item') || event.target.closest('.mgh-dock-item')) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        isDragging = true;
        startX = clientX;
        startY = clientY;
        const rect = dock.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;
        dock.style.cursor = 'grabbing';

        // Disable transitions during drag to prevent blinking
        dock.style.transition = 'none';
        dock.querySelectorAll('*').forEach(child => {
          child.style.transition = 'none';
          child.style.pointerEvents = 'none';
        });
      };

      // Shared drag move logic
      const handleDragMove = (clientX, clientY, event) => {
        if (!isDragging) return;
        event.preventDefault();
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        dock.style.left = startLeft + deltaX + 'px';
        dock.style.top = startTop + deltaY + 'px';
        dock.style.transform = 'none';
        dock.style.bottom = 'auto';
        dock.style.right = 'auto';
      };

      // Shared drag end logic
      const endDrag = () => {
        if (isDragging) {
          isDragging = false;
          dock.style.cursor = '';

          // Re-enable transitions after drag
          dock.style.transition = '';
          dock.querySelectorAll('*').forEach(child => {
            child.style.transition = '';
            child.style.pointerEvents = '';
          });

          // Save dock position to localStorage
          const rect = dock.getBoundingClientRect();
          saveDockPosition({
            left: rect.left,
            top: rect.top
          });
        }
      };

      // Mouse event handlers
      dock.addEventListener('mousedown', e => {
        startDrag(e.clientX, e.clientY, e);
      });

      targetDocument.addEventListener('mousemove', e => {
        handleDragMove(e.clientX, e.clientY, e);
      });

      targetDocument.addEventListener('mouseup', () => {
        endDrag();
      });

      // Touch event handlers
      dock.addEventListener(
        'touchstart',
        e => {
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            startDrag(touch.clientX, touch.clientY, e);
          }
        },
        { passive: false }
      );

      targetDocument.addEventListener(
        'touchmove',
        e => {
          if (isDragging && e.touches.length === 1) {
            const touch = e.touches[0];
            handleDragMove(touch.clientX, touch.clientY, e);
          }
        },
        { passive: false }
      );

      targetDocument.addEventListener('touchend', () => {
        endDrag();
      });

      targetDocument.addEventListener('touchcancel', () => {
        endDrag();
      });
    }

    function openSidebarTab(tabName) {
      const sidebar = UnifiedState.panels.sidebar;
      const sidebarBody = UnifiedState.panels.sidebarBody;

      // Check if clicking the same tab that's already open
      const isAlreadyOpen = sidebar.classList.contains('open') && UnifiedState.activeTab === tabName;

      if (isAlreadyOpen) {
        // Close sidebar
        sidebar.classList.remove('open');
        targetDocument.querySelectorAll('.mgh-dock-item').forEach(item => {
          item.classList.remove('active');
        });
        return;
      }

      // Update title
      sidebar.querySelector('.mgh-sidebar-title').textContent = tabName.charAt(0).toUpperCase() + tabName.slice(1);

      // Update UnifiedState FIRST (required for updateTabContent)
      UnifiedState.activeTab = tabName;

      // Create content container if it doesn't exist
      let contentEl = sidebarBody.querySelector('#mga-tab-content');
      if (!contentEl) {
        contentEl = targetDocument.createElement('div');
        contentEl.id = 'mga-tab-content';
        sidebarBody.innerHTML = '';
        sidebarBody.appendChild(contentEl);
      }

      // Call existing updateTabContent which handles all rendering
      updateTabContent();

      // Reset scroll position to top when opening a tab
      sidebarBody.scrollTop = 0;

      // Show sidebar
      sidebar.classList.add('open');

      // Update active state on dock items
      targetDocument.querySelectorAll('.mgh-dock-item').forEach(item => {
        item.classList.toggle('active', item.dataset.tab === tabName);
      });

      // Mark shift hint as shown
      localStorage.setItem('mga_shift_hint_shown', 'true');
    }

    function openPopoutWidget(tabName) {
      // Check if this widget is already open - if so, close it
      const existingPopout = targetDocument.querySelector(`.mgh-popout[data-tab="${tabName}"]`);
      if (existingPopout) {
        UnifiedState.data.popouts.widgets.delete(tabName); // Clean up tracking
        existingPopout.remove();
        return;
      }

      const popout = targetDocument.createElement('div');
      popout.className = 'mgh-popout';
      popout.dataset.tab = tabName; // Store tab name for toggle detection
      popout.style.top = '100px';
      popout.style.left = '100px';

      const header = targetDocument.createElement('div');
      header.className = 'mgh-popout-header';
      header.innerHTML = `
              <span>${tabName.charAt(0).toUpperCase() + tabName.slice(1)}</span>
              <span style="cursor: pointer; margin-left: auto; padding: 0 8px; font-size: 20px;">√ó</span>
          `;

      const closeBtn = header.querySelector('span:last-child');
      closeBtn.addEventListener('click', () => {
        // Cleanup for shop popout
        if (tabName === 'shop') {
          stopInventoryCounter();
        }
        UnifiedState.data.popouts.widgets.delete(tabName); // Clean up tracking
        popout.remove();
      });

      const body = targetDocument.createElement('div');
      body.className = 'mgh-popout-body';

      // Create content container
      const contentEl = targetDocument.createElement('div');
      contentEl.id = 'mga-tab-content';
      body.appendChild(contentEl);

      popout.appendChild(header);
      popout.appendChild(body);

      // Make draggable
      makePopoutDraggable(popout, header);

      // Render content BEFORE appending (so theme can see it)
      const prevTab = UnifiedState.activeTab;
      UnifiedState.activeTab = tabName;

      // Get the content element we just created
      const popoutContent = popout.querySelector('#mga-tab-content');

      // Generate content based on tab
      switch (tabName) {
        case 'pets':
          popoutContent.innerHTML = getPetsTabContent();
          setupPetsTabHandlers(popout); // Pass popout context
          break;
        case 'abilities':
          popoutContent.innerHTML = getAbilitiesTabContent();
          setupAbilitiesTabHandlers(popout);
          updateAbilityLogDisplay(popout);
          break;
        case 'seeds':
          popoutContent.innerHTML = getSeedsTabContent();
          setupSeedsTabHandlers(popout); // Pass popout context
          break;
        case 'shop':
          popoutContent.innerHTML = getShopTabContent();
          setupShopTabHandlers(popout); // Pass popout context
          break;
        case 'values':
          popoutContent.innerHTML = getValuesTabContent();
          setupValuesTabHandlers(popout); // Pass popout context
          break;
        case 'timers':
          popoutContent.innerHTML = getTimersTabContent();
          break;
        case 'rooms':
          popoutContent.innerHTML = getRoomStatusTabContent();
          setupRoomJoinButtons(popout); // Pass popout context
          break;
        case 'tools':
          popoutContent.innerHTML = getCachedTabContent('tools', getToolsTabContent);
          break;
        case 'settings':
          popoutContent.innerHTML = getCachedTabContent('settings', getSettingsTabContent);
          setupSettingsTabHandlers(popout); // Pass popout context
          break;
        case 'hotkeys':
          popoutContent.innerHTML = getCachedTabContent('hotkeys', getHotkeysTabContent);
          setupHotkeysTabHandlers(popout); // Pass popout context
          break;
        case 'notifications':
          popoutContent.innerHTML = getCachedTabContent('notifications', getNotificationsTabContent);
          setupNotificationsTabHandlers(popout); // Pass popout context
          break;
        case 'protect':
          popoutContent.innerHTML = getCachedTabContent('protect', getProtectTabContent);
          // Wait for browser to parse HTML before attaching handlers
          requestAnimationFrame(() => {
            setupProtectTabHandlers(popout); // Pass popout context
          });
          break;
        case 'help':
          popoutContent.innerHTML = getCachedTabContent('help', getHelpTabContent);
          break;
      }

      UnifiedState.activeTab = prevTab; // Restore previous tab

      // NOW append to DOM
      targetDocument.body.appendChild(popout);

      // Apply theme to widget AFTER content is rendered
      const popoutThemeStyles = generateThemeStyles(UnifiedState.data.settings, true);
      if (popoutThemeStyles) {
        applyThemeToPopoutWidget(popout, popoutThemeStyles);
      }

      // Make resizable LAST
      makeElementResizable(popout, {
        minWidth: 320,
        minHeight: 200,
        maxWidth: 800,
        maxHeight: 900,
        handleSize: 14,
        showHandleOnHover: true
      });

      // Track widget for theme updates
      UnifiedState.data.popouts.widgets.set(tabName, popout);
    }

    function makePopoutDraggable(popout, handle) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      // Shared drag start logic
      const startDrag = (clientX, clientY, event) => {
        isDragging = true;
        startX = clientX;
        startY = clientY;
        const rect = popout.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;
        handle.style.cursor = 'grabbing';
        event.preventDefault(); // Prevent text selection during drag
      };

      // Shared drag move logic
      const handleDragMove = (clientX, clientY) => {
        if (!isDragging) return;
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        popout.style.left = startLeft + deltaX + 'px';
        popout.style.top = startTop + deltaY + 'px';
      };

      // Shared drag end logic
      const endDrag = () => {
        if (isDragging) {
          isDragging = false;
          handle.style.cursor = 'grab';
        }
      };

      // Mouse event handlers
      handle.addEventListener('mousedown', e => {
        startDrag(e.clientX, e.clientY, e);
      });

      document.addEventListener('mousemove', e => {
        handleDragMove(e.clientX, e.clientY);
      });

      document.addEventListener('mouseup', () => {
        endDrag();
      });

      // Touch event handlers
      handle.addEventListener(
        'touchstart',
        e => {
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            startDrag(touch.clientX, touch.clientY, e);
          }
        },
        { passive: false }
      );

      document.addEventListener(
        'touchmove',
        e => {
          if (isDragging && e.touches.length === 1) {
            const touch = e.touches[0];
            handleDragMove(touch.clientX, touch.clientY);
            e.preventDefault(); // Prevent scrolling while dragging
          }
        },
        { passive: false }
      );

      document.addEventListener('touchend', () => {
        endDrag();
      });

      document.addEventListener('touchcancel', () => {
        endDrag();
      });
    }

    // ==================== WEATHER TOGGLE FUNCTIONS ====================
    let weatherCheckInterval = null;

    function hideWeatherCanvases() {
      const canvases = document.querySelectorAll('canvas.WeatherCanvas');
      productionLog(`üåßÔ∏è [WEATHER] Hiding ${canvases.length} weather canvas(es)`);
      canvases.forEach(canvas => {
        canvas.style.display = 'none';
      });
    }

    function showWeatherCanvases() {
      const canvases = document.querySelectorAll('canvas.WeatherCanvas');
      productionLog(`üåßÔ∏è [WEATHER] Showing ${canvases.length} weather canvas(es)`);
      canvases.forEach(canvas => {
        canvas.style.display = '';
      });
    }

    function applyWeatherSetting() {
      productionLog(`üåßÔ∏è [WEATHER] Applying weather setting: hideWeather=${UnifiedState.data.settings.hideWeather}`);

      // Clear any existing interval
      if (weatherCheckInterval) {
        clearInterval(weatherCheckInterval);
        weatherCheckInterval = null;
      }

      if (UnifiedState.data.settings.hideWeather) {
        // Hide weather canvases immediately
        hideWeatherCanvases();

        // Set up interval to catch dynamically added weather canvases
        weatherCheckInterval = setInterval(() => {
          const canvases = document.querySelectorAll('canvas.WeatherCanvas');
          canvases.forEach(canvas => {
            if (canvas.style.display !== 'none') {
              canvas.style.display = 'none';
            }
          });
        }, 500); // Check every 500ms
      } else {
        showWeatherCanvases();
      }
    }

    // ==================== HOTKEY HELPER FUNCTIONS ====================
    function formatHotkey(event) {
      const parts = [];
      if (event.ctrlKey) parts.push('Ctrl');
      if (event.altKey) parts.push('Alt');
      if (event.shiftKey) parts.push('Shift');

      let key = event.key;
      if (key === ' ') key = 'Space';
      else if (key.length === 1) key = key.toUpperCase();

      parts.push(key);
      return parts.join('+');
    }

    function matchesHotkey(event, hotkeyString) {
      if (!hotkeyString) return false;
      const formatted = formatHotkey(event);
      return formatted.toLowerCase() === hotkeyString.toLowerCase();
    }

    function showHotkeyRecordingModal(presetName, context) {
      // Create modal overlay
      const modal = targetDocument.createElement('div');
      modal.id = 'hotkey-recording-modal';
      modal.style.cssText = `
              position: fixed;
              top: 0; left: 0; right: 0; bottom: 0;
              background: rgba(0, 0, 0, 0.8);
              display: flex;
              align-items: center;
              justify-content: center;
              z-index: 9999999;
          `;

      const modalContent = targetDocument.createElement('div');
      modalContent.style.cssText = `
              background: #1a1a1a;
              padding: 24px;
              border-radius: 8px;
              border: 1px solid rgba(255, 255, 255, 0.73);
              text-align: center;
              min-width: 300px;
          `;

      modalContent.innerHTML = `
              <h3 style="color: white; margin-bottom: 16px;">Set Hotkey for "${presetName}"</h3>
              <p style="color: #aaa; margin-bottom: 16px; font-size: 13px;">Press any key combination...</p>
              <div id="hotkey-display" style="
                  background: rgba(74, 158, 255, 0.48);
                  border: 1px solid #4a9eff;
                  padding: 12px;
                  border-radius: 4px;
                  color: white;
                  font-size: 16px;
                  margin-bottom: 16px;
                  min-height: 40px;
                  display: flex;
                  align-items: center;
                  justify-content: center;
              ">Waiting...</div>
              <div style="display: flex; gap: 8px;">
                  <button id="hotkey-save" class="mga-btn" disabled style="flex: 1;">Save</button>
                  <button id="hotkey-clear" class="mga-btn" style="flex: 1; background: rgba(255, 100, 100, 0.48); border-color: #ff6464;">Clear</button>
                  <button id="hotkey-cancel" class="mga-btn" style="flex: 1;">Cancel</button>
              </div>
          `;

      modal.appendChild(modalContent);
      targetDocument.body.appendChild(modal);

      const display = modal.querySelector('#hotkey-display');
      const saveBtn = modal.querySelector('#hotkey-save');
      const clearBtn = modal.querySelector('#hotkey-clear');
      const cancelBtn = modal.querySelector('#hotkey-cancel');

      let capturedHotkey = null;

      const handleKeyDown = e => {
        if (e.key === 'Escape') {
          modal.remove();
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        capturedHotkey = formatHotkey(e);
        display.textContent = capturedHotkey;
        saveBtn.disabled = false;
      };

      targetDocument.addEventListener('keydown', handleKeyDown, true);

      saveBtn.addEventListener('click', () => {
        if (capturedHotkey) {
          // Check for duplicate hotkey usage
          const existingPreset = Object.entries(UnifiedState.data.petPresetHotkeys).find(
            ([name, key]) => name !== presetName && key === capturedHotkey
          );

          if (existingPreset) {
            const proceed = confirm(
              `Hotkey "${capturedHotkey}" is already used by preset "${existingPreset[0]}".\n\nReassign it to "${presetName}"? This will remove it from the other preset.`
            );
            if (!proceed) return;
            // Remove from old preset
            delete UnifiedState.data.petPresetHotkeys[existingPreset[0]];
          }

          UnifiedState.data.petPresetHotkeys[presetName] = capturedHotkey;
          MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
          refreshPresetsList(context);
        }
        targetDocument.removeEventListener('keydown', handleKeyDown, true);
        modal.remove();
      });

      clearBtn.addEventListener('click', () => {
        delete UnifiedState.data.petPresetHotkeys[presetName];
        MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
        refreshPresetsList(context);
        targetDocument.removeEventListener('keydown', handleKeyDown, true);
        modal.remove();
      });

      cancelBtn.addEventListener('click', () => {
        targetDocument.removeEventListener('keydown', handleKeyDown, true);
        modal.remove();
      });
    }

    // Register Alt+B hotkey to toggle shop windows
    // Use capture phase (true) to intercept before game handlers
    targetDocument.addEventListener(
      'keydown',
      e => {
        // CRITICAL: Block ALL MGTools hotkeys when typing in inputs
        if (shouldBlockHotkey(e)) {
          if (UnifiedState.data.settings?.debugMode) {
            console.log('[FIX_HOTKEYS] Blocked MGTools hotkey in input (pet presets/nav)');
          }
          return; // Don't process any MGTools hotkeys
        }

        // Alt+B for shop
        if (e.altKey && e.key.toLowerCase() === 'b') {
          e.preventDefault();
          e.stopPropagation();
          toggleShopWindows();
          return;
        }

        // Check pet preset hotkeys
        for (const [presetName, hotkey] of Object.entries(UnifiedState.data.petPresetHotkeys)) {
          if (hotkey && matchesHotkey(e, hotkey)) {
            const preset = UnifiedState.data.petPresets[presetName];
            if (preset) {
              e.preventDefault();
              e.stopPropagation();
              loadPetPreset(preset);

              // Refresh active pets display after loading
              setTimeout(() => {
                updateActivePetsFromRoomState();
                const sidebar = document.querySelector('#mgh-sidebar-body');
                if (sidebar) updateActivePetsDisplay(sidebar);

                // Also refresh any open popouts
                refreshSeparateWindowPopouts('pets');
              }, 800);
              return;
            }
            // If preset doesn't exist (orphaned hotkey), continue checking other presets
          }
        }

        // Check MGTools navigation hotkeys
        const mgToolsKeys = UnifiedState.data.hotkeys.mgToolsKeys;
        const tabMap = {
          openPets: 'pets',
          openAbilities: 'abilities',
          openSeeds: 'seeds',
          openValues: 'values',
          openTimers: 'timers',
          openRooms: 'rooms',
          openShop: 'shop'
        };

        for (const [action, config] of Object.entries(mgToolsKeys)) {
          if (config.custom && matchesHotkey(e, config.custom)) {
            e.preventDefault();
            e.stopPropagation();

            // Handle cycle presets action
            if (action === 'cyclePresets') {
              cycleToNextPreset();
              return;
            }

            // Handle tab opening actions
            const tabName = tabMap[action];
            if (tabName === 'shop') {
              toggleShopWindows();
            } else if (tabName) {
              openSidebarTab(tabName);
            }
            return;
          }
        }
      },
      true
    ); // Use capture phase to intercept before game handlers

    // Pop-out window functionality (separate window implementation)
    function openTabInSeparateWindow(tabName) {
      productionLog(`üîó Opening ${tabName} tab in pop-out window...`);

      const tabTitles = {
        pets: 'üêæ Pet Loadouts',
        abilities: '‚ö° Abilities',
        seeds: 'üå± Seeds',
        values: 'üí∞ Values',
        timers: '‚è∞ Timers',
        rooms: 'üéÆ Rooms',
        settings: '‚öôÔ∏è Settings'
      };

      const title = `MGTools - ${tabTitles[tabName] || tabName}`;

      // Calculate window size based on tab content
      const windowFeatures =
        'width=450,height=550,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=no,status=no';

      const popoutWindow = window.open('', `mga_popout_${tabName}`, windowFeatures);

      if (!popoutWindow) {
        productionWarn('‚ö†Ô∏è Pop-out blocked! Please allow popups for this site.');
        return;
      }

      // Track the popout window for cleanup
      trackPopoutWindow(popoutWindow);

      // BUGFIX: Store window reference in Map for real-time updates
      UnifiedState.data.popouts.windows.set(tabName, popoutWindow);

      // Add cleanup listener to remove from Map when window closes
      popoutWindow.addEventListener('beforeunload', () => {
        UnifiedState.data.popouts.windows.delete(tabName);
        debugLog('POPOUT_LIFECYCLE', `Removed ${tabName} from windows Map`);
      });

      // Get tab content based on tab name
      let content = '';
      switch (tabName) {
        case 'pets':
          content = getPetsPopoutContent();
          break;
        case 'abilities':
          content = getAbilitiesTabContent();
          break;
        case 'seeds':
          content = getSeedsTabContent();
          break;
        case 'shop':
          content = getShopTabContent();
          break;
        case 'values':
          content = getValuesTabContent();
          break;
        case 'timers':
          content = getTimersTabContent();
          break;
        case 'tools':
          content = getToolsTabContent();
          break;
        case 'rooms':
          content = getRoomStatusTabContent();
          break;
        case 'settings':
          content = getSettingsTabContent();
          break;
        case 'help':
          content = getHelpTabContent();
          break;
        default:
          content = '<p>Tab content not available</p>';
      }

      // Get current theme for pop-out window
      const currentTheme = UnifiedState.currentTheme || generateThemeStyles();

      // Create pop-out window HTML with dynamic theming
      const popoutHTML = `
  <!DOCTYPE html>
  <html>
  <head>
      <title>${title}</title>
      <style>
          ${UNIFIED_STYLES}
          body {
              margin: 0;
              padding: 16px;
              background: ${currentTheme.background};
              color: #ffffff;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
              min-height: 100vh;
              --panel-scale: 1;
              --base-font-size: 13px;
              --responsive-font-size: calc(var(--base-font-size) * var(--panel-scale));
              font-size: var(--responsive-font-size);
          }

          /* Removed universal font scaling to prevent oversized popout UI */
          .popout-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 16px;
              padding: 12px;
              background: rgba(255, 255, 255, 0.05);
              border-radius: 8px;
              border: 1px solid rgba(255, 255, 255, 0.57);
              flex-wrap: wrap;
              gap: 10px;
          }
          .popout-title {
              font-size: 18px;
              font-weight: 600;
              color: #4a9eff;
              flex-shrink: 0;
              min-width: 150px;
          }
          .popout-sync-notice {
              font-size: 12px;
              color: #888;
              font-style: italic;
              flex: 1 1 auto;
              text-align: center;
              min-width: 200px;
          }
          .refresh-btn {
              padding: 6px 12px;
              background: #4a9eff;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              flex-shrink: 0;
          }
          .refresh-btn:hover {
              background: #3a8eef;
          }
      </style>
  </head>
  <body>
      <div class="popout-header">
          <div class="popout-title">${title}</div>
          <div class="popout-sync-notice">Note: This is a static snapshot. Click refresh to update.</div>
          <button class="refresh-btn" onclick="refreshPopoutContent('\${tabName}')">üîÑ Refresh</button>
      </div>
      <div id="popout-content" class="mga-scrollable mga-popout-content" style="max-height: calc(100vh - 120px); overflow-y: auto;">
          ${content}
      </div>

      <script>
          // Store reference to main window
          const mainWindow = window.opener;

          function refreshPopoutContent(tabName) {
              if (!mainWindow || mainWindow.closed) {
                  productionWarn('‚ö†Ô∏è Main window is closed. Cannot refresh content.');
                  return;
              }

              // Get fresh content from main window
              let freshContent = '';
              switch(tabName) {
                  case 'pets':
                      freshContent = mainWindow.MGA_Internal?.getPetsPopoutContent ? mainWindow.MGA_Internal?.getPetsPopoutContent() : 'Content unavailable';
                      break;
                  case 'abilities':
                      freshContent = mainWindow.MGA_Internal?.getAbilitiesTabContent ? mainWindow.MGA_Internal?.getAbilitiesTabContent() : 'Content unavailable';
                      break;
                  case 'seeds':
                      freshContent = mainWindow.MGA_Internal?.getSeedsTabContent ? mainWindow.MGA_Internal?.getSeedsTabContent() : 'Content unavailable';
                      break;
                  case 'shop':
                      freshContent = mainWindow.MGA_Internal?.getShopTabContent ? mainWindow.MGA_Internal?.getShopTabContent() : 'Content unavailable';
                      break;
                  case 'values':
                      freshContent = mainWindow.MGA_Internal?.getValuesTabContent ? mainWindow.MGA_Internal?.getValuesTabContent() : 'Content unavailable';
                      break;
                  case 'timers':
                      freshContent = mainWindow.MGA_Internal?.getTimersTabContent ? mainWindow.MGA_Internal?.getTimersTabContent() : 'Content unavailable';
                      break;
                  case 'tools':
                      freshContent = mainWindow.MGA_Internal?.getToolsTabContent ? mainWindow.MGA_Internal?.getToolsTabContent() : 'Content unavailable';
                      break;
                  case 'rooms':
                      freshContent = mainWindow.MGA_Internal?.getRoomStatusTabContent ? mainWindow.MGA_Internal?.getRoomStatusTabContent() : 'Content unavailable';
                      break;
                  case 'settings':
                      freshContent = mainWindow.MGA_Internal?.getSettingsTabContent ? mainWindow.MGA_Internal?.getSettingsTabContent() : 'Content unavailable';
                      break;
              }

              document.getElementById('popout-content').innerHTML = freshContent;

              // Rerun handlers if needed
              if (tabName === 'abilities' && mainWindow.setupAbilitiesTabHandlers) {
                  mainWindow.setupAbilitiesTabHandlers.call(mainWindow);
                  if (mainWindow.updateAbilityLogDisplay) {
                      mainWindow.updateAbilityLogDisplay.call(mainWindow);
                  }
              } else if (tabName === 'pets') {
                  // For pets popout, use special popout handlers instead of main tab handlers
                  if (mainWindow.setupPetPopoutHandlers) {
                      mainWindow.setupPetPopoutHandlers.call(mainWindow, document);
                  }
              } else if (tabName === 'seeds' && mainWindow.setupSeedsTabHandlers) {
                  mainWindow.setupSeedsTabHandlers.call(mainWindow, document);
              } else if (tabName === 'values' && mainWindow.resourceDashboard) {
                  mainWindow.resourceDashboard.setupDashboardHandlers(document);
              } else if (tabName === 'settings' && mainWindow.setupSettingsTabHandlers) {
                  mainWindow.setupSettingsTabHandlers.call(mainWindow, document);
              } else if (tabName === 'rooms' && mainWindow.setupRoomJoinButtons) {
                  mainWindow.setupRoomJoinButtons.call(mainWindow);
              }

              productionLog('Pop-out content refreshed for:', tabName);
          }

          // BUGFIX: Expose refresh function on window object for external access
          window.refreshPopoutContent = refreshPopoutContent;

          // Store the tab name for this popup window
          const currentTabName = '\${tabName}';

          // Auto-refresh every 5 seconds for dynamic tabs
          // BUGFIX: Added 'abilities' to auto-refresh list for real-time ability log updates
          if (['values', 'timers', 'rooms', 'abilities'].includes(currentTabName)) {
              // Use managed interval to prevent memory leaks
              if (window.opener && window.opener.setManagedInterval) {
                  window.opener.setManagedInterval(
                      'popoutRefresh_' + currentTabName + '_' + Date.now(),
                      () => refreshPopoutContent(currentTabName),
                      5000
                  );
              }
          }

          // Cleanup when window closes
          window.addEventListener('beforeunload', () => {
              productionLog('Pop-out window closing for:', currentTabName);
          });
      </script>
  </body>
  </html>
          `;

      productionLog('üå± [WINDOW DEBUG] Content being written to separate window:', {
        tabName,
        contentLength: content.length,
        htmlLength: popoutHTML.length,
        contentPreview: content.substring(0, 200)
      });

      popoutWindow.document.open();
      popoutWindow.document.write(popoutHTML);
      popoutWindow.document.close();

      // Set up handlers for the pop-out content
      setTimeout(() => {
        try {
          switch (tabName) {
            case 'abilities':
              // Note: Handlers won't work perfectly in pop-out due to cross-window limitations
              // Users should use refresh button for interactions
              break;
            case 'pets':
              setupPetPopoutHandlers(popoutWindow.document);
              break;
            case 'seeds':
              setupSeedsTabHandlers(popoutWindow.document);
              break;
            case 'shop':
              setupShopTabHandlers(popoutWindow.document);
              break;
            case 'settings':
              setupSettingsTabHandlers(popoutWindow.document);
              break;
            case 'tools':
              setupToolsTabHandlers(popoutWindow.document);
              break;
            case 'rooms':
              setupRoomJoinButtons();
              setupRoomsTabButtons();
              break;
            case 'hotkeys':
              setupHotkeysTabHandlers(popoutWindow.document);
              break;
            case 'notifications':
              setupNotificationsTabHandlers(popoutWindow.document);
              break;
            case 'help':
              // Help tab doesn't need special handlers
              break;
          }
        } catch (error) {
          productionWarn('Could not set up pop-out handlers:', error);
        }
      }, 100);

      productionLog(`‚úÖ Pop-out window opened for ${tabName} tab`);
    }

    // Expose content functions in MGA namespace for pop-out windows (prevents conflicts)
    window.MGA_Internal = window.MGA_Internal || {};
    window.MGA_Internal.getPetsTabContent = getPetsTabContent;
    window.MGA_Internal.getPetsPopoutContent = getPetsPopoutContent;
    window.MGA_Internal.setupPetPopoutHandlers = setupPetPopoutHandlers;
    window.MGA_Internal.getAbilitiesTabContent = getAbilitiesTabContent;
    window.MGA_Internal.getSeedsTabContent = getSeedsTabContent;
    window.MGA_Internal.getValuesTabContent = getValuesTabContent;
    window.MGA_Internal.getTimersTabContent = getTimersTabContent;
    window.MGA_Internal.getToolsTabContent = getToolsTabContent;
    window.MGA_Internal.getRoomStatusTabContent = getRoomStatusTabContent;
    window.MGA_Internal.getSettingsTabContent = getSettingsTabContent;
    window.MGA_Internal.setupAbilitiesTabHandlers = setupAbilitiesTabHandlers;
    window.MGA_Internal.updateAbilityLogDisplay = updateAbilityLogDisplay;
    window.MGA_Internal.setupPetsTabHandlers = setupPetsTabHandlers;
    window.MGA_Internal.setupSeedsTabHandlers = setupSeedsTabHandlers;
    window.MGA_Internal.setupSettingsTabHandlers = setupSettingsTabHandlers;
    window.MGA_Internal.setupToolsTabHandlers = setupToolsTabHandlers;
    window.MGA_Internal.setupRoomJoinButtons = setupRoomJoinButtons;

    // Export storage functions
    window.MGA_Internal.MGA_loadJSON = MGA_loadJSON;
    window.MGA_Internal.MGA_saveJSON = MGA_saveJSON;

    // ==================== IN-GAME OVERLAY SYSTEM ====================

    function getContentForTab(tabName, isPopout = false) {
      switch (tabName) {
        case 'pets':
          return isPopout ? getPetsPopoutContent() : getPetsTabContent();
        case 'abilities':
          return getAbilitiesTabContent();
        case 'seeds':
          return getSeedsTabContent();
        case 'shop':
          return getShopTabContent();
        case 'values':
          return getValuesTabContent();
        case 'timers':
          return getTimersTabContent();
        case 'rooms':
          return getRoomStatusTabContent();
        case 'tools':
          return getToolsTabContent();
        case 'settings':
          return getSettingsTabContent();
        case 'hotkeys':
          return getHotkeysTabContent();
        case 'notifications':
          return getNotificationsTabContent();
        default:
          return '<div style="padding: 20px; text-align: center; color: rgba(255,255,255,0.5);">Content not available</div>';
      }
    }

    function setupOverlayHandlers(overlay, tabName) {
      try {
        debugLog('HANDLER_SETUP', `Setting up handlers for content-only overlay ${tabName}`, {
          overlayId: overlay.id
        });

        switch (tabName) {
          case 'abilities':
            setupAbilitiesTabHandlers(overlay);
            if (overlay) {
              updateAbilityLogDisplay(overlay);
              debugLog('ABILITY_LOGS', 'Populated ability logs for content-only overlay', {
                logCount: UnifiedState.data.petAbilityLogs.length
              });
            }
            break;
          case 'pets':
            setupPetPopoutHandlers(overlay); // Use popout handlers for overlays
            break;
          case 'seeds':
            setupSeedsTabHandlers(overlay);
            break;
          case 'shop':
            setupShopTabHandlers(overlay);
            break;
          case 'settings':
            setupSettingsTabHandlers(overlay);
            break;
          case 'tools':
            setupToolsTabHandlers(overlay);
            break;
          case 'rooms':
            setupRoomJoinButtons();
            setupRoomsTabButtons();
            break;
          case 'hotkeys':
            setupHotkeysTabHandlers(overlay);
            break;
          case 'notifications':
            setupNotificationsTabHandlers(overlay);
            break;
        }
      } catch (error) {
        debugError('HANDLER_SETUP', 'Failed to set up content-only overlay handlers', error, {
          tabName,
          overlayId: overlay?.id
        });
      }
    }

    function createInGameOverlay(tabName) {
      debugLog('OVERLAY_LIFECYCLE', `Creating content-only overlay for ${tabName} tab`);

      // Check if overlay already exists - toggle visibility
      if (UnifiedState.data.popouts.overlays.has(tabName)) {
        const existingOverlay = UnifiedState.data.popouts.overlays.get(tabName);
        if (existingOverlay && document.contains(existingOverlay)) {
          // Toggle: if visible, remove it; if hidden, show it
          if (existingOverlay.style.display !== 'none') {
            existingOverlay.remove();
            UnifiedState.data.popouts.overlays.delete(tabName);
            debugLog('OVERLAY_LIFECYCLE', `Toggled OFF: ${tabName} overlay removed`);
            return null;
          } else {
            existingOverlay.style.display = 'block';
            existingOverlay.style.zIndex = '999999';
            debugLog('OVERLAY_LIFECYCLE', `Toggled ON: ${tabName} overlay shown`);
            return existingOverlay;
          }
        }
      }

      // Create content-only overlay container - NO HEADER, NO DECORATIONS
      const overlay = targetDocument.createElement('div');
      overlay.className = 'mga-overlay-content-only mga-scrollable';
      overlay.id = `mga-overlay-${tabName}`;

      // SMART POSITIONING - Avoid overlapping with existing overlays
      const gameViewport = getGameViewport();
      const smartPosition = findOptimalPosition(tabName, gameViewport);

      // PURE CONTENT DESIGN with PROPER RESIZING - Perfect match to target image (NO CHROME)
      overlay.style.cssText = `
              position: fixed;
              top: ${smartPosition.top}px;
              left: ${smartPosition.left}px;
              width: 240px;
              height: 300px;
              min-height: 120px;
              max-height: 500px;
              padding: 10px 12px;
              color: #ffffff;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
              font-size: 12px;
              line-height: 1.4;
              z-index: 999998;
              overflow-y: auto;
              min-width: 180px;
              max-width: 450px;
              user-select: none;
              border-radius: 4px;
              backdrop-filter: blur(10px);
              cursor: grab;
              will-change: width, height, transform;
          `;

      // Apply theme - clean background with textures support
      const popoutTheme = generateThemeStyles(UnifiedState.data.settings, true);

      // Layer texture over gradient if texture is enabled (same logic as applyThemeToElement)
      if (popoutTheme.texturePattern) {
        overlay.style.background = `${popoutTheme.texturePattern}, ${popoutTheme.background}`;
        overlay.style.backgroundSize = `${popoutTheme.textureBackgroundSize}, cover`;
        overlay.style.backgroundBlendMode = `${popoutTheme.textureBlendMode}, normal`;
      } else {
        overlay.style.background = popoutTheme.background;
        overlay.style.backgroundBlendMode = '';
      }

      // Invisible scrollbars are now handled by the mga-scrollable class

      debugLog('POP_OUT_DESIGN', `Applied content-only theme for ${tabName}`, {
        background: popoutTheme.background,
        dimensions: `${overlay.style.width} x ${overlay.style.height}`
      });

      // NO HEADER - Content only design matching target image
      // Add simple close functionality via right-click context menu or ESC key

      // Add keyboard shortcut for closing (ESC key)
      overlay.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
          debugLog('POP_OUT_DESIGN', `Closing overlay ${tabName} via ESC key`);
          closeInGameOverlay(tabName);
        }
      });

      // Make overlay focusable for keyboard events
      overlay.tabIndex = -1;
      overlay.focus();

      // INVISIBLE DRAGGING - No chrome, entire overlay is draggable
      // Add subtle visual feedback on hover (skip for pets popouts to prevent stutter)
      overlay.addEventListener('mouseenter', () => {
        if (
          !overlay.hasAttribute('data-dragging') &&
          !overlay.id.includes('mga-pets-popout') &&
          !overlay.id.includes('pets')
        ) {
          overlay.style.transform = 'scale(1.005)';
          overlay.style.transition = 'transform 0.15s ease';
        }
      });

      overlay.addEventListener('mouseleave', () => {
        if (
          !overlay.hasAttribute('data-dragging') &&
          !overlay.id.includes('mga-pets-popout') &&
          !overlay.id.includes('pets')
        ) {
          overlay.style.transform = 'scale(1)';
        }
      });

      // Add content directly to overlay (no separate contentArea needed)
      // Add scrollbar styling for content-only design
      const contentHtml = `
              <style>
                  /* TARGET IMAGE MATCH - Clean, readable styling */
                  /* Section titles are now handled in the main visibility rules above */

                  .mga-overlay-content-only .mga-section {
                      margin: 0 !important;
                      padding: 0 !important;
                  }

                  .mga-overlay-content-only .mga-value-row {
                      display: flex !important;
                      justify-content: space-between !important;
                      margin: 3px 0 !important;
                      padding: 2px 0 !important;
                      line-height: 1.3 !important;
                  }

                  .mga-overlay-content-only .mga-value-label {
                      font-size: 12px !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      font-weight: 400 !important;
                      margin: 0 !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }

                  .mga-overlay-content-only .mga-value-amount {
                      font-size: 13px !important;
                      font-weight: 600 !important;
                      color: #ffffff !important;
                      margin: 0 !important;
                      text-align: right;
                      min-width: 50px;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
                  }

                  /* HIGH CONTRAST TOTAL VALUE */
                  .mga-overlay-content-only .mga-total-value {
                      border-top: 1px solid rgba(255, 255, 255, 0.73) !important;
                      margin-top: 6px !important;
                      padding-top: 4px !important;
                  }

                  .mga-overlay-content-only .mga-total-value .mga-value-label {
                      font-weight: 500 !important;
                      color: rgba(255, 255, 255, 0.95) !important;
                      font-size: 13px !important;
                  }

                  .mga-overlay-content-only .mga-total-value .mga-value-amount {
                      font-size: 14px !important;
                      font-weight: 700 !important;
                      color: #ffff00 !important;
                      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
                  }

                  /* Hide only truly unnecessary elements - KEEP buttons and checkboxes for functionality */
                  .mga-overlay-content-only .mga-section-header,
                  .mga-overlay-content-only .mga-input-group,
                  .mga-overlay-content-only .mga-timer-controls {
                      display: none !important;
                  }

                  /* Keep section titles visible but make them smaller */
                  .mga-overlay-content-only .mga-section-title {
                      display: block !important;
                      font-size: 11px !important;
                      margin-bottom: 4px !important;
                  }

                  /* Readable ability logs */
                  .mga-overlay-content-only .mga-log-item {
                      margin: 2px 0 !important;
                      padding: 2px 0 !important;
                      font-size: 11px !important;
                      line-height: 1.3 !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }

                  .mga-overlay-content-only .mga-log-time {
                      font-size: 10px !important;
                      color: rgba(255, 255, 255, 0.7) !important;
                  }

                  /* Readable pet loadouts */
                  .mga-overlay-content-only .mga-pet-slot {
                      margin: 2px 0 !important;
                      padding: 3px !important;
                      font-size: 11px !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }
              </style>
          `;

      // Get and add content directly to overlay - PURE CONTENT ONLY
      const contentHTML = getContentForTab(tabName, true); // isPopout=true for overlays

      productionLog('üîç [CONTENT DEBUG] Variables check:', {
        contentHtmlType: typeof contentHtml,
        contentHtmlLength: contentHtml?.length,
        contentHTMLType: typeof contentHTML,
        contentHTMLLength: contentHTML?.length,
        contentHtmlPreview: contentHtml?.substring(0, 100),
        contentHTMLPreview: contentHTML?.substring(0, 100)
      });

      // For ability logs, add a subtle drag indicator
      if (tabName === 'abilities') {
        const dragIndicator = `
                  <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.57);">
                      <div style="font-size: 11px; color: #4a9eff; font-weight: 600;">ABILITY LOGS</div>
                      <div style="font-size: 9px; color: rgba(255,255,255,0.4); cursor: grab;" title="Click and drag to move">‚£ø‚£ø drag</div>
                  </div>
              `;
        overlay.innerHTML = contentHtml + dragIndicator + contentHTML;
      } else {
        overlay.innerHTML = contentHtml + contentHTML;
      }

      productionLog('üå± [OVERLAY DEBUG] Content inserted:', {
        tabName,
        contentLength: contentHTML.length,
        overlayHTML: overlay.innerHTML.substring(0, 200)
      });

      // Apply invisible dragging to entire overlay surface
      makeEntireOverlayDraggable(overlay);

      // Add professional resize functionality
      addResizeHandleToOverlay(overlay);

      // Function now available globally - moved to global scope

      // Load saved position and dimensions
      loadOverlayPosition(overlay);
      loadOverlayDimensions(overlay);

      debugLog('POP_OUT_DESIGN', `Content added to overlay for ${tabName}`, {
        hasContent: !!contentHTML
      });

      // Add to DOM and track
      targetDocument.body.appendChild(overlay);

      // After rendering notification checkboxes in widget, reload saved state
      if (tabName === 'notifications') {
        // Use already-loaded settings from UnifiedState (avoid double-load race condition)
        const notifications = UnifiedState.data?.settings?.notifications;
        if (notifications) {
          // Apply ability notification settings
          const abilityCheckbox = overlay.querySelector('#ability-notifications-enabled');
          if (abilityCheckbox) {
            abilityCheckbox.checked = notifications.abilityNotificationsEnabled || false;
          }

          // Apply category settings if category checkboxes exist
          if (notifications.watchedAbilityCategories) {
            Object.keys(notifications.watchedAbilityCategories).forEach(category => {
              const catCheckbox = overlay.querySelector(`#ability-cat-${category}`);
              if (catCheckbox) {
                catCheckbox.checked = notifications.watchedAbilityCategories[category];
              }
            });
          }

          // Apply individual ability checkboxes
          if (notifications.watchedAbilities) {
            const individualCheckboxes = overlay.querySelectorAll('.individual-ability-checkbox');
            individualCheckboxes.forEach(checkbox => {
              const abilityName = checkbox.dataset.abilityName;
              if (abilityName) {
                checkbox.checked = notifications.watchedAbilities.includes(abilityName);
              }
            });
          }

          productionLog(`‚úÖ [WIDGET-STATE] Reloaded notification settings for ${tabName} widget`);
        }
      }
      UnifiedState.data.popouts.overlays.set(tabName, overlay);

      // Setup handlers for the content (now that overlay is in DOM)
      setTimeout(() => {
        setupOverlayHandlers(overlay, tabName);
      }, 100);

      debugLog('OVERLAY_LIFECYCLE', `Content-only overlay created for ${tabName}`, {
        dimensions: `${overlay.style.width} x ${overlay.style.height}`,
        overlayId: overlay.id
      });

      return overlay;
    }

    function updateOverlayContent(contentArea, tabName) {
      let content = '';
      switch (tabName) {
        case 'pets':
          content = getPetsPopoutContent();
          break;
        case 'abilities':
          content = getAbilitiesTabContent();
          break;
        case 'seeds':
          content = getSeedsTabContent();
          break;
        case 'shop':
          content = getShopTabContent();
          break;
        case 'values':
          content = getValuesTabContent();
          break;
        case 'timers':
          content = getTimersTabContent();
          break;
        case 'tools':
          content = getToolsTabContent();
          break;
        case 'rooms':
          content = getRoomStatusTabContent();
          break;
        case 'settings':
          content = getSettingsTabContent();
          break;
        case 'help':
          content = getHelpTabContent();
          break;
        default:
          content = '<p>Tab content not available</p>';
      }

      // Clear existing content except styles
      const styles = contentArea.querySelector('style');
      contentArea.innerHTML = '';
      if (styles) contentArea.appendChild(styles);

      const contentDiv = targetDocument.createElement('div');
      contentDiv.innerHTML = content;
      contentArea.appendChild(contentDiv);

      // Setup handlers if needed
      setTimeout(() => {
        try {
          // Find the parent overlay element
          const parentOverlay = contentArea.closest('.mga-overlay') || contentArea.parentElement;
          debugLog('HANDLER_SETUP', `Setting up handlers for ${tabName}`, {
            overlayFound: !!parentOverlay,
            overlayClass: parentOverlay?.className,
            contentAreaClass: contentArea?.className
          });

          switch (tabName) {
            case 'abilities':
              setupAbilitiesTabHandlers(parentOverlay);
              // Ensure ability logs are populated immediately
              if (parentOverlay) {
                updateAbilityLogDisplay(parentOverlay);
                debugLog('ABILITY_LOGS', 'Populated ability logs for new overlay', {
                  logCount: UnifiedState.data.petAbilityLogs.length,
                  overlayId: parentOverlay?.id || 'no-id'
                });

                // Additional delayed refresh to ensure logs appear
                setTimeout(() => {
                  updateAbilityLogDisplay(parentOverlay);
                  debugLog('ABILITY_LOGS', 'Secondary refresh for ability logs completed');
                }, 500);
              } else {
                debugError(
                  'HANDLER_SETUP',
                  'Could not find parent overlay for ability logs setup',
                  new Error('Parent overlay not found'),
                  { tabName, contentArea }
                );
              }
              break;
            case 'pets':
              setupPetPopoutHandlers(parentOverlay); // Use popout handlers for overlays
              break;
            case 'seeds':
              setupSeedsTabHandlers(parentOverlay);
              break;
            case 'shop':
              setupShopTabHandlers(parentOverlay);
              break;
            case 'settings':
              setupSettingsTabHandlers(parentOverlay);
              break;
            case 'notifications':
              setupNotificationsTabHandlers(parentOverlay);
              break;
          }
        } catch (error) {
          debugError('HANDLER_SETUP', 'Failed to set up overlay handlers', error, {
            tabName,
            contentArea: contentArea?.className,
            hasContent: !!contentArea
          });
        }
      }, 100);
    }

    // INVISIBLE DRAGGING SYSTEM - Entire overlay surface is draggable
    function makeEntireOverlayDraggable(overlay) {
      let isDragging = false;
      const dragOffset = { x: 0, y: 0 };
      let animationFrame = null;
      let dragStartTime = 0;

      debugLog('OVERLAY_LIFECYCLE', 'Setting up invisible dragging for entire overlay', {
        overlayId: overlay.id
      });

      overlay.addEventListener('mousedown', e => {
        // Don't start drag if clicking on interactive elements or resize handle
        if (
          e.target.tagName === 'BUTTON' ||
          e.target.tagName === 'INPUT' ||
          e.target.tagName === 'SELECT' ||
          e.target.closest('.mga-btn') ||
          e.target.classList.contains('mga-resize-handle')
        ) {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        dragStartTime = Date.now();
        isDragging = false; // Start as false, will become true after movement threshold

        const rect = overlay.getBoundingClientRect();
        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;
      });

      document.addEventListener('mousemove', e => {
        if (dragStartTime === 0) return;

        const timeDiff = Date.now() - dragStartTime;
        const mouseMoved = Math.abs(e.clientX - dragOffset.x) > 3 || Math.abs(e.clientY - dragOffset.y) > 3;

        // Start dragging after small movement threshold to prevent accidental drags
        if (!isDragging && mouseMoved && timeDiff > 50) {
          isDragging = true;
          overlay.setAttribute('data-dragging', 'true');

          // Professional drag start effects
          overlay.style.zIndex = '999999';
          overlay.style.transform = 'scale(1.02)';
          overlay.style.filter = 'brightness(1.1)';
          overlay.style.transition = 'transform 0.1s ease, filter 0.1s ease';
          overlay.classList.add('mga-dragging');
          targetDocument.body.style.userSelect = 'none';
          targetDocument.body.style.cursor = 'grabbing !important';

          debugLog('OVERLAY_LIFECYCLE', 'Started invisible dragging', { overlayId: overlay.id });
        }

        if (!isDragging) return;

        // Use RAF for smooth dragging performance
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }

        animationFrame = requestAnimationFrame(() => {
          const rect = overlay.getBoundingClientRect();
          const newX = e.clientX - dragOffset.x;
          const newY = e.clientY - dragOffset.y;

          // Enhanced viewport constraints
          const gameViewport = getGameViewport();

          const constrainedX = Math.max(gameViewport.left, Math.min(newX, gameViewport.right - rect.width));
          const constrainedY = Math.max(gameViewport.top, Math.min(newY, gameViewport.bottom - rect.height));

          overlay.style.left = constrainedX + 'px';
          overlay.style.top = constrainedY + 'px';
        });
      });

      document.addEventListener('mouseup', () => {
        if (dragStartTime > 0) {
          dragStartTime = 0;

          if (isDragging) {
            isDragging = false;
            overlay.removeAttribute('data-dragging');
            overlay.classList.remove('mga-dragging');

            // Professional drag end effects
            overlay.style.transform = 'scale(1)';
            overlay.style.filter = 'brightness(1)';
            overlay.style.zIndex = '999998';
            overlay.style.transition = 'transform 0.2s ease, filter 0.2s ease';

            targetDocument.body.style.userSelect = '';
            targetDocument.body.style.cursor = '';

            if (animationFrame) {
              cancelAnimationFrame(animationFrame);
              animationFrame = null;
            }

            // Save position to localStorage
            saveOverlayPosition(overlay.id, {
              left: overlay.style.left,
              top: overlay.style.top
            });

            debugLog('OVERLAY_LIFECYCLE', 'Finished invisible dragging', {
              overlayId: overlay.id,
              position: { left: overlay.style.left, top: overlay.style.top }
            });
          }
        }
      });
    }

    // Legacy draggable function for windowed overlays (to be replaced)
    function makeOverlayDraggable(overlay, header) {
      let isDragging = false;
      const dragOffset = { x: 0, y: 0 };

      header.addEventListener('mousedown', e => {
        if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons

        isDragging = true;
        const rect = overlay.getBoundingClientRect();
        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;

        overlay.style.zIndex = '999999'; // Bring to front while dragging
        targetDocument.body.style.userSelect = 'none';
        // Ensure proper cursor during drag - use grabbing instead of move
        targetDocument.body.style.cursor = 'grabbing !important';

        e.preventDefault();
      });

      document.addEventListener('mousemove', e => {
        if (!isDragging) return;

        const newX = e.clientX - dragOffset.x;
        const newY = e.clientY - dragOffset.y;

        // Constrain to game viewport
        const gameViewport = getGameViewport();
        const overlayRect = overlay.getBoundingClientRect();

        const constrainedX = Math.max(gameViewport.left, Math.min(newX, gameViewport.right - overlayRect.width));
        const constrainedY = Math.max(gameViewport.top, Math.min(newY, gameViewport.bottom - overlayRect.height));

        overlay.style.left = constrainedX + 'px';
        overlay.style.top = constrainedY + 'px';
      });

      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          targetDocument.body.style.userSelect = '';
          targetDocument.body.style.cursor = ''; // Reset cursor
          overlay.style.zIndex = '999998'; // Return to normal z-index
        }
      });
    }

    function constrainOverlayToViewport(overlay) {
      const observer = new ResizeObserver(() => {
        const gameViewport = getGameViewport();
        const rect = overlay.getBoundingClientRect();

        if (rect.right > gameViewport.right) {
          overlay.style.left = gameViewport.right - rect.width + 'px';
        }
        if (rect.bottom > gameViewport.bottom) {
          overlay.style.top = gameViewport.bottom - rect.height + 'px';
        }
        if (rect.left < gameViewport.left) {
          overlay.style.left = gameViewport.left + 'px';
        }
        if (rect.top < gameViewport.top) {
          overlay.style.top = gameViewport.top + 'px';
        }
      });

      observer.observe(overlay);

      // Also listen for window resize
      window.addEventListener('resize', () => {
        const gameViewport = getGameViewport();
        const rect = overlay.getBoundingClientRect();

        if (rect.right > gameViewport.right) {
          overlay.style.left = gameViewport.right - rect.width + 'px';
        }
        if (rect.bottom > gameViewport.bottom) {
          overlay.style.top = gameViewport.bottom - rect.height + 'px';
        }
      });
    }

    function getGameViewport() {
      // Try to find the game container or use window as fallback
      const gameContainer = document.querySelector('#game-container, #app, .game-wrapper, main') || targetDocument.body;
      const rect = gameContainer.getBoundingClientRect();

      return {
        top: Math.max(0, rect.top),
        left: Math.max(0, rect.left),
        right: Math.min(window.innerWidth, rect.right),
        bottom: Math.min(window.innerHeight, rect.bottom)
      };
    }

    // PROFESSIONAL RESIZE SYSTEM FOR POP-OUTS
    function addResizeHandleToOverlay(overlay) {
      productionLog('üîß [RESIZE DEBUG] Adding resize handle to overlay:', overlay.id);
      debugLog('RESIZE', 'Adding resize handle to overlay', { overlayId: overlay.id });

      // Remove any existing resize handles first to prevent duplicates
      const existingHandle = overlay.querySelector('.mga-resize-handle');
      if (existingHandle) {
        existingHandle.remove();
        productionLog('üîß [RESIZE DEBUG] Removed existing handle before adding new one');
      }

      // Use the unified resize system with overlay-specific options
      makeElementResizable(overlay, {
        minWidth: 180,
        minHeight: 120,
        maxWidth: 450,
        maxHeight: 500,
        showHandleOnHover: true
      });

      // Add save dimensions functionality
      const observer = new MutationObserver(() => {
        if (overlay.style.width && overlay.style.height) {
          saveOverlayDimensions(overlay.id, {
            width: overlay.style.width,
            height: overlay.style.height
          });
        }
      });

      observer.observe(overlay, {
        attributes: true,
        attributeFilter: ['style']
      });

      // Store observer for cleanup later if needed
      overlay._resizeObserver = observer;
    }

    function saveOverlayDimensions(overlayId, dimensions) {
      try {
        const savedDimensions = MGA_loadJSON('MGA_overlayDimensions', {});
        savedDimensions[overlayId] = dimensions;
        MGA_saveJSON('MGA_overlayDimensions', savedDimensions);

        debugLog('OVERLAY_LIFECYCLE', 'Saved overlay dimensions', {
          overlayId,
          dimensions
        });
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to save overlay dimensions', error, {
          overlayId,
          dimensions
        });
      }
    }

    function loadOverlayDimensions(overlay) {
      try {
        const savedDimensions = MGA_loadJSON('MGA_overlayDimensions', {});
        const dimensions = savedDimensions[overlay.id];

        if (dimensions && dimensions.width && dimensions.height) {
          const width = parseInt(dimensions.width);
          const height = parseInt(dimensions.height);

          if (!isNaN(width) && !isNaN(height)) {
            overlay.style.width = dimensions.width;
            overlay.style.height = dimensions.height;

            // Apply responsive scaling for the loaded dimensions
            applyResponsiveTextScaling(overlay, width, height);

            debugLog('OVERLAY_LIFECYCLE', 'Restored overlay dimensions', {
              overlayId: overlay.id,
              dimensions
            });
          }
        }
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to load overlay dimensions', error, {
          overlayId: overlay.id
        });
      }
    }

    // SMART POSITIONING SYSTEM - Professional collision avoidance
    function findOptimalPosition(tabName, gameViewport) {
      const overlayWidth = 240;
      const overlayHeight = 140;
      const margin = 15;
      const mainHudBuffer = 20; // Buffer around main HUD
      const snapGrid = 10; // Snap to 10px increments

      // Check if we have a saved position first
      const savedPositions = MGA_loadJSON('MGA_overlayPositions', {});
      const savedPosition = savedPositions[`mga-overlay-${tabName}`];

      if (savedPosition) {
        const leftPx = parseInt(savedPosition.left);
        const topPx = parseInt(savedPosition.top);

        if (
          !isNaN(leftPx) &&
          !isNaN(topPx) &&
          leftPx >= gameViewport.left &&
          topPx >= gameViewport.top &&
          leftPx + overlayWidth <= gameViewport.right &&
          topPx + overlayHeight <= gameViewport.bottom
        ) {
          // Check for collisions with existing overlays and main HUD
          if (!hasCollisionAtPosition(leftPx, topPx, overlayWidth, overlayHeight)) {
            debugLog('OVERLAY_LIFECYCLE', 'Using saved position with no collisions', {
              tabName,
              position: { left: leftPx, top: topPx }
            });
            return { left: leftPx, top: topPx };
          }
        }
      }

      // Define priority zones (in order of preference)
      const priorityZones = [
        // Zone 1: Right side of game viewport
        {
          name: 'rightSide',
          x: gameViewport.right - overlayWidth - margin,
          y: gameViewport.top + margin,
          maxX: gameViewport.right - margin,
          maxY: gameViewport.bottom - overlayHeight - margin,
          stepX: 0,
          stepY: overlayHeight + margin
        },
        // Zone 2: Left side if right is full
        {
          name: 'leftSide',
          x: gameViewport.left + margin,
          y: gameViewport.top + margin,
          maxX: gameViewport.left + overlayWidth + margin,
          maxY: gameViewport.bottom - overlayHeight - margin,
          stepX: 0,
          stepY: overlayHeight + margin
        },
        // Zone 3: Top area (cascade down)
        {
          name: 'topArea',
          x: gameViewport.left + margin + overlayWidth + margin,
          y: gameViewport.top + margin,
          maxX: gameViewport.right - overlayWidth - margin,
          maxY: gameViewport.top + overlayHeight * 3,
          stepX: overlayWidth + margin,
          stepY: 30
        },
        // Zone 4: Bottom area (cascade up)
        {
          name: 'bottomArea',
          x: gameViewport.left + margin,
          y: gameViewport.bottom - overlayHeight * 3,
          maxX: gameViewport.right - overlayWidth - margin,
          maxY: gameViewport.bottom - overlayHeight - margin,
          stepX: overlayWidth + margin,
          stepY: overlayHeight + margin
        }
      ];

      // Try each priority zone
      for (const zone of priorityZones) {
        const position = findPositionInZone(zone, overlayWidth, overlayHeight, snapGrid, mainHudBuffer);
        if (position) {
          debugLog('OVERLAY_LIFECYCLE', `Found optimal position in ${zone.name}`, {
            tabName,
            position,
            zone: zone.name
          });
          return position;
        }
      }

      // Ultimate fallback with collision avoidance
      let fallbackX = gameViewport.left + margin;
      let fallbackY = gameViewport.top + margin;
      let attempts = 0;

      while (attempts < 20) {
        if (
          !hasCollisionAtPosition(fallbackX, fallbackY, overlayWidth, overlayHeight) &&
          !overlapsMainHUD(fallbackX, fallbackY, overlayWidth, overlayHeight)
        ) {
          break;
        }
        fallbackX += 30;
        fallbackY += 30;

        // Wrap around if we go out of bounds
        if (fallbackX + overlayWidth > gameViewport.right) {
          fallbackX = gameViewport.left + margin;
          fallbackY += overlayHeight + margin;
        }
        if (fallbackY + overlayHeight > gameViewport.bottom) {
          fallbackY = gameViewport.top + margin;
        }
        attempts++;
      }

      debugLog('OVERLAY_LIFECYCLE', 'Using fallback positioning', {
        tabName,
        attempts,
        position: { left: fallbackX, top: fallbackY }
      });
      return {
        left: fallbackX,
        top: fallbackY
      };
    }

    function findPositionInZone(zone, overlayWidth, overlayHeight, snapGrid, mainHudBuffer) {
      let x = zone.x;
      let y = zone.y;

      while (y <= zone.maxY) {
        while (x <= zone.maxX) {
          // Snap to grid
          const snappedX = Math.round(x / snapGrid) * snapGrid;
          const snappedY = Math.round(y / snapGrid) * snapGrid;

          // Check bounds
          if (snappedX + overlayWidth <= zone.maxX && snappedY + overlayHeight <= zone.maxY) {
            // Check collisions with existing overlays and main HUD
            if (
              !hasCollisionAtPosition(snappedX, snappedY, overlayWidth, overlayHeight) &&
              !overlapsMainHUD(snappedX, snappedY, overlayWidth, overlayHeight)
            ) {
              return { left: snappedX, top: snappedY };
            }
          }

          x += zone.stepX || overlayWidth + 15;
          if (zone.stepX === 0) break; // Single column zone
        }
        x = zone.x;
        y += zone.stepY || 30;
      }

      return null;
    }

    function overlapsMainHUD(x, y, width, height) {
      const mainHUD = targetDocument.querySelector('.mga-panel');
      if (!mainHUD) return false;

      const mainHudRect = mainHUD.getBoundingClientRect();
      const buffer = 20; // 20px buffer around main HUD

      // Expand main HUD rect by buffer
      const expandedRect = {
        left: mainHudRect.left - buffer,
        top: mainHudRect.top - buffer,
        right: mainHudRect.right + buffer,
        bottom: mainHudRect.bottom + buffer
      };

      // Check for overlap
      return !(
        x + width < expandedRect.left ||
        x > expandedRect.right ||
        y + height < expandedRect.top ||
        y > expandedRect.bottom
      );
    }

    function hasCollisionAtPosition(x, y, width, height) {
      const existingOverlays = Array.from(targetDocument.querySelectorAll('.mga-overlay-content-only'));
      const buffer = 5; // Minimum spacing between overlays

      for (const existingOverlay of existingOverlays) {
        const rect = existingOverlay.getBoundingClientRect();

        // Check for overlap with buffer
        if (
          !(
            x + width + buffer < rect.left ||
            x - buffer > rect.right ||
            y + height + buffer < rect.top ||
            y - buffer > rect.bottom
          )
        ) {
          return true; // Collision detected
        }
      }
      return false; // No collision
    }

    // OVERLAY POSITION PERSISTENCE SYSTEM
    function saveOverlayPosition(overlayId, position) {
      try {
        const savedPositions = MGA_loadJSON('MGA_overlayPositions', {});
        savedPositions[overlayId] = position;
        MGA_saveJSON('MGA_overlayPositions', savedPositions);

        debugLog('OVERLAY_LIFECYCLE', 'Saved overlay position', {
          overlayId,
          position
        });
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to save overlay position', error, {
          overlayId,
          position
        });
      }
    }

    function loadOverlayPosition(overlay) {
      try {
        const savedPositions = MGA_loadJSON('MGA_overlayPositions', {});
        const position = savedPositions[overlay.id];

        if (position) {
          // Validate position is still within viewport
          const gameViewport = getGameViewport();
          const leftPx = parseInt(position.left);
          const topPx = parseInt(position.top);

          if (
            !isNaN(leftPx) &&
            !isNaN(topPx) &&
            leftPx >= gameViewport.left &&
            topPx >= gameViewport.top &&
            leftPx < gameViewport.right &&
            topPx < gameViewport.bottom
          ) {
            overlay.style.left = position.left;
            overlay.style.top = position.top;

            debugLog('OVERLAY_LIFECYCLE', 'Restored overlay position', {
              overlayId: overlay.id,
              position
            });
          } else {
            debugLog('OVERLAY_LIFECYCLE', 'Saved position out of bounds, using default', {
              overlayId: overlay.id,
              savedPosition: position,
              viewport: gameViewport
            });
          }
        }
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to load overlay position', error, {
          overlayId: overlay.id
        });
      }
    }

    // PROFESSIONAL MINIMIZE/MAXIMIZE FUNCTIONALITY
    function toggleOverlayMinimized(overlay, tabName) {
      const isMinimized = overlay.hasAttribute('data-minimized');
      const contentContainer = overlay.querySelector('.mga-content-container');

      if (isMinimized) {
        // EXPAND - Restore to normal state
        overlay.removeAttribute('data-minimized');
        overlay.style.height = 'auto';
        overlay.style.minHeight = '80px';
        overlay.style.maxHeight = '180px';
        overlay.style.overflow = 'visible'; // Allow resize handles to show

        if (contentContainer) {
          contentContainer.style.display = 'block';
          contentContainer.style.opacity = '1';
        }

        // Update minimize button
        const minimizeBtn = overlay.querySelector('.mga-drag-zone div:last-child');
        if (minimizeBtn) {
          minimizeBtn.innerHTML = '‚îÄ';
          minimizeBtn.title = 'Minimize';
        }

        debugLog('OVERLAY_LIFECYCLE', `Expanded overlay ${tabName}`, {
          overlayId: overlay.id
        });
      } else {
        // MINIMIZE - Collapse to title bar only
        overlay.setAttribute('data-minimized', 'true');
        overlay.style.height = '18px';
        overlay.style.minHeight = '18px';
        overlay.style.maxHeight = '18px';
        overlay.style.overflow = 'visible'; // Allow resize handles to show

        if (contentContainer) {
          contentContainer.style.display = 'none';
          contentContainer.style.opacity = '0';
        }

        // Update minimize button to restore button
        const minimizeBtn = overlay.querySelector('.mga-drag-zone div:last-child');
        if (minimizeBtn) {
          minimizeBtn.innerHTML = '‚ñ°';
          minimizeBtn.title = 'Restore';
        }

        debugLog('OVERLAY_LIFECYCLE', `Minimized overlay ${tabName}`, {
          overlayId: overlay.id
        });
      }

      // Save minimized state
      const overlayStates = MGA_loadJSON('MGA_overlayStates', {});
      overlayStates[overlay.id] = { minimized: !isMinimized };
      MGA_saveJSON('MGA_overlayStates', overlayStates);

      // Add smooth animation
      overlay.style.transition = 'height 0.2s ease, min-height 0.2s ease, max-height 0.2s ease';
      setTimeout(() => {
        overlay.style.transition = '';
      }, 200);
    }

    function loadOverlayState(overlay) {
      try {
        const overlayStates = MGA_loadJSON('MGA_overlayStates', {});
        const state = overlayStates[overlay.id];

        if (state && state.minimized) {
          // Apply minimized state without animation on startup
          overlay.setAttribute('data-minimized', 'true');
          overlay.style.height = '18px';
          overlay.style.minHeight = '18px';
          overlay.style.maxHeight = '18px';
          overlay.style.overflow = 'visible'; // Allow resize handles to show

          const contentContainer = overlay.querySelector('.mga-content-container');
          if (contentContainer) {
            contentContainer.style.display = 'none';
            contentContainer.style.opacity = '0';
          }

          const minimizeBtn = overlay.querySelector('.mga-drag-zone div:last-child');
          if (minimizeBtn) {
            minimizeBtn.innerHTML = '‚ñ°';
            minimizeBtn.title = 'Restore';
          }

          debugLog('OVERLAY_LIFECYCLE', `Loaded minimized state for ${overlay.id}`);
        }
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to load overlay state', error, {
          overlayId: overlay.id
        });
      }
    }

    function closeInGameOverlay(tabName) {
      const overlay = UnifiedState.data.popouts.overlays.get(tabName);
      if (overlay && document.contains(overlay)) {
        overlay.remove();
      }
      UnifiedState.data.popouts.overlays.delete(tabName);

      // Update the corresponding pop-out button state
      updatePopoutButtonStateByTab(tabName, false);

      productionLog(`üóëÔ∏è Closed in-game overlay for ${tabName} tab`);
    }

    function updatePopoutButtonStateByTab(tabName, isActive) {
      const popoutBtn = targetDocument.querySelector(`[data-popout="${tabName}"]`);
      if (popoutBtn) {
        updatePopoutButtonState(popoutBtn, isActive);
      }
    }

    // NEW: Update function for pure content overlays
    function updatePureOverlayContent(overlay, tabName) {
      try {
        debugLog('OVERLAY_LIFECYCLE', `Updating pure overlay content for ${tabName}`, {
          overlayId: overlay.id
        });

        let content = '';
        switch (tabName) {
          case 'pets':
            content = getPetsPopoutContent(); // Use popout version for overlays too
            break;
          case 'abilities':
            content = getAbilitiesTabContent();
            break;
          case 'seeds':
            content = getSeedsTabContent();
            break;
          case 'values':
            content = getValuesTabContent();
            break;
          case 'timers':
            content = getTimersTabContent();
            break;
          case 'settings':
            content = getSettingsTabContent();
            break;
          default:
            content = '<p>Tab content not available</p>';
        }

        // Create the full content with styles (matching createInGameOverlay structure)
        const contentHtml = `
              <style>
                  /* TARGET IMAGE MATCH - Clean, readable styling */
                  /* Section titles are now handled in the main visibility rules above */

                  .mga-overlay-content-only .mga-section {
                      margin: 0 !important;
                      padding: 0 !important;
                  }

                  .mga-overlay-content-only .mga-value-row {
                      display: flex !important;
                      justify-content: space-between !important;
                      margin: 3px 0 !important;
                      padding: 2px 0 !important;
                      line-height: 1.3 !important;
                  }

                  .mga-overlay-content-only .mga-value-label {
                      font-size: 12px !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      font-weight: 400 !important;
                      margin: 0 !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }

                  .mga-overlay-content-only .mga-value-amount {
                      font-size: 13px !important;
                      font-weight: 600 !important;
                      color: #ffffff !important;
                      margin: 0 !important;
                      text-align: right;
                      min-width: 50px;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
                  }

                  /* HIGH CONTRAST TOTAL VALUE */
                  .mga-overlay-content-only .mga-total-value {
                      border-top: 1px solid rgba(255, 255, 255, 0.73) !important;
                      margin-top: 6px !important;
                      padding-top: 4px !important;
                  }

                  .mga-overlay-content-only .mga-total-value .mga-value-label {
                      font-weight: 500 !important;
                      color: rgba(255, 255, 255, 0.95) !important;
                      font-size: 13px !important;
                  }

                  .mga-overlay-content-only .mga-total-value .mga-value-amount {
                      font-size: 14px !important;
                      font-weight: 700 !important;
                      color: #ffff00 !important;
                      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
                  }

                  /* Hide only truly unnecessary elements - KEEP buttons and checkboxes for functionality */
                  .mga-overlay-content-only .mga-section-header,
                  .mga-overlay-content-only .mga-input-group,
                  .mga-overlay-content-only .mga-timer-controls {
                      display: none !important;
                  }

                  /* Keep section titles visible but make them smaller */
                  .mga-overlay-content-only .mga-section-title {
                      display: block !important;
                      font-size: 11px !important;
                      margin-bottom: 4px !important;
                  }

                  /* Readable ability logs */
                  .mga-overlay-content-only .mga-log-item {
                      margin: 2px 0 !important;
                      padding: 2px 0 !important;
                      font-size: 11px !important;
                      line-height: 1.3 !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }

                  .mga-overlay-content-only .mga-log-time {
                      font-size: 10px !important;
                      color: rgba(255, 255, 255, 0.7) !important;
                  }

                  /* Readable pet loadouts */
                  .mga-overlay-content-only .mga-pet-slot {
                      margin: 2px 0 !important;
                      padding: 3px !important;
                      font-size: 11px !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }
              </style>
          `;

        // Update overlay content
        productionLog('üîç [PURE OVERLAY DEBUG] Variables check:', {
          contentHtmlType: typeof contentHtml,
          contentHtmlLength: contentHtml?.length,
          contentType: typeof content,
          contentLength: content?.length,
          contentHtmlPreview: contentHtml?.substring(0, 100),
          contentPreview: content?.substring(0, 100)
        });

        overlay.innerHTML = contentHtml + content;

        // Setup handlers for the overlay
        setupPureOverlayHandlers(overlay, tabName);

        // Re-add resize handle after content update (since innerHTML replaces everything)
        setTimeout(() => {
          if (!overlay.querySelector('.mga-resize-handle')) {
            addResizeHandleToOverlay(overlay);
            productionLog(`üîß [RESIZE] Re-added missing resize handle to ${tabName} pure overlay`);
          }
        }, 50);
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to update pure overlay content', error, {
          tabName,
          overlayId: overlay.id
        });
      }
    }

    function setupPureOverlayHandlers(overlay, tabName) {
      setTimeout(() => {
        try {
          productionLog(`üîß [HANDLER-SETUP] Setting up handlers for ${tabName} overlay`);
          debugLog('HANDLER_SETUP', `Setting up pure overlay handlers for ${tabName}`, {
            overlayId: overlay.id
          });

          switch (tabName) {
            case 'abilities':
              setupAbilitiesTabHandlers(overlay);
              updateAbilityLogDisplay(overlay);
              debugLog('ABILITY_LOGS', 'Set up ability logs for pure overlay', {
                logCount: UnifiedState.data.petAbilityLogs.length,
                overlayId: overlay.id
              });
              break;
            case 'pets':
              setupPetPopoutHandlers(overlay); // Use popout handlers for overlays
              break;
            case 'seeds':
              setupSeedsTabHandlers(overlay);
              break;
            case 'settings':
              setupSettingsTabHandlers(overlay);
              break;
            case 'tools':
              setupToolsTabHandlers(overlay);
              break;
            default:
              break;
          }
        } catch (error) {
          debugError('HANDLER_SETUP', 'Failed to set up pure overlay handlers', error, {
            tabName,
            overlayId: overlay.id
          });
        }
      }, 200); // Increased from 100ms to 200ms to ensure DOM is fully updated
    }

    function refreshOverlayContent(tabName) {
      const overlay = UnifiedState.data.popouts.overlays.get(tabName);
      if (overlay && document.contains(overlay)) {
        // NEW: Handle pure content overlays (no .mga-overlay-content wrapper)
        if (overlay.className.includes('mga-overlay-content-only')) {
          updatePureOverlayContent(overlay, tabName);
          productionLog(`üîÑ Refreshed pure overlay content for ${tabName} tab`);
        } else {
          // LEGACY: Handle old overlay structure if it exists
          const contentArea = overlay.querySelector('.mga-overlay-content');
          if (contentArea) {
            updateOverlayContent(contentArea, tabName);
            productionLog(`üîÑ Refreshed legacy overlay content for ${tabName} tab`);
          }
        }
      }
    }

    // Note: openTabInSeparateWindow is defined earlier at line 7900
    // Legacy wrapper function uses it via openTabInPopout

    // TOGGLE FUNCTIONALITY - Professional pop-out management
    function toggleTabPopout(tabName, buttonElement) {
      const isOverlayMode = UnifiedState.data.settings.useInGameOverlays;

      if (isOverlayMode) {
        // Check if overlay already exists
        const existingOverlay = UnifiedState.data.popouts.overlays.get(tabName);

        if (existingOverlay && document.contains(existingOverlay)) {
          // CLOSE existing overlay
          closeInGameOverlay(tabName);
          updatePopoutButtonState(buttonElement, false);
          debugLog('OVERLAY_LIFECYCLE', `Toggled OFF: ${tabName} overlay closed`);
        } else {
          // OPEN new overlay
          createInGameOverlay(tabName);
          updatePopoutButtonState(buttonElement, true);
          debugLog('OVERLAY_LIFECYCLE', `Toggled ON: ${tabName} overlay opened`);
        }
      } else {
        // For separate windows, always open (can't easily detect if window is open)
        openTabInSeparateWindow(tabName);
        updatePopoutButtonState(buttonElement, true);
        debugLog('OVERLAY_LIFECYCLE', `Opened separate window for ${tabName}`);
      }
    }

    function updatePopoutButtonState(buttonElement, isActive) {
      if (isActive) {
        buttonElement.style.color = '#4CAF50';
        buttonElement.style.transform = 'scale(1.1)';
        buttonElement.style.opacity = '1';
        buttonElement.title = 'Click to close pop-out';
      } else {
        buttonElement.style.color = '';
        buttonElement.style.transform = '';
        buttonElement.style.opacity = '';
        buttonElement.title = 'Click to open in pop-out';
      }
    }

    // Legacy function - Update openTabInPopout to check overlay preference
    function openTabInPopout(tabName) {
      if (UnifiedState.data.settings.useInGameOverlays) {
        return createInGameOverlay(tabName);
      } else {
        return openTabInSeparateWindow(tabName);
      }
    }

    // ==================== TAB CONTENT CACHE SYSTEM ====================
    // Performance optimization: Cache static tab content to reduce regeneration
    const tabContentCache = new Map();
    const TAB_CACHE_DURATION = 30000; // 30 seconds for static tabs

    function getCachedTabContent(tabName, generator) {
      // Never cache dynamic tabs (they need real-time data)
      const dynamicTabs = [
        'pets',
        'abilities',
        'seeds',
        'shop',
        'values',
        'timers',
        'rooms',
        'hotkeys',
        'settings',
        'notifications',
        'protect'
      ];
      if (dynamicTabs.includes(tabName)) {
        return generator();
      }

      // Check cache for static tabs
      const cached = tabContentCache.get(tabName);
      const now = Date.now();

      if (cached && now - cached.timestamp < TAB_CACHE_DURATION) {
        return cached.content;
      }

      // Generate and cache
      const content = generator();
      tabContentCache.set(tabName, { content, timestamp: now });
      return content;
    }

    // Invalidate tab cache (call when settings change)
    function invalidateTabCache(tabName = null) {
      if (tabName) {
        tabContentCache.delete(tabName);
      } else {
        tabContentCache.clear();
      }
    }

    window.MGA_TabCache = { getCachedTabContent, invalidateTabCache };

    let lastActiveTab = null; // Track previous tab for cleanup

    function updateTabContent() {
      const contentEl = getCachedElement('#mga-tab-content') || document.getElementById('mga-tab-content');

      // Safety check - if content element doesn't exist, bail out (normal during initialization)
      if (!contentEl) {
        debugLog('UPDATE_TAB', 'Content element not found, skipping update (UI not ready yet)');
        return;
      }

      // Cleanup when leaving shop tab
      if (lastActiveTab === 'shop' && UnifiedState.activeTab !== 'shop') {
        stopInventoryCounter();
      }
      lastActiveTab = UnifiedState.activeTab;

      // Preserve input state for pets tab to prevent typing interruption
      let preservedInputValue = '';
      let preservedInputFocused = false;
      let preservedCursorPosition = 0;
      if (UnifiedState.activeTab === 'pets') {
        const currentInput = document.getElementById('preset-name-input');
        if (currentInput) {
          preservedInputValue = currentInput.value;
          preservedInputFocused = document.activeElement === currentInput;
          preservedCursorPosition = currentInput.selectionStart || 0;
          if (UnifiedState.data.settings.debugMode) {
            productionLog('üîí Preserving input state:', {
              value: preservedInputValue,
              focused: preservedInputFocused,
              cursor: preservedCursorPosition
            });
          }
        }
      }

      // Add data attribute for CSS targeting
      contentEl.setAttribute('data-active', UnifiedState.activeTab);

      switch (UnifiedState.activeTab) {
        case 'pets': {
          // üîç RENDER CYCLE DEBUG: Track pets tab content generation
          productionLog('üîÑ [RENDER-CYCLE] Starting pets tab content generation', {
            timestamp: new Date().toLocaleTimeString(),
            activeTab: UnifiedState.activeTab,
            atomActivePets: UnifiedState.atoms.activePets?.length || 0,
            windowActivePets: window.activePets?.length || 0,
            renderTrigger: 'updateTabContent'
          });

          const petsHtml = getPetsTabContent();
          productionLog('üîÑ [RENDER-CYCLE] Generated pets HTML', {
            htmlLength: petsHtml.length,
            containsActivePets: petsHtml.includes('Active Pets'),
            containsPetData: petsHtml.includes('mga-pet-'),
            renderStage: 'html-generated'
          });

          contentEl.innerHTML = petsHtml;

          // Check what was actually rendered to DOM
          setTimeout(() => {
            const activePetsElements = contentEl.querySelectorAll('.mga-pet-item');
            productionLog('üîÑ [RENDER-CYCLE] DOM render result', {
              activePetsInDOM: activePetsElements.length,
              elementsFound: activePetsElements.length > 0,
              renderStage: 'dom-updated',
              timestamp: new Date().toLocaleTimeString()
            });
          }, 10);

          setupPetsTabHandlers();

          // Restore input state after HTML regeneration
          if (preservedInputValue || preservedInputFocused) {
            setTimeout(() => {
              const newInput = document.getElementById('preset-name-input');
              if (newInput) {
                newInput.value = preservedInputValue;
                if (preservedInputFocused) {
                  newInput.focus();
                  // Set cursor to preserved position
                  newInput.setSelectionRange(preservedCursorPosition, preservedCursorPosition);
                  if (UnifiedState.data.settings.debugMode) {
                    productionLog('‚úÖ Restored input state:', {
                      value: newInput.value,
                      focused: document.activeElement === newInput
                    });
                  }
                }
              }
            }, 0);
          }
          break;
        }
        case 'abilities':
          contentEl.innerHTML = getAbilitiesTabContent();
          setupAbilitiesTabHandlers();
          updateAbilityLogDisplay();
          break;
        case 'seeds':
          contentEl.innerHTML = getSeedsTabContent();
          setupSeedsTabHandlers(contentEl);
          break;
        case 'shop':
          contentEl.innerHTML = getShopTabContent();
          setupShopTabHandlers(contentEl);
          break;
        case 'values':
          contentEl.innerHTML = getValuesTabContent();
          setupValuesTabHandlers(contentEl);
          break;
        case 'timers':
          contentEl.innerHTML = getTimersTabContent();
          break;
        case 'rooms':
          contentEl.innerHTML = getRoomStatusTabContent();
          contentEl.setAttribute('data-tab', 'rooms'); // BUGFIX v3.7.5: Enable rooms tab to be found by updateRoomStatusDisplay()
          setupRoomJoinButtons();
          setupRoomsTabButtons();
          break;
        case 'tools':
          contentEl.innerHTML = getCachedTabContent('tools', getToolsTabContent);
          setupToolsTabHandlers(contentEl);
          break;
        case 'hotkeys':
          contentEl.innerHTML = getCachedTabContent('hotkeys', getHotkeysTabContent);
          setupHotkeysTabHandlers(contentEl);
          break;
        case 'notifications':
          contentEl.innerHTML = getCachedTabContent('notifications', getNotificationsTabContent);
          setupNotificationsTabHandlers(contentEl);
          break;
        case 'settings':
          productionLog('‚öôÔ∏è [SETTINGS-DEBUG] Settings tab case triggered');
          productionLog('‚öôÔ∏è [SETTINGS-DEBUG] contentEl exists:', !!contentEl);
          contentEl.innerHTML = getCachedTabContent('settings', getSettingsTabContent);
          productionLog('‚öôÔ∏è [SETTINGS-DEBUG] Settings HTML rendered');
          contentEl.setAttribute('data-tab', 'settings'); // Enable settings-specific scrolling
          productionLog(
            '‚öôÔ∏è [SETTINGS-DEBUG] About to call setupSettingsTabHandlers with context:',
            contentEl ? 'contentEl' : 'null'
          );
          setupSettingsTabHandlers(contentEl);
          productionLog('‚öôÔ∏è [SETTINGS-DEBUG] setupSettingsTabHandlers completed');
          break;
        case 'protect':
          contentEl.innerHTML = getCachedTabContent('protect', getProtectTabContent);
          // Wait for browser to parse HTML before attaching handlers
          requestAnimationFrame(() => {
            setupProtectTabHandlers(contentEl);
          });
          break;
        case 'help':
          contentEl.innerHTML = getCachedTabContent('help', getHelpTabContent);
          break;
      }
    }

    // ==================== TAB CONTENTS ====================
    // Simplified pets content for popouts - JUST preset selection
    function getPetsPopoutContent() {
      // Use multiple sources for pet data (same as updateActivePetsDisplay)
      const activePets = UnifiedState.atoms.activePets || window.activePets || [];
      const petPresets = UnifiedState.data.petPresets;

      if (Object.keys(petPresets).length === 0) {
        return `
                  <div class="mga-section">
                      <div class="mga-section-title mga-pet-section-title">Active Pets</div>
                      <div class="mga-active-pets-display">
                          ${
                            activePets.length > 0
                              ? `
                              <div style="color: #93c5fd; font-size: 12px; margin-bottom: 4px;">Currently Equipped:</div>
                              <div class="mga-active-pets-list">
                                  ${activePets
                                    .map((p, index) => {
                                      const timeUntilHungry = calculateTimeUntilHungry(p);
                                      const timerText = formatHungerTimer(timeUntilHungry);
                                      const timerColor =
                                        timeUntilHungry === null
                                          ? '#999'
                                          : timeUntilHungry <= 0
                                            ? '#8B0000'
                                            : timeUntilHungry < 5 * 60 * 1000
                                              ? '#ff4444'
                                              : timeUntilHungry < 15 * 60 * 1000
                                                ? '#ffa500'
                                                : '#4caf50';
                                      return `
                                          <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                              <span class="mga-pet-badge">${p.petSpecies}</span>
                                              <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                          </div>
                                      `;
                                    })
                                    .join('')}
                              </div>
                          `
                              : `
                              <div class="mga-empty-state">
                                  <div class="mga-empty-state-icon">‚Äî</div>
                                  <div class="mga-empty-state-description">No pets currently active</div>
                              </div>
                          `
                          }
                      </div>
                  </div>
                  <div class="mga-section">
                      <div class="mga-empty-state" style="padding: 40px 20px;">
                          <div class="mga-empty-state-icon">üìã</div>
                          <div class="mga-empty-state-title">No Saved Presets</div>
                          <div class="mga-empty-state-description">
                              You haven't saved any pet loadout presets yet.<br>
                              Open the main HUD Pets tab to create presets from your current active pets.
                          </div>
                      </div>
                  </div>
              `;
      }

      let html = `
              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Active Pets</div>
                  <div class="mga-active-pets-display">
                      ${
                        activePets.length > 0
                          ? `
                          <div class="mga-active-pets-header">Currently Equipped:</div>
                          <div class="mga-active-pets-list">
                              ${activePets
                                .map((p, index) => {
                                  const timeUntilHungry = calculateTimeUntilHungry(p);
                                  const timerText = formatHungerTimer(timeUntilHungry);
                                  const timerColor =
                                    timeUntilHungry === null
                                      ? '#999'
                                      : timeUntilHungry <= 0
                                        ? '#8B0000'
                                        : timeUntilHungry < 5 * 60 * 1000
                                          ? '#ff4444'
                                          : timeUntilHungry < 15 * 60 * 1000
                                            ? '#ffa500'
                                            : '#4caf50';
                                  return `
                                      <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                          <span class="mga-pet-badge">${p.petSpecies}</span>
                                          <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                      </div>
                                  `;
                                })
                                .join('')}
                          </div>
                      `
                          : `
                          <div class="mga-empty-state">
                              <div class="mga-empty-state-icon">‚Äî</div>
                              <div class="mga-empty-state-description">No pets currently active</div>
                          </div>
                      `
                      }
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Load Pet Preset</div>
          `;

      // Create clickable preset cards (consistent with main HUD structure) in order
      ensurePresetOrder();
      UnifiedState.data.petPresetsOrder.forEach(name => {
        if (petPresets[name]) {
          const pets = petPresets[name];
          const petList = pets.map(p => p.petSpecies).join(', ');
          html += `
                      <div class="mga-preset mga-preset-clickable" data-preset="${name}">
                          <div class="mga-preset-header">
                              <span class="mga-preset-name">${name}</span>
                          </div>
                          <div class="mga-preset-pets">${petList}</div>
                      </div>
                  `;
        }
      });

      html += `</div>`;
      return html;
    }

    // Setup handlers specifically for pet popout preset buttons
    function setupPetPopoutHandlers(context = document) {
      // Find all preset cards
      const cards = context.querySelectorAll('.mga-preset-clickable[data-preset]');

      // Set up preset card handlers - use cloneNode to ensure clean slate
      cards.forEach((presetCard, index) => {
        // Clone the node to remove ALL event listeners
        const newCard = presetCard.cloneNode(true);
        presetCard.parentNode.replaceChild(newCard, presetCard);

        // Attach fresh handler to the cloned card
        newCard.addEventListener('click', e => {
          const presetName = e.currentTarget.dataset.preset;

          if (!presetName || !UnifiedState.data.petPresets[presetName]) {
            productionWarn('‚ö†Ô∏è Preset not found!');
            return;
          }

          const preset = UnifiedState.data.petPresets[presetName];
          const maxSlots = 3;

          // Native swap approach - works even with full inventory!
          let delay = 0;

          for (let slotIndex = 0; slotIndex < maxSlots; slotIndex++) {
            const desiredPet = preset[slotIndex];

            // BUGFIX: Capture delay value in closure to prevent race conditions
            ((currentDelay, slot) => {
              setTimeout(() => {
                // BUGFIX: Read FRESH state inside timeout (not stale reference)
                const currentPets = UnifiedState.atoms.activePets || window.activePets || [];
                const currentPet = currentPets[slot];

                if (currentPet && desiredPet) {
                  // Check if desired pet is already equipped
                  if (currentPet.id === desiredPet.id) {
                    if (UnifiedState.data.settings?.debugMode) {
                      productionLog(`[PET-SWAP] Slot ${slot + 1}: Already equipped (${currentPet.id}), skipping`);
                    }
                    return; // Skip swap, pet already in place
                  }

                  // Both exist: Use native SwapPet (no inventory space needed!)
                  if (UnifiedState.data.settings?.debugMode) {
                    productionLog(`[PET-SWAP] Slot ${slot + 1}: Swapping ${currentPet.id} ‚Üí ${desiredPet.id}`);
                  }

                  safeSendMessage({
                    scopePath: ['Room', 'Quinoa'],
                    type: 'SwapPet',
                    petSlotId: currentPet.id,
                    petInventoryId: desiredPet.id
                  });
                } else if (!currentPet && desiredPet) {
                  // Empty slot: Place new pet
                  if (UnifiedState.data.settings?.debugMode) {
                    productionLog(`[PET-SWAP] Slot ${slot + 1}: Placing ${desiredPet.id} (empty slot)`);
                  }

                  safeSendMessage({
                    scopePath: ['Room', 'Quinoa'],
                    type: 'PlacePet',
                    itemId: desiredPet.id,
                    position: { x: 17 + slot * 2, y: 13 },
                    localTileIndex: 64,
                    tileType: 'Boardwalk'
                  });
                } else if (currentPet && !desiredPet) {
                  // Remove excess pet (preset has fewer pets)
                  if (UnifiedState.data.settings?.debugMode) {
                    productionLog(`[PET-SWAP] Slot ${slot + 1}: Storing ${currentPet.id} (no preset pet)`);
                  }

                  safeSendMessage({
                    scopePath: ['Room', 'Quinoa'],
                    type: 'StorePet',
                    itemId: currentPet.id
                  });
                }
              }, currentDelay);
            })(delay, slotIndex);

            // Increase delay: 100ms ‚Üí 200ms for better network latency tolerance
            delay += 200;
          }

          // Update displays after all pets are placed (single refresh with retry)
          const refreshPetDisplays = () => {
            // Force update from room state
            updateActivePetsFromRoomState();

            // Get the actual window context, whether we're in main window or popout
            const contextDoc = context.ownerDocument || context;
            const contextWindow = contextDoc.defaultView || window;

            // Check if this is a separate window popout
            const isSeparateWindow = contextWindow !== window && contextWindow.refreshPopoutContent;

            if (isSeparateWindow) {
              // Refresh separate window popout
              contextWindow.refreshPopoutContent('pets');
            } else {
              // It's an in-game overlay or main window - update all popouts
              refreshSeparateWindowPopouts('pets');

              // Update all overlays
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                if (overlay && document.contains(overlay) && tabName === 'pets') {
                  if (overlay.className.includes('mga-overlay-content-only')) {
                    updatePureOverlayContent(overlay, tabName);
                  }
                }
              });

              // Update main tab if active
              if (UnifiedState.activeTab === 'pets') {
                updateTabContent();
              }
            }
          };

          // Refresh after swaps complete + 500ms
          setTimeout(() => {
            refreshPetDisplays();

            // Retry handler reattachment after a short delay to ensure reliability
            setTimeout(() => {
              const overlay = UnifiedState.data.popouts.overlays.get('pets');
              if (overlay && document.contains(overlay)) {
                setupPetPopoutHandlers(overlay);
              }
            }, 500);
          }, delay + 500);

          // Visual feedback - gentle highlight, no transform (prevents stutter)
          // Temporarily disable pointer events to prevent hover conflicts
          e.currentTarget.style.pointerEvents = 'none';
          const originalBackground = e.currentTarget.style.background;
          e.currentTarget.style.background = 'rgba(16, 185, 129, 0.3)';
          setTimeout(() => {
            e.currentTarget.style.background = originalBackground;
            e.currentTarget.style.pointerEvents = '';
          }, 200);
        });
      });

      // Add event delegation for preset action buttons (move-up, move-down, save, place, remove)
      const presetsContainer = context.querySelector('#presets-list');
      if (presetsContainer) {
        // Remove old listener if it exists
        if (presetsContainer._mgaClickHandler) {
          presetsContainer.removeEventListener('click', presetsContainer._mgaClickHandler);
        }

        // Create new handler
        presetsContainer._mgaClickHandler = e => {
          const btn = e.target.closest('[data-action]');
          if (!btn) return;

          e.preventDefault();
          e.stopPropagation();

          const action = btn.dataset.action;
          const presetName = btn.dataset.preset;

          if (action === 'move-up') {
            movePreset(presetName, 'up', context);
          } else if (action === 'move-down') {
            movePreset(presetName, 'down', context);
          } else if (action === 'save') {
            UnifiedState.data.petPresets[presetName] = (UnifiedState.atoms.activePets || []).slice(0, 3);
            MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
            refreshPresetsList(context);
            refreshSeparateWindowPopouts('pets');
          } else if (action === 'place') {
            window.debouncedPlacePetPreset(presetName);
          } else if (action === 'remove') {
            delete UnifiedState.data.petPresets[presetName];
            const saveSuccess = MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);

            // FIX BUG #2 (v3.8.6): Also delete hotkey when preset is deleted
            if (UnifiedState.data.petPresetHotkeys[presetName]) {
              const deletedHotkey = UnifiedState.data.petPresetHotkeys[presetName];
              delete UnifiedState.data.petPresetHotkeys[presetName];
              MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
              console.log(`[MGTOOLS-FIX] ‚úÖ Cleared hotkey "${deletedHotkey}" for deleted preset: ${presetName}`);
            }

            if (!saveSuccess) {
              console.error('‚ùå Failed to save after removing preset');
              alert('‚ö†Ô∏è Failed to save changes! The preset removal may not persist.');
            }
            refreshPresetsList(context);
            refreshSeparateWindowPopouts('pets');
          }
        };

        // Add the handler
        presetsContainer.addEventListener('click', presetsContainer._mgaClickHandler);
      }

      // === EXPORT/IMPORT BUTTON HANDLERS (v3.8.7) ===
      const exportBtn = context.querySelector('#export-presets-btn');
      if (exportBtn && !exportBtn.hasAttribute('data-handler-setup')) {
        exportBtn.setAttribute('data-handler-setup', 'true');
        exportBtn.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
          exportPetPresets();
        });
      }

      const importBtn = context.querySelector('#import-presets-btn');
      if (importBtn && !importBtn.hasAttribute('data-handler-setup')) {
        importBtn.setAttribute('data-handler-setup', 'true');
        importBtn.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
          importPetPresets();
        });
      }
    }

    function getPetsTabContent() {
      // Use multiple sources for pet data (same as updateActivePetsDisplay)
      const activePets = UnifiedState.atoms.activePets || window.activePets || [];
      const petPresets = UnifiedState.data.petPresets;

      productionLog('üêæ [PETS-TAB-CONTENT] Generating HTML with pets:', {
        unifiedStateActivePets: UnifiedState.atoms.activePets?.length || 0,
        windowActivePets: window.activePets?.length || 0,
        finalActivePets: activePets.length,
        activePetsData: activePets
      });

      // Get cycle presets hotkey status
      const cycleHotkey = UnifiedState.data.hotkeys?.mgToolsKeys?.cyclePresets?.custom;
      const totalPresets = Object.keys(petPresets).length;

      let html = `
              ${
                totalPresets > 0
                  ? `
                  <div class="mga-section" style="padding: 8px 12px; background: rgba(139, 92, 246, 0.15); border-left: 3px solid #8b5cf6; margin-bottom: 12px;">
                      <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                          <div style="flex: 1;">
                              <div style="font-size: 11px; color: #a78bfa; font-weight: 600; margin-bottom: 2px;">üîÑ CYCLE PRESETS</div>
                              <div style="font-size: 10px; color: rgba(255,255,255,0.7);">
                                  ${cycleHotkey ? `Hotkey: <span style="background: rgba(139, 92, 246, 0.4); padding: 1px 6px; border-radius: 3px; font-weight: 600;">${cycleHotkey.toUpperCase()}</span>` : 'No hotkey set'}
                              </div>
                          </div>
                          <button class="mga-btn" id="set-cycle-hotkey-btn" style="padding: 4px 12px; font-size: 11px; white-space: nowrap; background: rgba(139, 92, 246, 0.4); border: 1px solid #8b5cf6;">
                              ${cycleHotkey ? 'Change' : 'Set Key'}
                          </button>
                      </div>
                  </div>
              `
                  : ''
              }
              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Active Pets</div>
                  <div class="mga-active-pets-display">
                      ${
                        activePets.length > 0
                          ? `
                          <div class="mga-active-pets-header">Currently Equipped:</div>
                          <div class="mga-active-pets-list">
                              ${activePets
                                .map((p, index) => {
                                  const timeUntilHungry = calculateTimeUntilHungry(p);
                                  const timerText = formatHungerTimer(timeUntilHungry);
                                  const timerColor =
                                    timeUntilHungry === null
                                      ? '#999'
                                      : timeUntilHungry <= 0
                                        ? '#8B0000'
                                        : timeUntilHungry < 5 * 60 * 1000
                                          ? '#ff4444'
                                          : timeUntilHungry < 15 * 60 * 1000
                                            ? '#ffa500'
                                            : '#4caf50';
                                  return `
                                      <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                          <span class="mga-pet-badge">${p.petSpecies}</span>
                                          <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                      </div>
                                  `;
                                })
                                .join('')}
                          </div>
                      `
                          : `
                          <div class="mga-empty-state">
                              <div class="mga-empty-state-icon">‚Äî</div>
                              <div class="mga-empty-state-description">No pets currently active</div>
                          </div>
                      `
                      }
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Quick Load Preset</div>
                  <select class="mga-select" id="preset-quick-select" style="margin-bottom: 8px;">
                      <option value="">-- Select Preset --</option>
                      ${Object.keys(petPresets)
                        .map(
                          name =>
                            `<option value="${name}">${name} (${petPresets[name].map(p => p.petSpecies).join(', ')})</option>`
                        )
                        .join('')}
                  </select>
                  <button class="mga-btn" id="quick-load-btn" style="width: 100%;">Load</button>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Create New Preset</div>
                  <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px; margin-bottom: 8px;">
                      <input type="text" class="mga-input" id="preset-name-input" placeholder="Preset name...">
                      <button class="mga-btn" id="add-preset-btn" style="white-space: nowrap; padding: 6px 24px;">Save Current</button>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Manage Presets</div>

                  <!-- Export/Import Buttons (v3.8.7) -->
                  <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                      <button id="export-presets-btn" class="mga-btn mga-btn-sm" style="flex: 1; background: #10b981; border-color: #059669; padding: 6px 12px;">
                          üì§ Export Backup
                      </button>
                      <button id="import-presets-btn" class="mga-btn mga-btn-sm" style="flex: 1; background: #3b82f6; border-color: #2563eb; padding: 6px 12px;">
                          üì• Import Backup
                      </button>
                  </div>

                  <div id="presets-list" class="mga-scrollable mga-presets-container">
          `;

      // Display presets in order
      ensurePresetOrder();
      UnifiedState.data.petPresetsOrder.forEach(name => {
        if (petPresets[name]) {
          const pets = petPresets[name];
          const hotkey = UnifiedState.data.petPresetHotkeys[name];
          html += `
                      <div class="mga-preset">
                          <div class="mga-preset-header">
                              <span class="mga-preset-name">${name}</span>
                              <button class="mga-hotkey-btn" data-preset="${name}" style="margin-left: auto; padding: 2px 8px; font-size: 11px; background: rgba(100, 200, 255, 0.48); border: 1px solid #4a9eff; border-radius: 4px; color: white; cursor: pointer;">
                                  ${hotkey || 'Set Hotkey'}
                              </button>
                          </div>
                          <div class="mga-preset-pets">${pets.map(p => p.petSpecies).join(', ')}</div>
                          <div class="mga-preset-actions">
                              <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                                  <button class="mga-btn mga-btn-sm" data-action="move-up" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">‚Üë</button>
                                  <button class="mga-btn mga-btn-sm" data-action="move-down" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">‚Üì</button>
                                  <button class="mga-btn mga-btn-sm" data-action="save" data-preset="${name}">Save Current</button>
                              </div>
                              <div style="display: flex; gap: 4px;">
                                  <button class="mga-btn mga-btn-sm" data-action="place" data-preset="${name}">Place</button>
                                  <button class="mga-btn mga-btn-sm" data-action="remove" data-preset="${name}">Remove</button>
                              </div>
                          </div>
                      </div>
                  `;
        }
      });

      html += '</div></div>';

      return html;
    }

    function getAbilitiesTabContent() {
      const logs = UnifiedState.data.petAbilityLogs.slice(0, 30);
      const filterMode = UnifiedState.data.filterMode || 'categories';

      const html = `
              <div class="mga-section">
                  <div class="mga-section-title">Filter Mode</div>
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 8px;">
                      <div style="display: flex; gap: 6px;">
                          <button class="mga-btn mga-btn-sm ${filterMode === 'categories' ? 'active' : ''}" id="filter-mode-categories" style="padding: 6px 12px; font-size: 12px;">Categories</button>
                          <button class="mga-btn mga-btn-sm ${filterMode === 'byPet' ? 'active' : ''}" id="filter-mode-bypet" style="padding: 6px 12px; font-size: 12px;">By Pet</button>
                          <button class="mga-btn mga-btn-sm ${filterMode === 'custom' ? 'active' : ''}" id="filter-mode-custom" style="padding: 6px 12px; font-size: 12px;">Custom</button>
                      </div>
                      <div style="display: flex; gap: 6px;">
                          <button class="mga-btn mga-btn-sm" id="select-all-filters" style="padding: 6px 10px; font-size: 11px;">All</button>
                          <button class="mga-btn mga-btn-sm" id="select-none-filters" style="padding: 6px 10px; font-size: 11px;">None</button>
                      </div>
                  </div>
                  <div id="filter-mode-description" style="font-size: 11px; color: #aaa; margin-bottom: 12px; padding: 6px 10px; background: rgba(255,255,255,0.03); border-radius: 4px;">
                      ${
                        filterMode === 'categories'
                          ? 'üìÇ Filter by ability categories'
                          : filterMode === 'byPet'
                            ? 'üêæ Filter by pet species'
                            : '‚öôÔ∏è Filter by individual abilities'
                      }
                  </div>

                  <!-- Categories Mode -->
                  <div id="category-filters" style="display: ${filterMode === 'categories' ? 'grid' : 'none'}; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.xpBoost ? 'checked' : ''} data-filter="xpBoost" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üí´ XP Boost</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.cropSizeBoost ? 'checked' : ''} data-filter="cropSizeBoost" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üìà Crop Size Boost</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.selling ? 'checked' : ''} data-filter="selling" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üí∞ Selling</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.harvesting ? 'checked' : ''} data-filter="harvesting" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üåæ Harvesting</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.growthSpeed ? 'checked' : ''} data-filter="growthSpeed" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üê¢ Growth Speed</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.specialMutations ? 'checked' : ''} data-filter="specialMutations" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üåà‚ú® Special Mutations</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.other ? 'checked' : ''} data-filter="other" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üîß Other</span>
                      </label>
                  </div>

                  <!-- By Pet Mode -->
                  <div id="pet-filters" style="display: ${filterMode === 'byPet' ? 'block' : 'none'}; margin-bottom: 8px;">
                      <div id="pet-species-list" class="mga-scrollable" style="max-height: 150px; border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; padding: 8px;">
                          <div style="color: #888; text-align: center;">Loading pet species...</div>
                      </div>
                  </div>

                  <!-- Custom Mode -->
                  <div id="custom-filters" style="display: ${filterMode === 'custom' ? 'block' : 'none'}; margin-bottom: 8px;">
                      <div id="individual-abilities-list" class="mga-scrollable" style="max-height: 150px; border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; padding: 8px;">
                          <div style="color: #888; text-align: center;">Loading individual abilities...</div>
                      </div>
                  </div>

                  <div style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
                      <button class="mga-btn mga-btn-sm" id="clear-logs-btn">Clear Logs</button>
                      <button class="mga-btn mga-btn-sm" id="export-logs-btn">Export CSV</button>
                      ${UnifiedState.data.settings?.debugMode ? '<button class="mga-btn mga-btn-sm" id="diagnose-logs-btn" style="background: #ff6b35;">üîç Diagnose Storage</button>' : ''}
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Recent Ability Triggers</div>
                  <div style="margin-bottom: 8px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="detailed-timestamps-checkbox" class="mga-checkbox"
                                 ${UnifiedState.data.settings.detailedTimestamps ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üïê Show detailed timestamps (HH:MM:SS)</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          When enabled, shows detailed 24-hour format timestamps instead of 12-hour format.
                      </p>
                  </div>
                  <div id="ability-logs" class="mga-scrollable" style="max-height: 400px; overflow-y: auto;">
                      ${logs.length === 0 ? '<div style="color: #888; text-align: center; padding: 20px;">No ability logs yet. Ability logs will appear here when your pets trigger abilities in-game.</div>' : ''}
                  </div>
              </div>
          `;

      return html;
    }

    function getSeedsTabContent() {
      debugLog('SEEDS_TAB', 'getSeedsTabContent() called - generating full content');
      productionLog('üîç [SEEDS DEBUG] getSeedsTabContent() called - generating content');
      const seedGroups = [
        { name: 'Common', color: '#fff', seeds: ['Carrot', 'Strawberry', 'Aloe'] },
        { name: 'Uncommon', color: '#0f0', seeds: ['Apple', 'Tulip', 'Tomato', 'Blueberry'] },
        { name: 'Rare', color: '#0af', seeds: ['Daffodil', 'Corn', 'Watermelon', 'Pumpkin', 'Delphinium', 'Squash'] },
        { name: 'Legendary', color: '#ff0', seeds: ['Echeveria', 'Coconut', 'Banana', 'Lily', 'BurrosTail'] },
        { name: 'Mythical', color: '#a0f', seeds: ['Mushroom', 'Cactus', 'Bamboo', 'Grape'] },
        {
          name: 'Divine',
          color: 'orange',
          seeds: ['Sunflower', 'Pepper', 'Lemon', 'PassionFruit', 'DragonFruit', 'Lychee']
        },
        { name: 'Celestial', color: '#ff69b4', seeds: ['Starweaver', 'Moonbinder', 'Dawnbinder'], protected: true }
      ];

      let html = `
              <div class="mga-section">
                  <div class="mga-section-title">Quick Actions</div>
                  <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
                      <button class="mga-btn mga-btn-sm" id="select-all-seeds" style="background: #059669;">Select All</button>
                      <button class="mga-btn mga-btn-sm" id="select-none-seeds" style="background: #dc2626;">Select None</button>
                      <button class="mga-btn mga-btn-sm" id="select-common" style="background: #6b7280;">Common</button>
                      <button class="mga-btn mga-btn-sm" id="select-uncommon" style="background: #059669;">Uncommon</button>
                      <button class="mga-btn mga-btn-sm" id="select-rare" style="background: #0ea5e9;">Rare+</button>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Seed Management</div>
                  <div style="display: flex; gap: 8px; margin-bottom: 12px; align-items: center; flex-wrap: wrap;">
                      <label class="mga-checkbox-group">
                          <input type="checkbox" class="mga-checkbox" id="auto-delete-checkbox">
                          <span class="mga-label">Auto-Delete</span>
                      </label>
                      <button class="mga-btn" id="delete-selected-btn" style="background: #dc2626;">Delete Selected</button>
                      <button class="mga-btn mga-btn-sm" id="calculate-value-btn" style="background: #f59e0b;">Calculate Value</button>
                  </div>
                  <div id="seed-value-display" style="display: none; margin-top: 8px; padding: 8px; background: rgba(245, 158, 11, 0.30); border-radius: 4px;">
                      <div style="font-size: 13px; color: #f59e0b;">Selected Seeds Value: <span id="selected-seeds-value">0</span> üí∞</div>
                  </div>
              </div>
          `;

      // Seed ID mapping for checking saved state (same as setupSeedsTabHandlers)
      const seedIdMap = {
        Carrot: 'Carrot',
        Strawberry: 'Strawberry',
        Aloe: 'Aloe',
        Blueberry: 'Blueberry',
        Apple: 'Apple',
        Tulip: 'OrangeTulip',
        Tomato: 'Tomato',
        Daffodil: 'Daffodil',
        Sunflower: 'Sunflower',
        Corn: 'Corn',
        Watermelon: 'Watermelon',
        Pumpkin: 'Pumpkin',
        Delphinium: 'Delphinium',
        Squash: 'Squash',
        Echeveria: 'Echeveria',
        Coconut: 'Coconut',
        Banana: 'Banana',
        Lily: 'Lily',
        BurrosTail: 'BurrosTail',
        Mushroom: 'Mushroom',
        Cactus: 'Cactus',
        Bamboo: 'Bamboo',
        Grape: 'Grape',
        Pepper: 'Pepper',
        Lemon: 'Lemon',
        PassionFruit: 'PassionFruit',
        DragonFruit: 'DragonFruit',
        Lychee: 'Lychee',
        Starweaver: 'Starweaver',
        Moonbinder: 'Moonbinder',
        Dawnbinder: 'Dawnbinder'
      };

      productionLog('üîç [SEEDS DEBUG] Applying saved state to checkboxes:', {
        savedSeedsToDelete: UnifiedState.data.seedsToDelete,
        savedSeedsCount: UnifiedState.data.seedsToDelete?.length || 0
      });

      seedGroups.forEach(group => {
        html += `
                  <div class="mga-section">
                      <div class="mga-section-title" style="color: ${group.color}">${group.name}</div>
                      <div class="mga-grid">
              `;

        group.seeds.forEach(seed => {
          const isGroupProtected = group.protected === true;
          const isIndividuallyProtected = ['Starweaver', 'Moonbinder', 'Dawnbinder', 'Sunflower'].includes(seed);
          const isProtected = isGroupProtected || isIndividuallyProtected;
          const disabledAttr = isProtected ? 'disabled' : '';
          const protectedStyle = isProtected ? 'opacity: 0.5; cursor: not-allowed;' : '';
          const protectedLabel = isProtected ? ' üîí' : '';

          // Check if this seed should be checked based on saved state
          const internalId = seedIdMap[seed] || seed;
          const isChecked = UnifiedState.data.seedsToDelete?.includes(internalId) || false;
          const checkedAttr = isChecked ? 'checked' : '';

          productionLog(`üîç [SEEDS DEBUG] Seed ${seed} (${internalId}): checked=${isChecked}`);

          html += `
                      <label class="mga-checkbox-group" style="${protectedStyle}">
                          <input type="checkbox" class="mga-checkbox seed-checkbox" data-seed="${seed}" ${disabledAttr} ${checkedAttr}>
                          <span class="mga-label" style="color: ${group.color}">${seed}${protectedLabel}</span>
                      </label>
                  `;
        });

        html += '</div></div>';
      });

      debugLog('SEEDS_TAB', 'getSeedsTabContent() returning HTML', { htmlLength: html.length });
      productionLog('üîç [SEEDS DEBUG] Returning HTML:', {
        htmlLength: html.length,
        htmlPreview: html.substring(0, 200)
      });
      return html;
    }

    // ==================== DUAL SHOP WINDOWS ====================
    let shopWindowsOpen = false;
    let seedShopWindow = null;
    let eggShopWindow = null;
    let shopOverlay = null;
    const shopRenderFunctions = {
      seed: null,
      egg: null
    };

    // Global shop refresh function
    function refreshAllShopWindows() {
      if (shopRenderFunctions.seed) {
        shopRenderFunctions.seed();
      }
      if (shopRenderFunctions.egg) {
        shopRenderFunctions.egg();
      }
    }

    // Make it available globally so atom hooks can call it
    targetWindow.refreshAllShopWindows = refreshAllShopWindows;

    // Shop sprite image map (Discord CDN URLs)
    const SHOP_IMAGE_MAP = {
      // Seeds
      Carrot: 'https://cdn.discordapp.com/emojis/1423010183574982669.webp',
      Strawberry: 'https://cdn.discordapp.com/emojis/1423010222724874330.webp',
      Aloe: 'https://cdn.discordapp.com/emojis/1423010259655590028.webp',
      Blueberry: 'https://cdn.discordapp.com/emojis/1423010283126784010.webp',
      Apple: 'https://cdn.discordapp.com/emojis/1423010302965846046.webp',
      OrangeTulip: 'https://cdn.discordapp.com/emojis/1423010324952514621.webp',
      Tomato: 'https://cdn.discordapp.com/emojis/1423010355109433478.webp',
      Daffodil: 'https://cdn.discordapp.com/emojis/1423010391356866654.webp',
      Corn: 'https://cdn.discordapp.com/emojis/1423010497648656566.webp',
      Watermelon: 'https://cdn.discordapp.com/emojis/1423010520067346515.webp',
      Pumpkin: 'https://cdn.discordapp.com/emojis/1423010546474549338.webp',
      Echeveria: 'https://cdn.discordapp.com/emojis/1423010587910078614.webp',
      Coconut: 'https://cdn.discordapp.com/emojis/1423010611721273444.webp',
      Banana: 'https://cdn.discordapp.com/emojis/1423010652582187089.webp',
      Lily: 'https://cdn.discordapp.com/emojis/1423010686388404407.webp',
      BurrosTail: 'https://cdn.discordapp.com/emojis/1423010714267942912.webp',
      Mushroom: 'https://cdn.discordapp.com/emojis/1423010734002012160.webp',
      Cactus: 'https://cdn.discordapp.com/emojis/1423010755267133531.webp',
      Bamboo: 'https://cdn.discordapp.com/emojis/1423010797830930552.webp',
      Grape: 'https://cdn.discordapp.com/emojis/1423010779522666616.webp',
      Pepper: 'https://cdn.discordapp.com/emojis/1423010818953580574.webp',
      Lemon: 'https://cdn.discordapp.com/emojis/1423010911144120330.webp',
      PassionFruit: 'https://cdn.discordapp.com/emojis/1423010934863171677.webp',
      DragonFruit: 'https://cdn.discordapp.com/emojis/1423010954991370271.webp',
      Lychee: 'https://cdn.discordapp.com/emojis/1423011007206396076.webp',
      Sunflower: 'https://cdn.discordapp.com/emojis/1423010976499765288.webp',
      Starweaver: 'https://cdn.discordapp.com/emojis/1423011042744729700.webp',
      DawnCelestial: 'https://cdn.discordapp.com/emojis/1423011097883185412.webp',
      MoonCelestial: 'https://cdn.discordapp.com/emojis/1423011077410525308.webp',
      // Eggs
      CommonEgg: 'https://cdn.discordapp.com/emojis/1423011628978540676.webp',
      UncommonEgg: 'https://cdn.discordapp.com/emojis/1423011627602804856.webp',
      RareEgg: 'https://cdn.discordapp.com/emojis/1423011625664905316.webp',
      LegendaryEgg: 'https://cdn.discordapp.com/emojis/1423011623089737739.webp',
      MythicalEgg: 'https://cdn.discordapp.com/emojis/1423011620828745899.webp',
      // Tools (Use Discord emojis for proper display)
      WateringCan: 'https://cdn.discordapp.com/emojis/1426622484957888512.webp',
      PlanterPot: 'https://cdn.discordapp.com/emojis/1426622518948794451.webp',
      Shovel: 'https://cdn.discordapp.com/emojis/1426622542222856282.webp',
      'Watering Can': 'https://cdn.discordapp.com/emojis/1426622484957888512.webp',
      'Planter Pot': 'https://cdn.discordapp.com/emojis/1426622518948794451.webp',
      'Garden Shovel': 'https://cdn.discordapp.com/emojis/1426622542222856282.webp'
    };

    // Color groups for item rarity/type
    const SHOP_COLOR_GROUPS = {
      white: ['CommonEgg', 'Carrot', 'Strawberry', 'Aloe'],
      green: ['UncommonEgg', 'Apple', 'OrangeTulip', 'Tomato', 'Blueberry'],
      blue: ['RareEgg', 'Daffodil', 'Corn', 'Watermelon', 'Pumpkin', 'Delphinium', 'Squash'],
      yellow: ['LegendaryEgg', 'Echeveria', 'Coconut', 'Banana', 'Lily', 'BurrosTail'],
      purple: ['MythicalEgg', 'Mushroom', 'Cactus', 'Bamboo', 'Grape'],
      orange: ['Pepper', 'Lemon', 'PassionFruit', 'DragonFruit', 'Lychee', 'Sunflower']
    };

    // Rainbow items (celestial seeds)
    const SHOP_RAINBOW_ITEMS = ['Starweaver', 'DawnCelestial', 'MoonCelestial'];

    // Shop prices (from in-game shop screenshots)
    const SHOP_PRICES = {
      // Seeds - Common tier
      Carrot: 10,
      Strawberry: 50,
      Aloe: 135,
      // Seeds - Uncommon tier
      Blueberry: 400,
      Apple: 500,
      OrangeTulip: 600,
      Tomato: 800,
      // Seeds - Rare tier
      Daffodil: 1000,
      Corn: 1300,
      Delphinium: 1800,
      Squash: 2200,
      Watermelon: 2500,
      Pumpkin: 3000,
      // Seeds - Legendary tier
      Echeveria: 4200,
      Coconut: 6000,
      Banana: 7500,
      Lily: 20000,
      BurrosTail: 93000,
      // Seeds - Mythical tier
      Mushroom: 150000,
      Cactus: 250000,
      Bamboo: 400000,
      Grape: 850000,
      // Seeds - Divine tier
      Pepper: 1000000,
      Lemon: 2000000,
      PassionFruit: 2750000,
      DragonFruit: 5000000,
      Lychee: 25000000,
      Sunflower: 100000000,
      // Seeds - Celestial tier
      Starweaver: 1000000000,
      DawnCelestial: 10000000000,
      MoonCelestial: 50000000000,
      // Eggs
      CommonEgg: 100000,
      UncommonEgg: 1000000,
      RareEgg: 10000000,
      LegendaryEgg: 100000000,
      MythicalEgg: 1000000000,
      // Tools (from game screenshot)
      WateringCan: 3000,
      'Watering Can': 3000,
      PlanterPot: 25000,
      'Planter Pot': 25000,
      GardenShovel: 0, // OWNED - unlimited uses
      'Garden Shovel': 0
    };

    // Format price with k/m/b notation and return color
    function formatShopPrice(price) {
      let formatted, color;
      if (price >= 1000000000) {
        formatted = (price / 1000000000).toFixed(price % 1000000000 === 0 ? 0 : 1) + 'b';
        color = '#4a9eff'; // Blue for billions
      } else if (price >= 1000000) {
        formatted = (price / 1000000).toFixed(price % 1000000 === 0 ? 0 : 1) + 'm';
        color = '#ffd700'; // Gold for millions
      } else if (price >= 1000) {
        formatted = (price / 1000).toFixed(price % 1000 === 0 ? 0 : 1) + 'k';
        color = '#999'; // Grey for thousands
      } else {
        formatted = price.toString();
        color = '#999'; // Grey for under 1000
      }
      return { formatted, color };
    }

    // Normalize string for comparison
    function normalizeShopKey(s) {
      return String(s ?? '')
        .toLowerCase()
        .replace(/[^a-z0-9]/g, '');
    }

    // Get text color class for an item
    function getShopItemColorClass(itemId) {
      const normalized = normalizeShopKey(itemId);

      // Check if rainbow item
      for (const rainbowItem of SHOP_RAINBOW_ITEMS) {
        if (normalized.includes(normalizeShopKey(rainbowItem))) {
          return 'shop-rainbow-text';
        }
      }

      // Check color groups
      const colorKeys = Object.keys(SHOP_COLOR_GROUPS);
      for (let i = 0; i < colorKeys.length; i += 1) {
        const color = colorKeys[i];
        const items = SHOP_COLOR_GROUPS[color];
        for (const item of items) {
          if (normalized === normalizeShopKey(item) || normalized.includes(normalizeShopKey(item))) {
            return `shop-color-${color}`;
          }
        }
      }

      return '';
    }

    // Preload shop images for better performance
    (function preloadShopImages() {
      Object.values(SHOP_IMAGE_MAP).forEach(src => {
        if (!src) return;
        const img = new Image();
        img.src = src;
      });
    })();

    // Flash purchase feedback tooltip
    function flashPurchaseFeedback(el, message, duration = 1500) {
      // Clean up any stuck tooltips first
      try {
        const stuckTooltips = targetDocument.querySelectorAll('.mga-flash-tooltip');
        stuckTooltips.forEach(t => {
          if (t && t.parentNode) t.remove();
        });
      } catch (e) {}

      try {
        if (!el || !(el instanceof Element)) {
          console.warn('flashPurchaseFeedback: invalid element', el);
          showFloatingMsg(message, duration);
          return;
        }

        const rect = el.getBoundingClientRect();
        const msg = targetDocument.createElement('div');
        msg.className = 'mga-flash-tooltip';
        msg.textContent = message;
        msg.setAttribute('role', 'status');
        msg.style.cssText =
          'position:fixed;pointer-events:none;padding:6px 10px;border-radius:8px;font-size:12px;background:rgba(0,0,0,.9);color:#fff;z-index:2147483647;transition:opacity 180ms ease,transform 220ms ease;opacity:0;transform:translateY(-6px);';

        if (rect && rect.width > 0 && rect.height > 0) {
          const left = rect.left + rect.width / 2;
          let top = rect.top - 10;

          if (top < 6) top = rect.bottom + 8;
          msg.style.left = `${Math.round(left)}px`;
          msg.style.top = `${Math.round(top)}px`;
          msg.style.transform += ' translateX(-50%)';
        } else {
          const left = window.innerWidth / 2;
          const top = 20;
          msg.style.left = `${Math.round(left)}px`;
          msg.style.top = `${Math.round(top)}px`;
          msg.style.transform += ' translateX(-50%)';
        }

        targetDocument.body.appendChild(msg);

        // Trigger animation
        requestAnimationFrame(() => {
          msg.style.opacity = '1';
          msg.style.transform = msg.style.transform.replace('translateY(-6px)', 'translateY(0)');
        });

        // Ensure removal with multiple fallbacks
        const removeMsg = () => {
          try {
            if (msg && msg.parentNode) {
              msg.style.opacity = '0';
              msg.style.transform = msg.style.transform.replace('translateY(0)', 'translateY(-6px)');
              setTimeout(() => {
                try {
                  if (msg && msg.parentNode) msg.remove();
                } catch (e) {}
              }, 220);
            }
          } catch (e) {
            try {
              if (msg && msg.parentNode) msg.remove();
            } catch (_) {}
          }
        };

        setTimeout(removeMsg, duration);
      } catch (err) {
        console.error('flashPurchaseFeedback error:', err);
        try {
          showFloatingMsg(message, duration);
        } catch (e) {}
      }
    }

    function showFloatingMsg(msg, dur = 900) {
      const m = targetDocument.createElement('div');
      m.textContent = msg;
      m.style.cssText =
        'position:fixed;left:50%;top:20px;transform:translateX(-50%);background:rgba(0,0,0,.9);color:#fff;padding:6px 10px;border-radius:8px;z-index:2147483647;';
      targetDocument.body.appendChild(m);
      setTimeout(() => m.remove(), dur);
    }

    // Create shop overlay
    function createShopOverlay() {
      if (shopOverlay) return shopOverlay;

      shopOverlay = targetDocument.createElement('div');
      shopOverlay.id = 'mga-shop-overlay';
      targetDocument.body.appendChild(shopOverlay);

      // Click outside to close
      shopOverlay.addEventListener('click', e => {
        if (e.target === shopOverlay) {
          toggleShopWindows();
        }
      });

      return shopOverlay;
    }

    function createShopSidebar(type, title, side) {
      const sidebar = targetDocument.createElement('div');
      sidebar.className = `mga-shop-sidebar mga-shop-sidebar-${side}`;
      sidebar.id = `mga-shop-${type}`;

      // Get current inventory count (includes bag + hotbar)
      const inventory = UnifiedState.atoms.inventory;
      const currentCount = inventory?.items?.length || 0;
      const maxCount = 100; // 91 bag + 9 hotbar = 100 total

      // Color code based on inventory fullness
      let inventoryColor = '#4caf50'; // Green (< 95)
      if (currentCount >= 100) {
        inventoryColor = '#ff4444'; // Red (full)
      } else if (currentCount >= 95) {
        inventoryColor = '#ffa500'; // Yellow (95-99)
      }

      sidebar.innerHTML = `
              <div class="mga-shop-sidebar-header">
                  <h3 style="margin: 0; font-size: 16px; font-weight: 600;">üå± ${title}</h3>
                  <div style="display: flex; gap: 8px; align-items: center;">
                      <button class="shop-refresh-btn" style="cursor: pointer; font-size: 16px; color: #4a9eff; background: none; border: none; padding: 4px 8px; transition: color 0.2s ease;" title="Refresh shop">üîÑ</button>
                      <button class="shop-close-btn" style="cursor: pointer; font-weight: 700; font-size: 20px; color: #cfcfcf; background: none; border: none; padding: 0 8px; transition: color 0.2s ease;">√ó</button>
                  </div>
              </div>

              <!-- NEW v3.7.8: Inventory counter -->
              <div class="shop-inventory-counter" style="
                  font-size: 12px;
                  font-weight: 600;
                  color: ${inventoryColor};
                  margin: 12px 12px 0 12px;
                  padding: 8px 12px;
                  background: rgba(255,255,255,0.05);
                  border-radius: 6px;
                  border-left: 3px solid ${inventoryColor};
                  display: flex;
                  align-items: center;
                  gap: 8px;
              ">
                  <span>üì¶</span>
                  <span>Inventory: <span class="shop-inventory-count">${currentCount}</span>/${maxCount}</span>
              </div>

              <div style="display: flex; flex-direction: column; gap: 8px; padding: 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.57);">
                  <label style="font-size: 12px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                      <input type="checkbox" class="show-available-only" style="accent-color: #2afd23;">
                      <span>Show available only</span>
                  </label>
                  <label style="font-size: 12px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                      <input type="checkbox" class="sort-by-value" style="accent-color: #4a9eff;">
                      <span>Sort by Value</span>
                  </label>
              </div>
              <div class="shop-items-list" style="display: flex; flex-direction: column; gap: 6px; padding: 12px; overflow-y: auto; flex: 1;"></div>
          `;

      targetDocument.body.appendChild(sidebar);

      // Close button handler
      const closeBtn = sidebar.querySelector('.shop-close-btn');
      closeBtn.addEventListener('click', e => {
        e.stopPropagation();
        toggleShopWindows();
      });
      closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.color = '#ff5555';
      });
      closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.color = '#cfcfcf';
      });

      // Refresh button handler (will be fully wired in setupShopWindowHandlers)
      const refreshBtn = sidebar.querySelector('.shop-refresh-btn');
      refreshBtn.addEventListener('mouseenter', () => {
        refreshBtn.style.color = '#6fbfff';
      });
      refreshBtn.addEventListener('mouseleave', () => {
        refreshBtn.style.color = '#4a9eff';
      });

      return sidebar;
    }

    // Update inventory counter displays
    let inventoryUpdateInterval = null;
    let cachedCounterElements = null;
    let cachedCountElements = null;

    function updateInventoryCounters() {
      const inventory = UnifiedState.atoms.inventory;
      const currentCount = inventory?.items?.length || 0;
      const maxCount = 100;

      // Determine color based on fullness
      let inventoryColor = '#4caf50'; // Green
      if (currentCount >= 100) {
        inventoryColor = '#ff4444'; // Red
      } else if (currentCount >= 95) {
        inventoryColor = '#ffa500'; // Yellow
      }

      // Cache DOM elements on first run or if they don't exist
      if (!cachedCountElements || cachedCountElements.length === 0) {
        cachedCountElements = targetDocument.querySelectorAll('.shop-inventory-count, #shop-inventory-count');
      }
      if (!cachedCounterElements || cachedCounterElements.length === 0) {
        cachedCounterElements = targetDocument.querySelectorAll('.shop-inventory-counter, #shop-inventory-counter');
      }

      // Update all inventory counter elements (using cached selectors)
      cachedCountElements.forEach(el => {
        if (el && el.textContent !== String(currentCount)) {
          el.textContent = currentCount;
        }
      });

      // Update counter colors (using cached selectors)
      cachedCounterElements.forEach(el => {
        if (el && el.style.color !== inventoryColor) {
          el.style.color = inventoryColor;
          el.style.borderLeftColor = inventoryColor;
        }
      });
    }

    // Start/stop inventory counter with reference counting
    let inventoryCounterRefs = 0;
    function startInventoryCounter() {
      inventoryCounterRefs++;
      if (inventoryCounterRefs === 1) {
        // First reference - start the interval
        updateInventoryCounters(); // Update immediately
        if (inventoryUpdateInterval) clearInterval(inventoryUpdateInterval);
        inventoryUpdateInterval = setInterval(updateInventoryCounters, 1000); // Optimized: 500ms‚Üí1000ms
      }
    }

    function stopInventoryCounter() {
      inventoryCounterRefs = Math.max(0, inventoryCounterRefs - 1);
      if (inventoryCounterRefs === 0 && inventoryUpdateInterval) {
        // No more references - stop the interval
        clearInterval(inventoryUpdateInterval);
        inventoryUpdateInterval = null;
        // Clear cache so it refreshes next time
        cachedCounterElements = null;
        cachedCountElements = null;
      }
    }

    function toggleShopWindows() {
      if (shopWindowsOpen) {
        // Close both sidebars
        if (seedShopWindow) {
          seedShopWindow.classList.remove('open');
        }
        if (eggShopWindow) {
          eggShopWindow.classList.remove('open');
        }
        shopWindowsOpen = false;

        // Stop inventory counter updates
        stopInventoryCounter();
      } else {
        // Open both sidebars
        if (!seedShopWindow) createShopSidebars();
        seedShopWindow.classList.add('open');
        eggShopWindow.classList.add('open');
        shopWindowsOpen = true;

        // Start inventory counter updates
        startInventoryCounter();
      }
    }

    function createShopSidebars() {
      // Create seed shop sidebar (left)
      seedShopWindow = createShopSidebar('seed', 'Seeds', 'left');
      // Create egg & tool shop sidebar (right)
      eggShopWindow = createShopSidebar('egg', 'Eggs & Tools', 'right');

      // Setup handlers
      setupShopWindowHandlers(seedShopWindow, 'seed');
      setupShopWindowHandlers(eggShopWindow, 'egg'); // This now handles both eggs and tools
    }

    // Escape key handler to close shop windows
    targetDocument.addEventListener('keydown', e => {
      if (e.key === 'Escape' && shopWindowsOpen) {
        toggleShopWindows();
      }
    });

    function createShopWindow(type, title, leftOffset) {
      const window = targetDocument.createElement('div');
      window.className = 'mga-shop-window';
      window.id = `mga-shop-${type}`;

      // Load saved position and size with validation
      const savedPositions = MGA_loadJSON('MGA_shopWindowPositions', {});
      const savedSizes = MGA_loadJSON('MGA_shopWindowSizes', {});
      const savedPos = savedPositions[type] || { left: leftOffset, top: 120 };
      const savedSize = savedSizes[type] || { width: 300, height: 500 };

      // Validate saved position is on screen
      if (savedPos.left < 0 || savedPos.left > window.innerWidth - 100) {
        savedPos.left = leftOffset;
      }
      if (savedPos.top < 0 || savedPos.top > window.innerHeight - 100) {
        savedPos.top = 120;
      }

      // Validate saved size is reasonable
      if (savedSize.width < 250 || savedSize.width > 800) {
        savedSize.width = 300;
      }
      if (savedSize.height < 300 || savedSize.height > 900) {
        savedSize.height = 500;
      }

      window.style.cssText = `
              position: fixed;
              top: ${savedPos.top}px;
              left: ${savedPos.left}px;
              width: ${savedSize.width}px;
              height: ${savedSize.height}px;
              background: rgba(17, 24, 39, 0.98);
              border: 1px solid rgba(255, 255, 255, 0.73);
              border-radius: 8px;
              padding: 12px;
              z-index: 999999;
              overflow-y: auto;
              color: #fff;
              transition: transform 0.3s ease, opacity 0.3s ease;
          `;

      window.innerHTML = `
              <div class="shop-window-header" style="padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid rgba(255, 255, 255, 0.57); cursor: grab;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; position: relative;">
                      <h3 style="margin: 0; font-size: 14px;">üå± ${title}</h3>
                      <button class="shop-close-btn" style="position: absolute; top: -4px; right: -4px; cursor: pointer; font-weight: 700; font-size: 16px; color: #cfcfcf; background: none; border: none; padding: 0 6px; transition: color 0.2s ease;">√ó</button>
                  </div>
                  <div style="display: flex; flex-direction: column; gap: 6px;">
                      <label style="font-size: 11px; display: flex; align-items: center; gap: 4px; cursor: pointer;">
                          <input type="checkbox" class="show-available-only" style="accent-color: #2afd23;">
                          <span>Show available only</span>
                      </label>
                      <label style="font-size: 11px; display: flex; align-items: center; gap: 4px; cursor: pointer;">
                          <input type="checkbox" class="sort-by-value" style="accent-color: #4a9eff;">
                          <span>Sort by Value</span>
                      </label>
                  </div>
              </div>
              <div class="shop-items-list" style="display: flex; flex-direction: column; gap: 6px;"></div>
          `;

      // Append to body (overlay is just a backdrop)
      targetDocument.body.appendChild(window);

      // Add close button handler
      const closeBtn = window.querySelector('.shop-close-btn');
      closeBtn.addEventListener('click', e => {
        e.stopPropagation();
        window.remove();
        // Update state
        if (type === 'seed') {
          seedShopWindow = null;
        } else {
          eggShopWindow = null;
        }
        // If both windows are closed, close overlay and update state
        if (!seedShopWindow && !eggShopWindow) {
          if (shopOverlay) shopOverlay.classList.remove('active');
          shopWindowsOpen = false;
        }
      });
      closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.color = '#ff5555';
      });
      closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.color = '#cfcfcf';
      });

      // Make draggable with type parameter for position saving
      makeShopWindowDraggable(window, window.querySelector('.shop-window-header'), type);

      // Make resizable with size saving
      makeElementResizable(window, {
        minWidth: 250,
        minHeight: 300,
        maxWidth: 600,
        maxHeight: 800,
        showHandleOnHover: true
      });

      // Save size on resize
      const resizeObserver = new ResizeObserver(() => {
        const sizes = MGA_loadJSON('MGA_shopWindowSizes', {});
        sizes[type] = {
          width: window.offsetWidth,
          height: window.offsetHeight
        };
        MGA_saveJSON('MGA_shopWindowSizes', sizes);
      });
      resizeObserver.observe(window);

      return window;
    }

    function makeShopWindowDraggable(element, handle, windowType) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      handle.style.cursor = 'grab';

      handle.addEventListener('mousedown', e => {
        // Don't drag if clicking on interactive elements
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
        // Allow dragging from labels and spans, but not if they contain an input
        if (e.target.tagName === 'LABEL' && e.target.querySelector('input')) return;
        // Don't start drag if clicking resize handle
        if (e.target.classList && e.target.classList.contains('mga-resize-handle')) return;

        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = element.offsetLeft;
        startTop = element.offsetTop;
        handle.style.cursor = 'grabbing';
        element.style.zIndex = '9999999'; // Bring to front while dragging
      });

      targetDocument.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        element.style.left = `${startLeft + dx}px`;
        element.style.top = `${startTop + dy}px`;
      });

      targetDocument.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          handle.style.cursor = 'grab';
          element.style.zIndex = '999999'; // Reset z-index

          // Save position
          const positions = MGA_loadJSON('MGA_shopWindowPositions', {});
          positions[windowType] = {
            left: element.offsetLeft,
            top: element.offsetTop
          };
          MGA_saveJSON('MGA_shopWindowPositions', positions);
        }
      });
    }

    // Shop item constants (moved before first use)
    const SEED_SPECIES_SHOP = [
      'Carrot',
      'Strawberry',
      'Aloe',
      'Blueberry',
      'Apple',
      'OrangeTulip',
      'Tomato',
      'Daffodil',
      'Corn',
      'Watermelon',
      'Pumpkin',
      'Echeveria',
      'Coconut',
      'Banana',
      'Lily',
      'BurrosTail',
      'Mushroom',
      'Cactus',
      'Bamboo',
      'Grape',
      'Pepper',
      'Lemon',
      'PassionFruit',
      'DragonFruit',
      'Lychee',
      'Sunflower',
      'Starweaver',
      'DawnCelestial',
      'MoonCelestial'
    ];

    const EGG_IDS_SHOP = ['CommonEgg', 'UncommonEgg', 'RareEgg', 'LegendaryEgg', 'MythicalEgg'];

    // Display name overrides for shop (keeps internal names intact)
    const SHOP_DISPLAY_NAMES = {
      OrangeTulip: 'Tulip',
      // Tools
      WateringCan: 'Watering Can',
      PlanterPot: 'Planter Pot',
      GardenShovel: 'Garden Shovel'
    };

    function setupShopWindowHandlers(window, type) {
      const itemsList = window.querySelector('.shop-items-list');
      const sortCheckbox = window.querySelector('.sort-by-value');
      const showAvailableCheckbox = window.querySelector('.show-available-only');

      // eslint-disable-next-line no-use-before-define
      const items = type === 'seed' ? SEED_SPECIES_SHOP : EGG_IDS_SHOP;

      function renderItems(sortByValue = false, showAvailableOnly = false) {
        itemsList.innerHTML = '';

        // For egg type, render both eggs and tools with divider
        if (type === 'egg') {
          // Render eggs section
          let eggItemsToRender = EGG_IDS_SHOP.map(id => ({
            id,
            stock: getItemStock(id, 'egg'),
            value: getItemValue(id, 'egg'),
            type: 'egg'
          }));

          if (showAvailableOnly) {
            eggItemsToRender = eggItemsToRender.filter(item => item.stock > 0);
          }

          if (sortByValue) {
            eggItemsToRender.sort((a, b) => b.value - a.value);
          }

          eggItemsToRender.forEach(({ id, stock, value }) => {
            const itemEl = createShopItemElement(id, 'egg', stock, value);
            itemsList.appendChild(itemEl);
          });

          // Get tools from game shop inventory
          const toolShop = targetWindow?.globalShop?.shops?.tool;
          const toolInventory = toolShop?.inventory || [];
          // Only show divider and tools if tools exist
          if (toolInventory.length > 0) {
            // Add professional divider
            const divider = targetDocument.createElement('div');
            divider.style.cssText = `
                          margin: 12px 0;
                          padding: 8px 0;
                          border-top: 1px solid rgba(255, 255, 255, 0.1);
                          border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                          text-align: center;
                          font-size: 11px;
                          font-weight: 600;
                          color: rgba(255, 255, 255, 0.5);
                          text-transform: uppercase;
                          letter-spacing: 1px;
                      `;
            divider.textContent = 'üîß Tools';
            itemsList.appendChild(divider);

            // Render tools dynamically from inventory
            let toolItemsToRender = toolInventory.map((tool, idx) => {
              const toolId = tool.toolId || tool.name || `Tool_${idx}`;

              // Check if player owns Shovel (it's a one-time purchase)
              let isOwned = false;
              let isUnlimited = false;
              if (toolId === 'Shovel' || toolId === 'GardenShovel') {
                // Check player inventory for Shovel ownership
                const playerInventory = targetWindow.myData?.inventory?.items || [];
                isOwned = playerInventory.some(
                  item => item.itemType === 'Tool' && (item.toolId === 'Shovel' || item.toolId === 'GardenShovel')
                );
                if (isOwned) {
                  isUnlimited = true;
                }
              }

              const toolStock = isOwned ? 0 : getItemStock(toolId, 'tool');
              return {
                id: toolId,
                stock: toolStock,
                value: getItemValue(toolId, 'tool'),
                type: 'tool',
                owned: isOwned,
                unlimited: isUnlimited
              };
            });

            if (showAvailableOnly) {
              // Don't filter out owned/unlimited items (like Shovel)
              toolItemsToRender = toolItemsToRender.filter(item => item.stock > 0 || item.owned || item.unlimited);
            }

            if (sortByValue) {
              toolItemsToRender.sort((a, b) => b.value - a.value);
            }

            toolItemsToRender.forEach(({ id, stock, value, owned, unlimited }) => {
              const itemEl = createShopItemElement(id, 'tool', stock, value, { owned, unlimited });
              itemsList.appendChild(itemEl);
            });
          }

          // Show empty state if no items after filtering
          if (eggItemsToRender.length === 0 && toolInventory.length === 0 && showAvailableOnly) {
            itemsList.innerHTML =
              '<div style="color: #888; text-align: center; padding: 20px; font-size: 12px;">No items in stock</div>';
          }
        } else {
          // Render seeds normally
          let itemsToRender = items.map(id => ({
            id,
            stock: getItemStock(id, type),
            value: getItemValue(id, type)
          }));

          if (showAvailableOnly) {
            itemsToRender = itemsToRender.filter(item => item.stock > 0);
          }

          if (sortByValue) {
            itemsToRender.sort((a, b) => b.value - a.value);
          }

          itemsToRender.forEach(({ id, stock, value }) => {
            const itemEl = createShopItemElement(id, type, stock, value);
            itemsList.appendChild(itemEl);
          });

          if (itemsToRender.length === 0 && showAvailableOnly) {
            itemsList.innerHTML =
              '<div style="color: #888; text-align: center; padding: 20px; font-size: 12px;">No items in stock</div>';
          }
        }
      }

      // Load saved checkbox states
      const savedFilters = MGA_loadJSON('MGA_shopFilters', {});
      const savedShowAvailable = savedFilters.showAvailableOnly ?? false;
      const savedSortByValue = savedFilters.sortByValue ?? false;

      sortCheckbox.checked = savedSortByValue;
      showAvailableCheckbox.checked = savedShowAvailable;

      sortCheckbox.addEventListener('change', () => {
        const filters = { showAvailableOnly: showAvailableCheckbox.checked, sortByValue: sortCheckbox.checked };
        MGA_saveJSON('MGA_shopFilters', filters);
        renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
      });

      showAvailableCheckbox.addEventListener('change', () => {
        const filters = { showAvailableOnly: showAvailableCheckbox.checked, sortByValue: sortCheckbox.checked };
        MGA_saveJSON('MGA_shopFilters', filters);
        renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
      });

      // Manual refresh button handler
      const refreshBtn = window.querySelector('.shop-refresh-btn');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
          // Force re-render with latest game data
          renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
        });
      }

      // Smart initial render with loading state
      function isShopDataReady() {
        return !!targetWindow?.globalShop?.shops;
      }

      function showLoadingState() {
        itemsList.innerHTML = `
          <div style="color: #4a9eff; text-align: center; padding: 40px 20px; font-size: 13px;">
            <div style="margin-bottom: 12px; font-size: 24px;">‚è≥</div>
            <div style="font-weight: 600; margin-bottom: 8px;">Loading shop data...</div>
            <div style="font-size: 11px; color: rgba(255, 255, 255, 0.5);">Waiting for game data</div>
          </div>
        `;
      }

      function showTimeoutError() {
        itemsList.innerHTML = `
          <div style="color: #ff6b6b; text-align: center; padding: 40px 20px; font-size: 13px;">
            <div style="margin-bottom: 12px; font-size: 24px;">‚ö†Ô∏è</div>
            <div style="font-weight: 600; margin-bottom: 8px;">Shop data unavailable</div>
            <div style="font-size: 11px; color: rgba(255, 255, 255, 0.5); margin-bottom: 16px;">
              Game data not loaded yet
            </div>
            <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7);">
              Try using the refresh button (üîÑ) or closing and reopening the shop
            </div>
          </div>
        `;
      }

      function waitForShopData(callback, timeout = 5000) {
        const startTime = Date.now();
        const pollInterval = 100; // Check every 100ms

        const poller = setInterval(() => {
          if (isShopDataReady()) {
            clearInterval(poller);
            productionLog(`‚úÖ [SHOP] Shop data ready after ${Date.now() - startTime}ms`);
            callback(true);
          } else if (Date.now() - startTime >= timeout) {
            clearInterval(poller);
            productionWarn(`‚ö†Ô∏è [SHOP] Shop data timeout after ${timeout}ms`);
            callback(false);
          }
        }, pollInterval);
      }

      // Check if shop data is ready on initial render
      if (isShopDataReady()) {
        // Data ready immediately - render normally
        renderItems(savedSortByValue, savedShowAvailable);
      } else {
        // Data not ready - show loading state and wait
        productionLog(`‚è≥ [SHOP] Shop data not ready yet, showing loading state for ${type} shop`);
        showLoadingState();

        waitForShopData(success => {
          if (success) {
            // Data became available - render shop
            renderItems(savedSortByValue, savedShowAvailable);
          } else {
            // Timeout - show error
            showTimeoutError();
          }
        });
      }

      // Store render function for global refresh
      shopRenderFunctions[type] = () => renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);

      // Auto-refresh stock and detect restocks using pattern-based detection
      let lastTimerValue = null;
      let timerWasDecreasing = false;

      setInterval(() => {
        // Check if shop has restocked by watching secondsUntilRestock timer pattern
        const shop = targetWindow?.globalShop?.shops;
        if (shop) {
          const shopData = type === 'seed' ? shop.seed : shop.egg;
          if (shopData && typeof shopData.secondsUntilRestock !== 'undefined') {
            const currentTimer = Number(shopData.secondsUntilRestock) || 0;

            // First reading - initialize tracking
            if (lastTimerValue === null) {
              lastTimerValue = currentTimer;
              return;
            }

            let restockDetected = false;

            // Pattern-based detection: timer naturally decreases, then suddenly increases = restock
            if (currentTimer < lastTimerValue) {
              // Timer decreasing normally (countdown in progress)
              timerWasDecreasing = true;
            } else if (timerWasDecreasing && currentTimer > lastTimerValue + 2) {
              // Timer increased after decreasing - this is the restock pattern!
              // +2 threshold prevents false positives from network jitter
              restockDetected = true;
              timerWasDecreasing = false;

              if (UnifiedState.data.settings.debugMode) {
                console.log(
                  `[SHOP DEBUG] Restock detected for ${type}! Pattern: ${lastTimerValue}s ‚Üí ${currentTimer}s (was decreasing, then increased)`
                );
              }
            }

            lastTimerValue = currentTimer;

            // Refresh UI when restock is detected
            if (restockDetected) {
              // Reset local purchase tracking for this shop type
              resetLocalPurchases(type);

              // Short delay to ensure stock data is stable
              setTimeout(() => {
                renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
              }, 500);
              return; // Skip the immediate render below
            }
          }
        }

        // Normal periodic refresh (no restock detected)
        // In-game purchases are now detected via sendMessage interception
        // ONLY refresh if no buttons are being hovered (prevents flickering)
        const isHovering = itemsList.querySelector('.buy-btn:hover');
        if (!isHovering) {
          renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
        }
      }, 2000); // Check every 2 seconds for better responsiveness
    }

    function createShopItemElement(id, type, stock, value, options = {}) {
      const { owned = false, unlimited = false } = options;

      const div = targetDocument.createElement('div');
      div.className = 'shop-item';
      // Only add 'in-stock' class if actually in stock (not owned)
      if (stock > 0 && !owned) div.classList.add('in-stock');

      div.style.cssText = `
              padding: 8px;
              background: ${stock > 0 && !owned ? 'rgba(76, 255, 106, 0.40)' : 'rgba(255,255,255,0.03)'};
              border: 1px solid ${stock > 0 && !owned ? 'rgba(9, 255, 0, 0.48)' : 'rgba(255, 255, 255, 0.57)'};
              border-radius: 4px;
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 8px;
              transition: all 0.2s ease;
          `;

      const displayName = SHOP_DISPLAY_NAMES[id] || id.replace(/([A-Z])/g, ' $1').trim();
      const spriteUrl = SHOP_IMAGE_MAP[id] || '';
      const colorClass = getShopItemColorClass(id);
      const price = SHOP_PRICES[id] || 0;
      const priceData = formatShopPrice(price);

      // Determine stock display text
      let stockDisplay;
      if (owned || unlimited) {
        // For owned items (like Shovel), just show "OWNED" in neutral color
        stockDisplay = '<span style="color: #888; font-weight: 600;">OWNED</span>';
      } else {
        stockDisplay = `Stock: ${stock} | <span style="color: ${priceData.color};">üí∞${priceData.formatted}</span>`;
      }

      // Get current owned quantity for display
      const ownedCount = getInventoryItemCount(id, type);
      const stackCap = getItemStackCap(id, type);
      let quantityDisplay = '';

      if (stackCap < Infinity && ownedCount > 0) {
        const percentFull = (ownedCount / stackCap) * 100;
        let color = 'rgba(255, 255, 255, 0.7)';

        // Color code based on capacity
        if (percentFull >= 100) {
          color = '#ff4444'; // Red at max
        } else if (percentFull >= 80) {
          color = '#ffaa44'; // Orange at 80%+
        } else if (percentFull >= 50) {
          color = '#ffff44'; // Yellow at 50%+
        }

        quantityDisplay = `<div class="quantity-display" style="font-size: 11px; color: ${color}; margin-top: 2px; font-weight: bold;">Owned: ${ownedCount}/${stackCap}</div>`;
      } else if (ownedCount > 0 && !owned && !unlimited) {
        quantityDisplay = `<div class="quantity-display" style="font-size: 11px; color: rgba(255, 255, 255, 0.7); margin-top: 2px;">Owned: ${ownedCount}</div>`;
      }

      div.innerHTML = `
              <div style="flex: 1; min-width: 0; display: flex; align-items: center; gap: 8px;">
                  ${spriteUrl ? `<img src="${spriteUrl}" alt="${displayName}" class="shop-sprite" loading="lazy">` : ''}
                  <div style="flex: 1; min-width: 0;">
                      <div style="font-size: 12px; font-weight: 600; margin-bottom: 2px;" class="${colorClass}">${displayName}</div>
                      <div class="stock-display" style="font-size: 10px; color: #888;">${stockDisplay}</div>
                      ${quantityDisplay}
                  </div>
              </div>
              <div style="display: ${owned || unlimited ? 'none' : 'flex'}; gap: 4px;">
                  <button class="buy-btn" data-amount="1" ${stock === 0 ? 'disabled' : ''}
                          style="padding: 4px 8px; font-size: 11px; background: rgba(74, 158, 255, 0.3); border: 1px solid rgba(74, 158, 255, 0.5); border-radius: 3px; color: #fff; cursor: ${stock > 0 ? 'pointer' : 'not-allowed'}; transition: all 0.15s ease;">1</button>
                  <button class="buy-btn" data-amount="all" ${stock === 0 ? 'disabled' : ''}
                          style="padding: 4px 8px; font-size: 11px; background: rgba(76, 175, 80, 0.3); border: 1px solid rgba(76, 175, 80, 0.5); border-radius: 3px; color: #fff; cursor: ${stock > 0 ? 'pointer' : 'not-allowed'}; transition: all 0.15s ease;">All</button>
              </div>
          `;

      div.querySelectorAll('.buy-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const amount = btn.dataset.amount === 'all' ? stock : 1;
          buyItem(id, type, amount, div);
        });

        // Add hover effects (NO TRANSFORM - prevents flickering)
        if (stock > 0) {
          btn.addEventListener('mouseenter', () => {
            btn.style.background = 'rgba(9, 255, 0, 0.5)';
            btn.style.borderColor = 'rgba(9, 255, 0, 0.8)';
            btn.style.boxShadow = '0 0 8px rgba(9, 255, 0, 0.4)';
          });
          btn.addEventListener('mouseleave', () => {
            const isAllButton = btn.dataset.amount === 'all';
            btn.style.background = isAllButton ? 'rgba(76, 175, 80, 0.3)' : 'rgba(74, 158, 255, 0.3)';
            btn.style.borderColor = isAllButton ? 'rgba(76, 175, 80, 0.5)' : 'rgba(74, 158, 255, 0.5)';
            btn.style.boxShadow = '';
          });
        }
      });

      return div;
    }

    // Helper function to check if inventory is full (NEW v3.7.8)
    function isInventoryFull() {
      const inventory = UnifiedState.atoms.inventory;
      if (!inventory || !inventory.items) return false;

      // Magic Garden inventory: 91 bag slots + 9 hotbar slots = 100 total
      // inventory.items.length includes BOTH bag and hotbar
      const MAX_INVENTORY = 100;
      const currentCount = inventory.items.length;

      return currentCount >= MAX_INVENTORY;
    }

    // FIX ISSUE C: Count how many of a specific item type are in inventory
    function getInventoryItemCount(itemId, itemType) {
      const inventory = UnifiedState.atoms.inventory;
      if (!inventory || !inventory.items) return 0;

      let count = 0;
      for (const item of inventory.items) {
        if (itemType === 'seed' && item.species === itemId) {
          count += item.quantity || 1;
        } else if (itemType === 'egg' && item.eggId === itemId) {
          count += item.quantity || 1;
        } else if (itemType === 'tool' && item.toolId === itemId) {
          count += item.quantity || 1;
        }
      }

      return count;
    }

    // FIX ISSUE C: Get stack cap for specific items
    function getItemStackCap(itemId, itemType) {
      // Shovel: unlimited uses (can buy 1 at a time, restocks)
      if (itemType === 'tool' && (itemId === 'Shovel' || itemId === 'GardenShovel')) {
        return Infinity; // No cap for Shovel
      }

      // WateringCan: Only item with a cap of 99 (cannot stack in inventory)
      if (itemType === 'tool' && itemId === 'WateringCan') {
        return 99;
      }

      // All other items (PlanterPot, seeds, eggs, etc.): No purchase limit
      return Infinity;
    }

    // Visual feedback for full inventory (NEW v3.7.8)
    function flashInventoryFullFeedback(element, message) {
      // Flash red 3 times
      let flashes = 0;
      const flashInterval = setInterval(() => {
        if (flashes >= 6) {
          // 3 full cycles (on/off)
          clearInterval(flashInterval);
          element.style.background = '';
          element.style.borderColor = '';
          element.style.boxShadow = '';
          return;
        }

        // Alternate between red and normal
        if (flashes % 2 === 0) {
          element.style.background = 'rgba(255, 0, 0, 0.3)';
          element.style.borderColor = 'rgba(255, 0, 0, 0.8)';
          element.style.boxShadow = '0 0 15px rgba(255, 0, 0, 0.5)';
        } else {
          element.style.background = '';
          element.style.borderColor = '';
          element.style.boxShadow = '';
        }

        flashes++;
      }, 200); // Flash every 200ms

      // Show message
      productionLog(`‚ùå [SHOP] ${message}`);
    }

    function buyItem(id, type, amount, itemEl) {
      const conn = targetWindow.MagicCircle_RoomConnection;
      if (!conn?.sendMessage) {
        alert('Connection not available');
        return;
      }

      // SMART INVENTORY CHECK: Only block if truly full
      // For stackable items, check if we already have the item (can stack more)
      // For non-stackable items (Produce, Pets), check if inventory is full
      const inventory = UnifiedState.atoms.inventory;
      const hasExistingStack = inventory?.items?.some(item => {
        if (type === 'seed') return item.species === id && item.itemType !== 'Produce';
        if (type === 'egg') return item.eggId === id;
        if (type === 'tool') return item.toolId === id || item.name === id;
        return false;
      });

      // If inventory is full AND we don't have an existing stack, block purchase
      if (isInventoryFull() && !hasExistingStack) {
        flashInventoryFullFeedback(itemEl, `Inventory Full! (100/100) - Cannot purchase new items`);
        if (UnifiedState.data.settings?.debugMode) {
          console.log(`[SHOP] Purchase blocked: Inventory full and no existing stack for ${id}`);
        }
        return;
      }

      // If we have an existing stack, the quantity cap check will handle it
      if (hasExistingStack && UnifiedState.data.settings?.debugMode) {
        console.log(`[SHOP] ‚úÖ Inventory full but ${id} can stack on existing item`);
      }

      // FIX ISSUE C: Check if at item stack cap before purchase
      const currentCount = getInventoryItemCount(id, type);
      const stackCap = getItemStackCap(id, type);

      if (currentCount >= stackCap) {
        const displayName = SHOP_DISPLAY_NAMES[id] || id.replace(/([A-Z])/g, ' $1').trim();

        // Special visual feedback for items at max quantity
        if (stackCap < Infinity) {
          flashInventoryFullFeedback(
            itemEl,
            `${displayName} at MAX! (${currentCount}/${stackCap}) - Cannot purchase more`
          );

          // Update the item display to show current quantity persistently
          const quantityDisplay = itemEl.querySelector('.quantity-display');
          if (quantityDisplay) {
            quantityDisplay.textContent = `Owned: ${currentCount}/${stackCap}`;
            quantityDisplay.style.color = '#ff4444';
            quantityDisplay.style.fontWeight = 'bold';
          }
        } else {
          flashInventoryFullFeedback(itemEl, `${displayName} at max capacity! (${currentCount}/${stackCap})`);
        }

        if (UnifiedState.data.settings?.debugMode) {
          console.log(`[MGTOOLS-FIX-C] ‚ùå Purchase blocked: ${id} at cap (${currentCount}/${stackCap})`);
        }
        return;
      }

      // FIX ISSUE C: Check if purchasing would exceed cap
      if (currentCount + amount > stackCap) {
        const displayName = SHOP_DISPLAY_NAMES[id] || id.replace(/([A-Z])/g, ' $1').trim();
        const canPurchase = stackCap - currentCount;
        flashInventoryFullFeedback(
          itemEl,
          `Can only purchase ${canPurchase} more ${displayName} (currently ${currentCount}/${stackCap})`
        );
        if (UnifiedState.data.settings?.debugMode) {
          console.log(
            `[MGTOOLS-FIX-C] ‚ùå Purchase blocked: would exceed cap (${currentCount} + ${amount} > ${stackCap})`
          );
        }
        return;
      }

      if (UnifiedState.data.settings?.debugMode) {
        console.log(`[MGTOOLS-FIX-C] ‚úÖ Purchase allowed: ${id} (${currentCount} + ${amount} <= ${stackCap})`);
      }

      try {
        for (let i = 0; i < amount; i++) {
          let messageType, itemKey;

          if (type === 'seed') {
            messageType = 'PurchaseSeed';
            itemKey = 'species';
          } else if (type === 'egg') {
            messageType = 'PurchaseEgg';
            itemKey = 'eggId';
          } else if (type === 'tool') {
            messageType = 'PurchaseTool';
            itemKey = 'toolId';
          }

          conn.sendMessage({
            scopePath: ['Room', 'Quinoa'],
            type: messageType,
            [itemKey]: id
          });
        }

        // Purchase tracking happens automatically in sendMessage intercept
        const displayName = id.replace(/([A-Z])/g, ' $1').trim();
        flashPurchaseFeedback(itemEl, `Purchased x${amount} ${displayName}`);
        productionLog(`‚úÖ Purchased ${amount}x ${id}`);

        // Update stock display - game automatically updates window.bought.shopPurchases
        setTimeout(() => {
          const newStock = getItemStock(id, type);
          const stockSpan = itemEl.querySelector('.stock-display');
          if (stockSpan) {
            const priceData = formatShopPrice(SHOP_PRICES[id] || 0);
            stockSpan.innerHTML = `Stock: ${newStock} | <span style="color: ${priceData.color};">üí∞${priceData.formatted}</span>`;
          }

          // Update quantity display
          const quantityDiv = itemEl.querySelector('.quantity-display');
          if (quantityDiv) {
            const ownedCount = getInventoryItemCount(id, type);
            const stackCap = getItemStackCap(id, type);

            if (stackCap < Infinity && ownedCount > 0) {
              const percentFull = (ownedCount / stackCap) * 100;
              let color = 'rgba(255, 255, 255, 0.7)';

              if (percentFull >= 100) {
                color = '#ff4444';
              } else if (percentFull >= 80) {
                color = '#ffaa44';
              } else if (percentFull >= 50) {
                color = '#ffff44';
              }

              quantityDiv.style.color = color;
              quantityDiv.style.fontWeight = percentFull >= 100 ? 'bold' : 'normal';
              quantityDiv.textContent = `Owned: ${ownedCount}/${stackCap}`;
            } else if (ownedCount > 0) {
              quantityDiv.textContent = `Owned: ${ownedCount}`;
            }
          }

          if (UnifiedState.data.settings.debugMode) {
            console.log(`[SHOP DEBUG] Stock updated for ${id}: ${newStock} (using game's purchase data)`);
          }

          // Update in-stock styling
          if (newStock === 0) {
            itemEl.classList.remove('in-stock');
            itemEl.style.background = 'rgba(255,255,255,0.03)';
            itemEl.style.borderColor = 'rgba(255, 255, 255, 0.57)';
            // Disable buttons
            itemEl.querySelectorAll('.buy-btn').forEach(btn => {
              btn.disabled = true;
              btn.style.cursor = 'not-allowed';
            });
          } else {
            itemEl.classList.add('in-stock');
            itemEl.style.background = 'rgba(76, 255, 106, 0.40)';
            itemEl.style.borderColor = 'rgba(9, 255, 0, 0.48)';
          }
        }, 100);
      } catch (e) {
        console.error('Purchase error:', e);
        alert('Purchase failed');
      }
    }

    function getItemStock(id, type) {
      try {
        const shop = targetWindow?.globalShop?.shops;
        if (!shop) return 0;

        let inventory, item;

        if (type === 'seed') {
          inventory = shop.seed?.inventory;
          if (!inventory) return 0;
          item = inventory.find(i => i.species === id);
        } else if (type === 'egg') {
          inventory = shop.egg?.inventory;
          if (!inventory) return 0;
          item = inventory.find(i => i.eggId === id);
        } else if (type === 'tool') {
          inventory = shop.tool?.inventory;
          if (!inventory) return 0;
          // Tools use toolId property - also check with/without spaces for compatibility
          const idNoSpaces = id.replace(/\s+/g, '');
          item = inventory.find(
            i =>
              i.toolId === id ||
              i.name === id ||
              i.toolId?.replace(/\s+/g, '') === idNoSpaces ||
              i.name?.replace(/\s+/g, '') === idNoSpaces
          );
        } else {
          return 0;
        }

        if (!item) return 0;

        // initialStock is a snapshot that only updates on restock
        // We must subtract local purchases to get current stock
        const initial = item.initialStock || item.stock || 0;
        // Cap purchased count to initial - can't have purchased more than what was available
        // This prevents stale localStorage data from showing incorrect stock
        const purchased = Math.min(getLocalPurchaseCount(id, type), initial);

        const stock = Math.max(0, initial - purchased);
        return stock;
      } catch (e) {
        productionError('[SHOP] getItemStock error:', e);
        return 0;
      }
    }

    function getItemValue(id, type) {
      // Placeholder - you can integrate with your value system
      const valueMap = {
        // Seeds (approximate values)
        MoonCelestial: 50000,
        DawnCelestial: 45000,
        Starweaver: 40000,
        Lychee: 8000,
        DragonFruit: 7000,
        PassionFruit: 6000,
        Sunflower: 5000,
        Lemon: 4000,
        Pepper: 3500,
        Grape: 3000,
        Bamboo: 2500,
        Cactus: 2000,
        Mushroom: 1800,
        BurrosTail: 1500,
        Lily: 1200,
        Banana: 1000,
        Coconut: 900,
        Echeveria: 800,
        Pumpkin: 600,
        Watermelon: 500,
        Corn: 400,
        Daffodil: 300,
        Tomato: 250,
        OrangeTulip: 200,
        Apple: 150,
        Blueberry: 100,
        Aloe: 80,
        Strawberry: 60,
        Carrot: 40,
        // Eggs
        MythicalEgg: 10000,
        LegendaryEgg: 5000,
        RareEgg: 1000,
        UncommonEgg: 200,
        CommonEgg: 50,
        // Tools (placeholder values - these will be replaced with actual game values)
        Shovel: 500,
        WateringCan: 300,
        Fertilizer: 200
      };
      return valueMap[id] || 100;
    }

    function formatValue(value) {
      if (value >= 1000) return `${(value / 1000).toFixed(1)}k`;
      return value.toString();
    }

    // Local purchase tracking for immediate UI updates (persisted across page refreshes)
    let localPurchaseTracker = {
      seed: {},
      egg: {},
      tool: {}
    };

    // Load persisted purchase tracker from storage
    function loadPurchaseTracker() {
      try {
        const saved = MGA_loadJSON('MGA_purchaseTracker');
        if (saved && typeof saved === 'object') {
          localPurchaseTracker = {
            seed: saved.seed || {},
            egg: saved.egg || {},
            tool: saved.tool || {}
          };
          console.log('üì¶ [LOCAL-TRACK] Loaded purchase tracker:', {
            seeds: Object.keys(localPurchaseTracker.seed).length,
            eggs: Object.keys(localPurchaseTracker.egg).length,
            tools: Object.keys(localPurchaseTracker.tool).length,
            toolData: localPurchaseTracker.tool
          });
        }
      } catch (e) {
        console.error('[LOCAL-TRACK] Error loading purchase tracker:', e);
      }
    }

    // Save purchase tracker to storage
    function savePurchaseTracker() {
      try {
        MGA_saveJSON('MGA_purchaseTracker', localPurchaseTracker);
      } catch (e) {
        console.error('[LOCAL-TRACK] Error saving purchase tracker:', e);
      }
    }

    // Load on script start
    loadPurchaseTracker();

    // Debug flag to only search for purchase atoms once
    const purchaseAtomsSearched = false;

    // Function to track a local purchase
    function trackLocalPurchase(id, type, amount = 1) {
      if (!localPurchaseTracker[type][id]) {
        localPurchaseTracker[type][id] = 0;
      }
      localPurchaseTracker[type][id] += amount;

      productionLog(
        `üìù [LOCAL-TRACK] Recorded ${amount}x ${id} (${type}). Total local: ${localPurchaseTracker[type][id]}`
      );

      // Persist to storage
      savePurchaseTracker();
    }

    // Function to get local purchase count
    function getLocalPurchaseCount(id, type) {
      // Check exact match first
      if (localPurchaseTracker[type][id]) {
        return localPurchaseTracker[type][id];
      }

      // For tools, also check with/without spaces for compatibility
      if (type === 'tool') {
        const idNoSpaces = id.replace(/\s+/g, '');
        const typeKeys = Object.keys(localPurchaseTracker[type]);
        for (let i = 0; i < typeKeys.length; i += 1) {
          const key = typeKeys[i];
          const keyNoSpaces = key.replace(/\s+/g, '');
          if (keyNoSpaces === idNoSpaces) {
            return localPurchaseTracker[type][key];
          }
        }
      }

      return 0;
    }

    // Function to reset local purchases when shop restocks
    function resetLocalPurchases(type = null) {
      if (type) {
        localPurchaseTracker[type] = {};
        productionLog(`üîÑ [LOCAL-TRACK] Reset ${type} purchases for restock`);
      } else {
        localPurchaseTracker.seed = {};
        localPurchaseTracker.egg = {};
        localPurchaseTracker.tool = {};
        productionLog(`üîÑ [LOCAL-TRACK] Reset all purchases for restock`);
      }

      // Persist to storage
      savePurchaseTracker();
    }

    // ==================== SHOP TAB (DEPRECATED - USING DUAL WINDOWS NOW) ====================
    function getShopTabContent() {
      const settings = UnifiedState.data.settings;

      // Get current inventory count (includes bag + hotbar)
      const inventory = UnifiedState.atoms.inventory;
      const currentCount = inventory?.items?.length || 0;
      const maxCount = 100; // 91 bag + 9 hotbar = 100 total

      // Color code based on inventory fullness
      let inventoryColor = '#4caf50'; // Green (< 95)
      if (currentCount >= 100) {
        inventoryColor = '#ff4444'; // Red (full)
      } else if (currentCount >= 95) {
        inventoryColor = '#ffa500'; // Yellow (95-99)
      }

      return `
              <div class="mga-section">
                  <div class="mga-section-title">üõí Shop</div>
                  <p style="font-size: 12px; color: #aaa; margin-bottom: 8px;">
                      Quick buy seeds and eggs. Stock updates automatically when shop resets.
                  </p>

                  <!-- NEW v3.7.8: Inventory counter -->
                  <div id="shop-inventory-counter" style="
                      font-size: 13px;
                      font-weight: 600;
                      color: ${inventoryColor};
                      margin-bottom: 16px;
                      padding: 8px 12px;
                      background: rgba(255,255,255,0.05);
                      border-radius: 6px;
                      border-left: 3px solid ${inventoryColor};
                      display: flex;
                      align-items: center;
                      gap: 8px;
                  ">
                      <span>üì¶</span>
                      <span>Inventory: <span id="shop-inventory-count">${currentCount}</span>/${maxCount}</span>
                  </div>

                  <div style="margin-bottom: 20px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                          <input type="checkbox" id="shop-in-stock-only" class="mga-checkbox">
                          <span>Show only items in stock</span>
                      </label>
                  </div>

                  <div id="shop-seed-section" style="margin-bottom: 24px;">
                      <h3 style="font-size: 14px; margin-bottom: 12px; color: #fff;">üå± Seeds</h3>
                      <div id="shop-seed-list" style="display: grid; gap: 6px;"></div>
                  </div>

                  <div id="shop-egg-section">
                      <h3 style="font-size: 14px; margin-bottom: 12px; color: #fff;">ü•ö Eggs</h3>
                      <div id="shop-egg-list" style="display: grid; gap: 6px;"></div>
                  </div>
              </div>
          `;
    }

    function setupShopTabHandlers(context) {
      let contextLocal = context;
      if (!contextLocal) contextLocal = targetDocument;

      const inStockCheckbox = contextLocal.querySelector('#shop-in-stock-only');
      const seedList = contextLocal.querySelector('#shop-seed-list');
      const eggList = contextLocal.querySelector('#shop-egg-list');

      if (!seedList || !eggList) return;

      // Start inventory counter updates for shop tab
      startInventoryCounter();

      // Seed/Egg item definition
      const SEED_SPECIES = [
        'Carrot',
        'Strawberry',
        'Aloe',
        'Blueberry',
        'Apple',
        'OrangeTulip',
        'Tomato',
        'Daffodil',
        'Corn',
        'Watermelon',
        'Pumpkin',
        'Echeveria',
        'Coconut',
        'Banana',
        'Lily',
        'BurrosTail',
        'Mushroom',
        'Cactus',
        'Bamboo',
        'Grape',
        'Pepper',
        'Lemon',
        'PassionFruit',
        'DragonFruit',
        'Lychee',
        'Sunflower',
        'Starweaver',
        'DawnCelestial',
        'MoonCelestial'
      ];

      const EGG_IDS = ['CommonEgg', 'UncommonEgg', 'RareEgg', 'LegendaryEgg', 'MythicalEgg'];

      // Create shop items
      function createShopItem(id, type) {
        const item = targetDocument.createElement('div');
        item.className = 'shop-item';
        item.dataset.itemId = id;
        item.dataset.itemType = type;
        item.style.cssText = `
                  padding: 10px;
                  background: rgba(255,255,255,0.03);
                  border: 1px solid rgba(255, 255, 255, 0.57);
                  border-radius: 6px;
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  gap: 10px;
                  transition: all 0.2s ease;
              `;

        const displayName = SHOP_DISPLAY_NAMES[id] || id.replace(/([A-Z])/g, ' $1').trim();
        const stock = getItemStock(id, type);

        item.innerHTML = `
                  <div style="flex: 1; min-width: 0;">
                      <div style="font-weight: 600; font-size: 13px; color: #fff; margin-bottom: 2px;">${displayName}</div>
                      <div class="stock-display" style="font-size: 11px; color: #888;">Stock: ${stock}</div>
                  </div>
                  <div style="display: flex; gap: 6px;">
                      <button class="mga-btn mga-btn-secondary buy-one" ${stock === 0 ? 'disabled' : ''}
                              style="padding: 6px 12px; font-size: 12px;">Buy 1</button>
                      <button class="mga-btn mga-btn-secondary buy-all" ${stock === 0 ? 'disabled' : ''}
                              style="padding: 6px 12px; font-size: 12px;">Buy All</button>
                  </div>
              `;

        if (stock > 0) {
          item.style.background = 'rgba(76, 255, 106, 0.40)';
          item.style.borderColor = 'rgba(9, 255, 0, 0.48)';
        }

        // Event handlers
        item.querySelector('.buy-one').addEventListener('click', () => buyItem(id, type, 1, item));
        item.querySelector('.buy-all').addEventListener('click', () => buyItem(id, type, stock, item));

        return item;
      }

      function getItemStock(id, type) {
        try {
          const shop = targetWindow?.globalShop?.shops;
          if (!shop) return 0;

          const inventory = type === 'seed' ? shop.seed?.inventory : shop.egg?.inventory;
          if (!inventory) return 0;

          const item = inventory.find(i => {
            const itemId = type === 'seed' ? i.species : i.eggId;
            return itemId === id;
          });

          if (!item) return 0;

          // initialStock is a snapshot that only updates on restock
          // We must subtract local purchases to get current stock
          const initial = item.initialStock || 0;
          // Cap purchased count to initial - can't have purchased more than what was available
          // This prevents stale localStorage data from showing incorrect stock
          const purchased = Math.min(getLocalPurchaseCount(id, type), initial);
          const stock = Math.max(0, initial - purchased);

          return stock;
        } catch (e) {
          productionError('[SHOP-TAB] getItemStock error:', e);
          return 0;
        }
      }

      function buyItem(id, type, amount, itemEl) {
        const conn = targetWindow.MagicCircle_RoomConnection;
        if (!conn?.sendMessage) {
          alert('Connection not available');
          return;
        }

        // SMART INVENTORY CHECK: Only block if truly full
        // For stackable items, check if we already have the item (can stack more)
        // For non-stackable items (Produce, Pets), check if inventory is full
        const inventory = UnifiedState.atoms.inventory;
        const hasExistingStack = inventory?.items?.some(item => {
          if (type === 'seed') return item.species === id && item.itemType !== 'Produce';
          if (type === 'egg') return item.eggId === id;
          if (type === 'tool') return item.toolId === id || item.name === id;
          return false;
        });

        // If inventory is full AND we don't have an existing stack, block purchase
        if (isInventoryFull() && !hasExistingStack) {
          flashInventoryFullFeedback(itemEl, `Inventory Full! (100/100) - Cannot purchase new items`);
          console.log(`[SHOP] Purchase blocked: Inventory full and no existing stack for ${id}`);
          return;
        }

        // If we have an existing stack, the quantity cap check will handle it
        if (hasExistingStack) {
          console.log(`[SHOP] ‚úÖ Inventory full but ${id} can stack on existing item`);
        }

        // FIX ISSUE C: Check if at item stack cap before purchase
        const currentCount = getInventoryItemCount(id, type);
        const stackCap = getItemStackCap(id, type);

        if (currentCount >= stackCap) {
          const displayName = SHOP_DISPLAY_NAMES[id] || id.replace(/([A-Z])/g, ' $1').trim();

          // Special visual feedback for items at max quantity
          if (stackCap < Infinity) {
            flashInventoryFullFeedback(
              itemEl,
              `${displayName} at MAX! (${currentCount}/${stackCap}) - Cannot purchase more`
            );

            // Update the item display to show current quantity persistently
            const quantityDisplay = itemEl.querySelector('.quantity-display');
            if (quantityDisplay) {
              quantityDisplay.textContent = `Owned: ${currentCount}/${stackCap}`;
              quantityDisplay.style.color = '#ff4444';
              quantityDisplay.style.fontWeight = 'bold';
            }
          } else {
            flashInventoryFullFeedback(itemEl, `${displayName} at max capacity! (${currentCount}/${stackCap})`);
          }

          if (UnifiedState.data.settings?.debugMode) {
            console.log(`[MGTOOLS-FIX-C] ‚ùå Purchase blocked: ${id} at cap (${currentCount}/${stackCap})`);
          }
          return;
        }

        // FIX ISSUE C: Check if purchasing would exceed cap
        if (currentCount + amount > stackCap) {
          const displayName = SHOP_DISPLAY_NAMES[id] || id.replace(/([A-Z])/g, ' $1').trim();
          const canPurchase = stackCap - currentCount;
          flashInventoryFullFeedback(
            itemEl,
            `Can only purchase ${canPurchase} more ${displayName} (currently ${currentCount}/${stackCap})`
          );
          if (UnifiedState.data.settings?.debugMode) {
            console.log(
              `[MGTOOLS-FIX-C] ‚ùå Purchase blocked: would exceed cap (${currentCount} + ${amount} > ${stackCap})`
            );
          }
          return;
        }

        if (UnifiedState.data.settings?.debugMode) {
          console.log(`[MGTOOLS-FIX-C] ‚úÖ Purchase allowed: ${id} (${currentCount} + ${amount} <= ${stackCap})`);
        }

        try {
          for (let i = 0; i < amount; i++) {
            let messageType, itemKey;

            if (type === 'seed') {
              messageType = 'PurchaseSeed';
              itemKey = 'species';
            } else if (type === 'egg') {
              messageType = 'PurchaseEgg';
              itemKey = 'eggId';
            } else if (type === 'tool') {
              messageType = 'PurchaseTool';
              itemKey = 'toolId';
            }

            conn.sendMessage({
              scopePath: ['Room', 'Quinoa'],
              type: messageType,
              [itemKey]: id
            });
          }

          // Purchase tracking happens automatically in sendMessage intercept

          // Update UI
          setTimeout(() => {
            const newStock = getItemStock(id, type);
            const stockDisplay = itemEl.querySelector('.stock-display');
            if (stockDisplay) stockDisplay.textContent = `Stock: ${newStock}`;

            // Update quantity display
            const quantityDiv = itemEl.querySelector('.quantity-display');
            if (quantityDiv) {
              const ownedCount = getInventoryItemCount(id, type);
              const stackCap = getItemStackCap(id, type);

              if (stackCap < Infinity && ownedCount > 0) {
                const percentFull = (ownedCount / stackCap) * 100;
                let color = 'rgba(255, 255, 255, 0.7)';

                if (percentFull >= 100) {
                  color = '#ff4444';
                } else if (percentFull >= 80) {
                  color = '#ffaa44';
                } else if (percentFull >= 50) {
                  color = '#ffff44';
                }

                quantityDiv.style.color = color;
                quantityDiv.style.fontWeight = percentFull >= 100 ? 'bold' : 'normal';
                quantityDiv.textContent = `Owned: ${ownedCount}/${stackCap}`;
              } else if (ownedCount > 0) {
                quantityDiv.textContent = `Owned: ${ownedCount}`;
              }
            }

            const buttons = itemEl.querySelectorAll('button');
            buttons.forEach(btn => (btn.disabled = newStock === 0));

            if (newStock === 0) {
              itemEl.style.background = 'rgba(255,255,255,0.03)';
              itemEl.style.borderColor = 'rgba(255, 255, 255, 0.57)';
            }

            applyStockFilter();
          }, 100);

          productionLog(`‚úÖ Purchased ${amount}x ${id}`);
        } catch (e) {
          console.error('Purchase error:', e);
          alert('Purchase failed');
        }
      }

      function applyStockFilter() {
        if (!inStockCheckbox) return;
        const showOnlyInStock = inStockCheckbox.checked;

        context.querySelectorAll('.shop-item').forEach(item => {
          const id = item.dataset.itemId;
          const type = item.dataset.itemType;
          const stock = getItemStock(id, type);
          item.style.display = showOnlyInStock && stock === 0 ? 'none' : 'flex';
        });
      }

      // Initialize shop
      SEED_SPECIES.forEach(species => {
        seedList.appendChild(createShopItem(species, 'seed'));
      });

      EGG_IDS.forEach(eggId => {
        eggList.appendChild(createShopItem(eggId, 'egg'));
      });

      if (inStockCheckbox) {
        inStockCheckbox.addEventListener('change', applyStockFilter);
      }

      // Auto-refresh on shop update
      const refreshInterval = setInterval(() => {
        if (!context.querySelector('#shop-seed-list')) {
          clearInterval(refreshInterval);
          return;
        }

        context.querySelectorAll('.shop-item').forEach(item => {
          const id = item.dataset.itemId;
          const type = item.dataset.itemType;
          const newStock = getItemStock(id, type);
          const stockDisplay = item.querySelector('.stock-display');
          if (stockDisplay) stockDisplay.textContent = `Stock: ${newStock}`;

          const buttons = item.querySelectorAll('button');
          buttons.forEach(btn => (btn.disabled = newStock === 0));

          if (newStock > 0) {
            item.style.background = 'rgba(76, 255, 106, 0.40)';
            item.style.borderColor = 'rgba(9, 255, 0, 0.48)';
          } else {
            item.style.background = 'rgba(255,255,255,0.03)';
            item.style.borderColor = 'rgba(255, 255, 255, 0.57)';
          }
        });

        applyStockFilter();
      }, 2000);
    }

    function getValuesTabContent() {
      // eslint-disable-next-line no-use-before-define
      const valueManager = globalValueManager || initializeValueManager();
      const tileValue = valueManager.getTileValue();
      const gardenValue = valueManager.getGardenValue();
      const inventoryValue = valueManager.getInventoryValue();

      return `
              <div class="mga-section">
                  <div class="mga-section-title">üí∞ Garden Values</div>
                  <div class="mga-value-compact" style="
                      display: grid;
                      grid-template-columns: 1fr auto;
                      column-gap: 12px;
                      row-gap: 4px;
                      font-size: 13px;
                      line-height: 1.5;
                  ">
                      <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Tile value:</div>
                      <div class="overlay-val" style="text-align: right; color: #4a9eff; font-weight: bold; min-width: 90px; word-break: keep-all;">${tileValue.toLocaleString()}</div>

                      <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Inventory value:</div>
                      <div class="overlay-val" style="text-align: right; color: #f59e0b; font-weight: bold; min-width: 90px; word-break: keep-all;">${inventoryValue.toLocaleString()}</div>

                      <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Garden value:</div>
                      <div class="overlay-val" style="text-align: right; color: #10b981; font-weight: bold; min-width: 90px; word-break: keep-all;">${gardenValue.toLocaleString()}</div>
                  </div>
              </div>

              <div class="mga-section" style="margin-top: 16px;">
                  <div class="mga-section-title" style="display: flex; align-items: center; justify-content: space-between;">
                      <span>üåü Auto-Favorite</span>
                      <label class="switch" style="margin-left: auto;">
                          <input type="checkbox" id="auto-favorite-enabled" ${UnifiedState.data.settings.autoFavorite.enabled ? 'checked' : ''}>
                          <span class="slider"></span>
                      </label>
                  </div>
                  <div style="margin-top: 8px;">
                      <div style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                          Automatically favorite these species when added to inventory:
                      </div>
                      <div id="auto-favorite-species" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 16px; max-height: 300px; overflow-y: auto; padding-right: 8px;">
                          ${[
                            'Carrot',
                            'Strawberry',
                            'Aloe',
                            'Blueberry',
                            'Apple',
                            'OrangeTulip',
                            'Tomato',
                            'Daffodil',
                            'Corn',
                            'Watermelon',
                            'Pumpkin',
                            'Echeveria',
                            'Coconut',
                            'Banana',
                            'Lily',
                            'BurrosTail',
                            'Mushroom',
                            'Cactus',
                            'Bamboo',
                            'Grape',
                            'Pepper',
                            'Lemon',
                            'PassionFruit',
                            'DragonFruit',
                            'Lychee',
                            'Sunflower',
                            'Starweaver',
                            'DawnCelestial',
                            'MoonCelestial'
                          ]
                            .map(
                              species => `
                                  <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; cursor: pointer; user-select: none;">
                                      <input type="checkbox" value="${species}"
                                          ${UnifiedState.data.settings.autoFavorite.species.includes(species) ? 'checked' : ''}
                                          style="cursor: pointer;">
                                      <span style="color: #e5e7eb;">${species.replace('OrangeTulip', 'Tulip').replace('DawnCelestial', 'Dawnbinder').replace('MoonCelestial', 'Moonbinder')}</span>
                                  </label>
                              `
                            )
                            .join('')}
                      </div>
                      <div style="font-size: 11px; color: #aaa; margin-bottom: 12px; border-top: 1px solid rgba(255, 255, 255, 0.57); padding-top: 12px;">
                          Automatically favorite items with these mutations:
                      </div>
                      <div id="auto-favorite-mutations" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                          ${[
                            'Rainbow',
                            'Gold',
                            'Frozen',
                            'Wet',
                            'Chilled',
                            'Dawnlit',
                            'Amberlit',
                            'Dawnbound',
                            'Amberbound'
                          ]
                            .map(
                              mutation => `
                                  <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer; user-select: none;">
                                      <input type="checkbox" value="${mutation}"
                                          ${UnifiedState.data.settings.autoFavorite.mutations.includes(mutation) ? 'checked' : ''}
                                          style="cursor: pointer;">
                                      <span style="color: #e5e7eb;">${mutation}</span>
                                  </label>
                              `
                            )
                            .join('')}
                      </div>
                      <div style="font-size: 11px; color: #aaa; margin-bottom: 12px; border-top: 1px solid rgba(255, 255, 255, 0.57); padding-top: 12px;">
                          Automatically favorite pets with these abilities:
                      </div>
                      <div id="auto-favorite-pet-abilities" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                          ${['Rainbow Granter', 'Gold Granter']
                            .map(
                              ability => `
                                  <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer; user-select: none;">
                                      <input type="checkbox" value="${ability}"
                                          ${(UnifiedState.data.settings.autoFavorite.petAbilities || []).includes(ability) ? 'checked' : ''}
                                          style="cursor: pointer;">
                                      <span style="color: #e5e7eb;">${ability}</span>
                                  </label>
                              `
                            )
                            .join('')}
                      </div>
                  </div>
              </div>
          `;
    }

    function setupValuesTabHandlers(context = document) {
      // Helper function to save auto-favorite settings with dual-backend persistence
      const saveAutoFavoriteSettings = () => {
        // Save entire UnifiedState
        MGA_saveJSON('MGA_data', UnifiedState.data);

        // Also save auto-favorite settings separately for redundancy
        try {
          const autoFavData = JSON.stringify(UnifiedState.data.settings.autoFavorite);
          localStorage.setItem('mgtools_auto_favorites', autoFavData);
          logDebug('AUTO-FAV', 'Saved auto-favorites to localStorage backup');
        } catch (e) {
          logWarn('AUTO-FAV', 'Failed to save localStorage backup', e);
        }
      };

      // Auto-favorite toggle
      const autoFavoriteToggle = context.querySelector('#auto-favorite-enabled');
      if (autoFavoriteToggle) {
        autoFavoriteToggle.addEventListener('change', e => {
          UnifiedState.data.settings.autoFavorite.enabled = e.target.checked;
          saveAutoFavoriteSettings();
          productionLog(`üåü Auto-favorite ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }

      // Species checkboxes
      const speciesCheckboxes = context.querySelectorAll('#auto-favorite-species input[type="checkbox"]');
      speciesCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          const species = e.target.value;
          if (e.target.checked) {
            if (!UnifiedState.data.settings.autoFavorite.species.includes(species)) {
              UnifiedState.data.settings.autoFavorite.species.push(species);
            }
            // Immediately favorite all existing items of this species
            if (targetWindow.favoriteSpecies) {
              targetWindow.favoriteSpecies(species);
            }
          } else {
            UnifiedState.data.settings.autoFavorite.species = UnifiedState.data.settings.autoFavorite.species.filter(
              s => s !== species
            );
            // Immediately unfavorite all existing items of this species
            if (targetWindow.unfavoriteSpecies) {
              targetWindow.unfavoriteSpecies(species);
            }
          }
          saveAutoFavoriteSettings();
        });
      });

      // Mutation checkboxes
      const mutationCheckboxes = context.querySelectorAll('#auto-favorite-mutations input[type="checkbox"]');
      mutationCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          const mutation = e.target.value;
          if (e.target.checked) {
            if (!UnifiedState.data.settings.autoFavorite.mutations.includes(mutation)) {
              UnifiedState.data.settings.autoFavorite.mutations.push(mutation);
            }
            // Immediately favorite all existing items with this mutation
            if (targetWindow.favoriteMutation) {
              targetWindow.favoriteMutation(mutation);
            }
          } else {
            UnifiedState.data.settings.autoFavorite.mutations =
              UnifiedState.data.settings.autoFavorite.mutations.filter(m => m !== mutation);
            // Immediately unfavorite all existing items with this mutation
            if (targetWindow.unfavoriteMutation) {
              targetWindow.unfavoriteMutation(mutation);
            }
          }
          saveAutoFavoriteSettings();
        });
      });

      // Pet ability checkboxes
      const petAbilityCheckboxes = context.querySelectorAll('#auto-favorite-pet-abilities input[type="checkbox"]');
      petAbilityCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          const ability = e.target.value;

          // DEFENSIVE: Ensure petAbilities array exists (v2.0.0 fix for upgrade path)
          if (!UnifiedState.data.settings.autoFavorite.petAbilities) {
            UnifiedState.data.settings.autoFavorite.petAbilities = [];
            productionLog('üîß [AUTO-FAVORITE-PET] Initialized petAbilities array');
          }

          if (e.target.checked) {
            productionLog(`‚úÖ [AUTO-FAVORITE-PET] Checkbox CHECKED for ${ability}`);

            if (!UnifiedState.data.settings.autoFavorite.petAbilities.includes(ability)) {
              UnifiedState.data.settings.autoFavorite.petAbilities.push(ability);
            }
            // Immediately favorite all existing pets with this ability
            if (targetWindow.favoritePetAbility) {
              targetWindow.favoritePetAbility(ability);
            }
          } else {
            productionLog(
              `‚¨ú [AUTO-FAVORITE-PET] Checkbox UNCHECKED for ${ability} - disabling auto-favorite (existing favorites preserved)`
            );

            UnifiedState.data.settings.autoFavorite.petAbilities =
              UnifiedState.data.settings.autoFavorite.petAbilities.filter(a => a !== ability);
            // Never unfavorite - only disable future auto-favoriting
            if (targetWindow.unfavoritePetAbility) {
              targetWindow.unfavoritePetAbility(ability);
            }
          }
          saveAutoFavoriteSettings();

          productionLog(
            `üíæ [AUTO-FAVORITE-PET] Settings saved. Current pet abilities:`,
            UnifiedState.data.settings.autoFavorite.petAbilities
          );
        });
      });
    }

    function getTimersTabContent() {
      return `
              <div class="mga-section">
                  <div class="mga-section-title">Restock Timers</div>
                  <div class="mga-timer">
                      <div class="mga-timer-label">Seed Restock</div>
                      <div class="mga-timer-value" id="timer-seed">--:--</div>
                  </div>
                  <div class="mga-timer">
                      <div class="mga-timer-label">Egg Restock</div>
                      <div class="mga-timer-value" id="timer-egg">--:--</div>
                  </div>
                  <div class="mga-timer">
                      <div class="mga-timer-label">Tool Restock</div>
                      <div class="mga-timer-value" id="timer-tool">--:--</div>
                  </div>
                  <div class="mga-timer" style="background: rgba(147, 51, 234, 0.30); border-color: rgba(147, 51, 234, 0.3);">
                      <div class="mga-timer-label">Lunar Event</div>
                      <div class="mga-timer-value" id="timer-lunar" style="color: #9333ea;">--:--</div>
                  </div>
              </div>
          `;
    }

    function getRoomStatusTabContent() {
      const currentRoom = getCurrentRoomCode();
      const roomCounts = UnifiedState.data.roomStatus?.counts || {};
      const activeRoomsTab = UnifiedState.data.activeRoomsTab || 'mg'; // BUGFIX v3.7.3: Default to MG rooms (more useful for browser users)

      // Helper function to render room card
      const renderRoomCard = (room, allowDelete = false, allowDrag = false) => {
        // Try name first (Discord rooms stored as 'PLAY1'), fallback to id (MG rooms stored as 'MG1')
        const count = roomCounts[room.name?.toUpperCase()] || roomCounts[room.id] || 0;
        const displayCount = Math.min(count, 6);
        const isCurrentRoom = room.id === currentRoom;

        // Color based on player count
        let statusColor = '#94a3b8'; // Gray for empty
        if (count > 0) statusColor = '#4ade80'; // Green for active
        if (count >= 4) statusColor = '#fbbf24'; // Yellow for busy
        if (count >= 6) statusColor = '#ef4444'; // Red for full

        const bgColor = isCurrentRoom ? 'rgba(59, 130, 246, 0.40)' : 'rgba(255, 255, 255, 0.03)';
        const borderColor = isCurrentRoom ? '#3b82f6' : 'rgba(255, 255, 255, 0.57)';

        return `
                  <div class="room-item" ${allowDrag ? 'draggable="true"' : ''} data-room="${room.id}" style="
                      display: flex;
                      align-items: center;
                      justify-content: space-between;
                      padding: 12px;
                      background: ${bgColor};
                      border: 1px solid ${borderColor};
                      border-radius: 6px;
                      transition: all 0.2s;
                      cursor: ${allowDrag ? 'grab' : 'default'} !important;
                      user-select: none;
                  ">
                      <div style="display: flex; align-items: center; gap: 12px; flex: 1; cursor: ${allowDrag ? 'grab' : 'default'} !important;">
                          ${allowDrag ? '<span style="color: #666; font-size: 16px; cursor: grab !important;" title="Drag to reorder">‚ãÆ‚ãÆ</span>' : ''}
                          <span style="
                              font-weight: bold;
                              color: ${isCurrentRoom ? '#60a5fa' : '#e5e7eb'};
                              font-size: 14px;
                              min-width: ${allowDrag ? '45px' : '70px'};
                              cursor: ${allowDrag ? 'grab' : 'default'} !important;
                          ">${room.name || room.id}</span>
                          <span style="
                              font-weight: bold;
                              color: ${statusColor};
                              font-size: 13px;
                              min-width: 50px;
                              cursor: ${allowDrag ? 'grab' : 'default'} !important;
                          ">${displayCount}/6 ${isCurrentRoom ? '(You)' : ''}</span>
                      </div>
                      <div style="display: flex; gap: 8px; align-items: center;">
                          <button class="mga-button room-join-btn" data-room="${room.id}" style="
                              padding: 6px 14px;
                              font-size: 12px;
                              background: ${isCurrentRoom ? '#666' : '#4a9eff'};
                              color: white;
                              border: none;
                              border-radius: 4px;
                              cursor: ${isCurrentRoom ? 'not-allowed' : 'pointer'} !important;
                              opacity: ${isCurrentRoom ? '0.5' : '1'};
                          " ${isCurrentRoom ? 'disabled' : ''}>
                              ${isCurrentRoom ? 'Current' : 'Join'}
                          </button>
                          ${
                            allowDelete
                              ? `
                          <button class="room-delete-btn" data-room="${room.id}" style="
                              padding: 6px 10px;
                              font-size: 14px;
                              background: #ef4444;
                              color: white;
                              border: none;
                              border-radius: 4px;
                              cursor: pointer !important;
                              opacity: 0.8;
                              transition: opacity 0.2s;
                          " title="Remove room from list">
                              ‚ùå
                          </button>`
                              : ''
                          }
                      </div>
                  </div>
              `;
      };

      // Get MG & Custom rooms
      const mgAndCustomRooms = RoomRegistry.getMGAndCustomRooms();

      return `
              <div class="mga-section">
                  <div class="mga-section-title">üéÆ Live Room Status</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Real-time player counts for Magic Garden rooms. Add custom rooms to track, or browse official MG1-10 servers.
                  </p>

                  <!-- Tab Selector (BUGFIX v3.7.3: MG tab first, Discord second) -->
                  <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 2px solid rgba(255,255,255,0.1);">
                      <button class="rooms-tab-btn" data-tab="mg" style="
                          flex: 1;
                          padding: 10px;
                          background: ${activeRoomsTab === 'mg' ? 'rgba(34, 197, 94, 0.3)' : 'transparent'};
                          border: none;
                          border-bottom: 2px solid ${activeRoomsTab === 'mg' ? '#22c55e' : 'transparent'};
                          color: ${activeRoomsTab === 'mg' ? '#fff' : '#aaa'};
                          font-size: 13px;
                          font-weight: bold;
                          cursor: pointer;
                          transition: all 0.2s;
                          border-radius: 4px 4px 0 0;
                      ">
                          üåü MG & Custom
                      </button>
                      <button class="rooms-tab-btn" data-tab="discord" style="
                          flex: 1;
                          padding: 10px;
                          background: ${activeRoomsTab === 'discord' ? 'rgba(138, 43, 226, 0.3)' : 'transparent'};
                          border: none;
                          border-bottom: 2px solid ${activeRoomsTab === 'discord' ? '#8a2be2' : 'transparent'};
                          color: ${activeRoomsTab === 'discord' ? '#fff' : '#aaa'};
                          font-size: 13px;
                          font-weight: bold;
                          cursor: pointer;
                          transition: all 0.2s;
                          border-radius: 4px 4px 0 0;
                      ">
                          üéÆ Discord Servers
                      </button>
                  </div>

                  <!-- Search Bar -->
                  <div style="margin-bottom: 12px;">
                      <input type="text" id="room-search-input" placeholder="Search room..."
                          style="width: 100%; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57);
                          border-radius: 4px; color: white; font-size: 12px;">
                  </div>

                  <!-- BUGFIX v3.7.4: Single container approach - swaps content instead of toggling display on two divs -->
                  <!-- This fixes the side-by-side display bug where both tabs were showing simultaneously -->
                  <div id="rooms-tab-content">
                      ${
                        activeRoomsTab === 'mg'
                          ? `
                          <!-- MG & Custom Tab Content -->
                          <div id="room-status-list-mg" style="display: flex; flex-direction: column; gap: 8px;">
                              ${mgAndCustomRooms.map(room => renderRoomCard(room, room.category === 'custom', room.category === 'custom')).join('')}
                          </div>

                          <!-- Add Custom Room Section -->
                          <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 6px;">
                              <div style="font-weight: bold; color: #60a5fa; margin-bottom: 8px; font-size: 13px;">‚ûï Add Custom Room</div>
                              <div style="display: flex; gap: 8px; align-items: center;">
                                  <input type="text" id="add-room-input" placeholder="Room code (e.g., MG16)"
                                      style="flex: 1; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57);
                                      border-radius: 4px; color: white; font-size: 12px; text-transform: uppercase;">
                                  <button id="add-room-btn" class="mga-button" style="
                                      padding: 8px 16px;
                                      font-size: 12px;
                                      background: #4ade80;
                                      color: white;
                                      border: none;
                                      border-radius: 4px;
                                      cursor: pointer;
                                      font-weight: bold;
                                  ">Add</button>
                              </div>
                              <div style="font-size: 10px; color: #888; margin-top: 6px;">
                                  Tip: Drag custom rooms to reorder, click ‚ùå to remove
                              </div>
                          </div>

                          <div style="margin-top: 16px; padding: 12px; background: rgba(34, 197, 94, 0.2); border-radius: 6px; border: 1px solid rgba(34, 197, 94, 0.3);">
                              <div style="font-size: 12px; color: #94a3b8; line-height: 1.5;">
                                  <strong style="color: #4ade80;">Magic Garden Rooms</strong><br>
                                  ‚Ä¢ MG1-15 are public Magic Garden servers<br>
                                  ‚Ä¢ Add your own custom rooms to track<br>
                                  ‚Ä¢ Player counts update automatically every 5 seconds
                              </div>
                          </div>
                      `
                          : `
                          <!-- Discord Servers Tab Content -->
                          <div id="room-status-list-discord" style="display: flex; flex-direction: column; gap: 8px;">
                              ${
                                RoomRegistry.discord.length > 0
                                  ? RoomRegistry.discord.map(room => renderRoomCard(room, false, false)).join('')
                                  : '<div style="padding: 20px; text-align: center; color: #94a3b8; font-size: 13px;">No Discord rooms available</div>'
                              }
                          </div>
                          <div style="margin-top: 16px; padding: 12px; background: rgba(138, 43, 226, 0.2); border-radius: 6px; border: 1px solid rgba(138, 43, 226, 0.3);">
                              <div style="font-size: 12px; color: #94a3b8; line-height: 1.5;">
                                  <strong style="color: #a78bfa;">üí° Discord Activity Rooms (87 Total)</strong><br>
                                  ‚Ä¢ Garlic Bread: play1-play10 (no hyphen) - 10 rooms<br>
                                  ‚Ä¢ Magic Circle: play-2 to play-50 (with hyphen) - 49 rooms<br>
                                  ‚Ä¢ Magic Circle: Country rooms (play-üá®üá¶, play-üá¨üáß, etc.) - 26 rooms<br>
                                  ‚Ä¢ Special: play-qu√©bec, play - 2 rooms<br>
                                  ‚Ä¢ <strong>Player counts via /api/rooms/{id}/info</strong> (same as community scripts)
                              </div>
                          </div>
                      `
                      }
                  </div>
              </div>
          `;
    }

    function getToolsTabContent() {
      return `
              <div class="mga-section">
                  <div class="mga-section-title">Magic Garden Calculators</div>
                  <div class="mga-tools-grid">
                      <div class="mga-tool-card" data-calculator="sell-price">
                          <div class="mga-tool-icon">üí∞</div>
                          <div class="mga-tool-name">Sell Price Calculator</div>
                          <div class="mga-tool-desc">Calculate optimal selling prices for items</div>
                      </div>
                      <div class="mga-tool-card" data-calculator="weight-probability">
                          <div class="mga-tool-icon">‚öñÔ∏è</div>
                          <div class="mga-tool-name">Weight Probability Calculator</div>
                          <div class="mga-tool-desc">Calculate weight-based probability outcomes</div>
                      </div>
                      <div class="mga-tool-card" data-calculator="pet-appearance-probability">
                          <div class="mga-tool-icon">üé≤</div>
                          <div class="mga-tool-name">Pet Appearance Probability Calculator</div>
                          <div class="mga-tool-desc">Calculate probabilities for pet appearances</div>
                      </div>
                      <div class="mga-tool-card" data-calculator="ability-trigger-time">
                          <div class="mga-tool-icon">‚è±Ô∏è</div>
                          <div class="mga-tool-name">Ability Trigger Time Calculator</div>
                          <div class="mga-tool-desc">Calculate optimal timing for pet ability triggers</div>
                      </div>
                      <div class="mga-tool-card" data-calculator="import-garden">
                          <div class="mga-tool-icon">üì•</div>
                          <div class="mga-tool-name">Import Your Garden</div>
                          <div class="mga-tool-desc">Import and analyze your garden layout</div>
                      </div>
                  </div>
                  <div class="mga-section-note" style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.15); border-radius: 5px;">
                      <strong>Note:</strong> Calculators will open in new popup windows. Make sure popup blockers are disabled for this site.
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üìö Wiki Resources</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Quick access to Magic Garden wiki pages. Click any card to open in a popup window.
                  </p>
                  <div class="mga-wiki-grid">
                      <div class="mga-wiki-card" data-wiki="crops">
                          <div class="mga-wiki-icon">üåæ</div>
                          <div class="mga-wiki-name">Crops</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="pets">
                          <div class="mga-wiki-icon">üêæ</div>
                          <div class="mga-wiki-name">Pets</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="abilities">
                          <div class="mga-wiki-icon">‚ö°</div>
                          <div class="mga-wiki-name">Abilities</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="weather">
                          <div class="mga-wiki-icon">üå§Ô∏è</div>
                          <div class="mga-wiki-name">Weather Events</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="multipliers">
                          <div class="mga-wiki-icon">üìà</div>
                          <div class="mga-wiki-name">Multipliers</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="shops">
                          <div class="mga-wiki-icon">üè™</div>
                          <div class="mga-wiki-name">Shops</div>
                      </div>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üå± Crop Highlighting</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Visual highlighting system for crops. Use Ctrl+H to clear highlights, Ctrl+Shift+H to toggle this panel.
                  </p>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Highlight Species:
                      </label>
                      <select class="mga-select" id="highlight-species-select">
                          <option value="">Select species to highlight...</option>
                          <option value="Carrot">ü•ï Carrot</option>
                          <option value="Strawberry">üçì Strawberry</option>
                          <option value="Aloe">üåø Aloe</option>
                          <option value="Apple">üçé Apple</option>
                          <option value="Tulip">üå∑ Tulip</option>
                          <option value="Tomato">üçÖ Tomato</option>
                          <option value="Blueberry">ü´ê Blueberry</option>
                          <option value="Daffodil">üåª Daffodil</option>
                          <option value="Corn">üåΩ Corn</option>
                          <option value="Watermelon">üçâ Watermelon</option>
                          <option value="Pumpkin">üéÉ Pumpkin</option>
                          <option value="Echeveria">üåµ Echeveria</option>
                          <option value="Coconut">ü•• Coconut</option>
                          <option value="Banana">üçå Banana</option>
                          <option value="Lily">üå∫ Lily</option>
                          <option value="BurrosTail">üåø BurrosTail</option>
                          <option value="Mushroom">üçÑ Mushroom</option>
                          <option value="Cactus">üåµ Cactus</option>
                          <option value="Bamboo">üéã Bamboo</option>
                          <option value="Grape">üçá Grape</option>
                          <option value="Sunflower">üåª Sunflower</option>
                          <option value="Pepper">üå∂Ô∏è Pepper</option>
                          <option value="Lemon">üçã Lemon</option>
                          <option value="PassionFruit">ü•≠ PassionFruit</option>
                          <option value="DragonFruit">üêâ DragonFruit</option>
                          <option value="Lychee">üçí Lychee</option>
                          <option value="Starweaver">‚≠ê Starweaver</option>
                          <option value="Moonbinder">üåô Moonbinder</option>
                          <option value="Dawnbinder">üåÖ Dawnbinder</option>
                      </select>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Slot Index (0-2):
                      </label>
                      <input type="number" class="mga-input" id="highlight-slot-input"
                             min="0" max="2" value="0" style="width: 80px;">
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Hidden Species:
                      </label>
                      <select class="mga-select" id="hidden-species-select">
                          <option value="">None</option>
                          <option value="Carrot">ü•ï Carrot</option>
                          <option value="Strawberry">üçì Strawberry</option>
                          <option value="Aloe">üåø Aloe</option>
                          <option value="Apple">üçé Apple</option>
                          <option value="Tulip">üå∑ Tulip</option>
                          <option value="Tomato">üçÖ Tomato</option>
                          <option value="Blueberry">ü´ê Blueberry</option>
                          <option value="Daffodil">üåª Daffodil</option>
                          <option value="Corn">üåΩ Corn</option>
                          <option value="Watermelon">üçâ Watermelon</option>
                          <option value="Pumpkin">üéÉ Pumpkin</option>
                          <option value="Echeveria">üåµ Echeveria</option>
                          <option value="Coconut">ü•• Coconut</option>
                          <option value="Banana">üçå Banana</option>
                          <option value="Lily">üå∫ Lily</option>
                          <option value="BurrosTail">üåø BurrosTail</option>
                          <option value="Mushroom">üçÑ Mushroom</option>
                          <option value="Cactus">üåµ Cactus</option>
                          <option value="Bamboo">üéã Bamboo</option>
                          <option value="Grape">üçá Grape</option>
                          <option value="Sunflower">üåª Sunflower</option>
                          <option value="Pepper">üå∂Ô∏è Pepper</option>
                          <option value="Lemon">üçã Lemon</option>
                          <option value="PassionFruit">ü•≠ PassionFruit</option>
                          <option value="DragonFruit">üêâ DragonFruit</option>
                          <option value="Lychee">üçí Lychee</option>
                          <option value="Starweaver">‚≠ê Starweaver</option>
                          <option value="Moonbinder">üåô Moonbinder</option>
                          <option value="Dawnbinder">üåÖ Dawnbinder</option>
                      </select>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Hidden Scale (0.0 - 1.0):
                      </label>
                      <input type="number" class="mga-input" id="hidden-scale-input"
                             min="0" max="1" step="0.1" value="0.1" style="width: 80px;">
                  </div>

                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <button class="mga-btn" id="apply-highlighting-btn" style="background: #059669;">
                          ‚ú® Apply Highlighting
                      </button>
                      <button class="mga-btn mga-btn-sm" id="clear-highlighting-btn" style="background: #dc2626;">
                          üóëÔ∏è Clear All
                      </button>
                  </div>
              </div>
              <style>
                  .mga-tools-grid {
                      display: grid;
                      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                      gap: 15px;
                      margin-top: 15px;
                  }

                  .mga-tool-card {
                      background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.02));
                      border: 1px solid rgba(255, 255, 255, 0.57);
                      border-radius: 8px;
                      padding: 15px;
                      cursor: pointer;
                      transition: all 0.3s ease;
                      text-align: center;
                  }

                  .mga-tool-card:hover {
                      background: linear-gradient(135deg, rgba(255, 255, 255, 0.55), rgba(255,255,255,0.04));
                      border-color: rgba(255, 255, 255, 0.73);
                      transform: translateY(-2px);
                      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.48);
                  }

                  .mga-tool-icon {
                      font-size: 2em;
                      margin-bottom: 8px;
                  }

                  .mga-tool-name {
                      font-weight: bold;
                      margin-bottom: 5px;
                      color: rgba(255,255,255,0.9);
                  }

                  .mga-tool-desc {
                      font-size: 0.85em;
                      color: rgba(255,255,255,0.6);
                      line-height: 1.3;
                  }

                  .mga-wiki-grid {
                      display: grid;
                      grid-template-columns: repeat(3, 1fr);
                      gap: 10px;
                      margin-top: 12px;
                  }

                  .mga-wiki-card {
                      background: linear-gradient(135deg, rgba(74, 158, 255, 0.28), rgba(74, 158, 255, 0.03));
                      border: 1px solid rgba(74, 158, 255, 0.48);
                      border-radius: 6px;
                      padding: 12px 8px;
                      cursor: pointer;
                      transition: all 0.2s ease;
                      text-align: center;
                  }

                  .mga-wiki-card:hover {
                      background: linear-gradient(135deg, rgba(74, 158, 255, 0.40), rgba(74, 158, 255, 0.28));
                      border-color: rgba(74, 158, 255, 0.4);
                      transform: translateY(-1px);
                      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.48);
                  }

                  .mga-wiki-icon {
                      font-size: 1.5em;
                      margin-bottom: 4px;
                  }

                  .mga-wiki-name {
                      font-size: 0.85em;
                      font-weight: 600;
                      color: rgba(255,255,255,0.9);
                  }
              </style>
          `;
    }

    // ==================== AUDIO NOTIFICATION SYSTEM ====================

    // BUGFIX: Reuse single AudioContext to prevent memory leaks and browser audio conflicts
    let sharedAudioContext = null;

    function getAudioContext() {
      if (!sharedAudioContext || sharedAudioContext.state === 'closed') {
        sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      // Resume if suspended (browser autoplay policy)
      if (sharedAudioContext.state === 'suspended') {
        sharedAudioContext.resume();
      }
      return sharedAudioContext;
    }

    // Play notification sound using Web Audio API
    function playNotificationSound(frequency = 800, duration = 200, volume = 0.3) {
      try {
        const audioContext = getAudioContext();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration / 1000);

        productionLog(`üîä [NOTIFICATIONS] Sound played for rare item!`);
      } catch (error) {
        console.error('‚ùå [NOTIFICATIONS] Failed to play notification sound:', error);
      }
    }

    // Play triple beep notification for rare items
    function playTripleBeepNotification(volume = 0.3) {
      playNotificationSound(1000, 250, volume);
      setTimeout(() => playNotificationSound(1000, 200, volume * 0.8), 300);
      setTimeout(() => playNotificationSound(1200, 150, volume * 0.6), 600);
    }

    // Play double beep notification for pet hunger (different from shop alerts)
    function playDoubleBeepNotification(volume = 0.3) {
      playNotificationSound(600, 200, volume);
      setTimeout(() => playNotificationSound(600, 200, volume * 0.9), 250);
    }

    // Play single beep for ability notifications (subtle)
    function playSingleBeepNotification(volume = 0.2) {
      playNotificationSound(500, 150, volume);
    }

    // Play chime notification - ascending notes (pleasant)
    function playChimeNotification(volume = 0.2) {
      playNotificationSound(500, 100, volume);
      setTimeout(() => playNotificationSound(800, 100, volume * 0.9), 120);
      setTimeout(() => playNotificationSound(1000, 120, volume * 0.8), 240);
    }

    // Play alert notification - urgent descending (attention-grabbing)
    function playAlertNotification(volume = 0.2) {
      playNotificationSound(1200, 150, volume);
      setTimeout(() => playNotificationSound(900, 150, volume * 0.9), 160);
    }

    // Play buzz notification - rapid pulsing (energetic)
    function playBuzzNotification(volume = 0.2) {
      for (let i = 0; i < 8; i++) {
        setTimeout(() => playNotificationSound(300, 40, volume * (i % 2 === 0 ? 1 : 0.6)), i * 50);
      }
    }

    // Play ding notification - clean bell-like (clear)
    function playDingNotification(volume = 0.2) {
      playNotificationSound(2000, 180, volume);
    }

    // Play chirp notification - quick rising chirp (cute)
    function playChirpNotification(volume = 0.2) {
      playNotificationSound(400, 80, volume);
      setTimeout(() => playNotificationSound(800, 60, volume * 0.8), 85);
      setTimeout(() => playNotificationSound(1200, 40, volume * 0.6), 150);
    }

    // Play alarm siren notification (very loud and noticeable)
    function playAlarmNotification(volume = 0.5) {
      let count = 0;
      const interval = setInterval(() => {
        // Alternating high-low siren sound
        playNotificationSound(count % 2 === 0 ? 1500 : 800, 400, volume);
        count++;
        if (count >= 6) clearInterval(interval); // Play 6 times total
      }, 450);
    }

    // Play continuous warning sound (repeats until acknowledged)
    let continuousAlarmInterval = null;
    function startContinuousAlarm(volume = 0.4) {
      if (continuousAlarmInterval) return; // Already playing

      let tone = 800;
      continuousAlarmInterval = setInterval(() => {
        // Warbling effect
        tone = tone === 800 ? 1200 : 800;
        playNotificationSound(tone, 300, volume);
      }, 350);

      productionLog('üö® [NOTIFICATIONS] Continuous alarm started - requires acknowledgment!');
    }

    function stopContinuousAlarm() {
      if (continuousAlarmInterval) {
        clearInterval(continuousAlarmInterval);
        continuousAlarmInterval = null;
        productionLog('‚úÖ [NOTIFICATIONS] Continuous alarm stopped');
      }
    }

    // Play epic notification (multiple tones in sequence)
    function playEpicNotification(volume = 0.4) {
      const sequence = [
        [400, 100],
        [500, 100],
        [600, 100],
        [800, 150],
        [1000, 200],
        [1200, 150],
        [1000, 150],
        [1200, 200],
        [1500, 300],
        [1200, 100],
        [1500, 400]
      ];

      let delay = 0;
      sequence.forEach(([freq, dur]) => {
        setTimeout(() => playNotificationSound(freq, dur, volume), delay);
        delay += dur + 50;
      });
    }

    // Play selected notification type
    function playSelectedNotification() {
      const notifications = UnifiedState.data.settings.notifications;
      const volume = notifications.volume || 0.3;
      const type = notifications.notificationType || 'triple';

      productionLog(`üîä [NOTIFICATIONS] Playing ${type} notification at ${Math.round(volume * 100)}% volume`);

      switch (type) {
        case 'simple':
          playNotificationSound(1000, 300, volume);
          break;
        case 'triple':
          playTripleBeepNotification(volume);
          break;
        case 'alarm':
          playAlarmNotification(volume);
          break;
        case 'epic':
          playEpicNotification(volume);
          break;
        case 'continuous':
          startContinuousAlarm(volume);
          break;
        default:
          playTripleBeepNotification(volume);
      }
    }

    // Normalize species names for case-insensitive matching
    function normalizeSpeciesName(name) {
      if (!name || typeof name !== 'string') return '';
      return name.trim().toLowerCase();
    }

    // ========== CUSTOM SOUND PLAYBACK WRAPPERS ==========
    // These functions check for custom uploaded sounds before falling back to default beeps

    function playCustomOrDefaultSound(soundType, defaultPlayFunc, volume) {
      const customSound = GM_getValue(`mgtools_custom_sound_${soundType}`, null);

      if (customSound) {
        // Check if we're in continuous mode - custom sounds can't loop, so use default alarm instead
        const notificationType = UnifiedState.data.settings.notifications.notificationType;
        if (notificationType === 'continuous') {
          productionLog(`üéµ [CUSTOM-SOUND] Continuous mode active - using alarm instead of custom ${soundType} sound`);
          startContinuousAlarm(volume);
          return;
        }

        try {
          const audio = new Audio(customSound);
          audio.volume = volume || 0.3;
          audio.play();
          productionLog(`üéµ [CUSTOM-SOUND] Playing custom ${soundType} sound`);
        } catch (err) {
          console.error(`Failed to play custom ${soundType} sound:`, err);
          defaultPlayFunc(volume);
        }
      } else {
        defaultPlayFunc(volume);
      }
    }

    function playGeneralNotificationSound(volume) {
      const type = UnifiedState.data.settings.notifications.notificationType || 'epic';

      switch (type) {
        case 'simple':
          playNotificationSound(1000, 300, volume);
          break;
        case 'triple':
          playTripleBeepNotification(volume);
          break;
        case 'alarm':
          playAlarmNotification(volume);
          break;
        case 'epic':
          playEpicNotification(volume);
          break;
        case 'continuous':
          startContinuousAlarm(volume);
          break;
        default:
          playEpicNotification(volume);
      }
    }

    function playShopNotificationSound(volume) {
      playCustomOrDefaultSound('shop', playGeneralNotificationSound, volume);
    }

    function playPetNotificationSound(volume) {
      playCustomOrDefaultSound('pet', playGeneralNotificationSound, volume);
    }

    function playAbilityNotificationSound(volume) {
      const customSound = GM_getValue('mgtools_custom_sound_ability', null);
      if (customSound) {
        try {
          const audio = new Audio(customSound);
          audio.volume = volume || 0.2;
          audio.play();
          productionLog('üéµ [CUSTOM-SOUND] Playing custom ability sound');
        } catch (err) {
          console.error('Failed to play custom ability sound:', err);
          // Fall through to default sound logic
        }
      }

      // If no custom sound or custom sound failed, use user's selected default
      if (!customSound) {
        const abilitySound = UnifiedState.data.settings.notifications.abilityNotificationSound || 'single';

        switch (abilitySound) {
          case 'single':
            playSingleBeepNotification(volume);
            break;
          case 'double':
            playDoubleBeepNotification(volume);
            break;
          case 'triple':
            playTripleBeepNotification(volume);
            break;
          case 'chime':
            playChimeNotification(volume);
            break;
          case 'alert':
            playAlertNotification(volume);
            break;
          case 'buzz':
            playBuzzNotification(volume);
            break;
          case 'ding':
            playDingNotification(volume);
            break;
          case 'chirp':
            playChirpNotification(volume);
            break;
          case 'epic':
            playEpicNotification(volume);
            break;
          default:
            playSingleBeepNotification(volume);
        }
      }
    }

    function playWeatherNotificationSound(volume) {
      playCustomOrDefaultSound('weather', playGeneralNotificationSound, volume);
    }

    // Check if an item is on the watch list (case-insensitive for seeds)
    function isWatchedItem(itemId, type = 'seed') {
      const notifications = UnifiedState.data.settings.notifications;
      if (type === 'seed') {
        // Handle name variations for celestial seeds
        // Shop uses "DawnCelestial" and "MoonCelestial" but UI uses "Dawnbinder" and "Moonbinder"
        const nameMap = {
          DawnCelestial: 'Dawnbinder',
          MoonCelestial: 'Moonbinder'
        };
        const checkId = nameMap[itemId] || itemId;

        // Case-insensitive matching for seeds
        const normalizedItemId = normalizeSpeciesName(checkId);
        return notifications.watchedSeeds.some(watched => normalizeSpeciesName(watched) === normalizedItemId);
      } else if (type === 'egg') {
        return notifications.watchedEggs.includes(itemId);
      }
      return false;
    }

    // Update last seen timestamp for an item
    function updateLastSeen(itemId) {
      const notifications = UnifiedState.data.settings.notifications;
      notifications.lastSeenTimestamps[itemId] = Date.now();
      MGA_saveJSON('MGA_data', UnifiedState.data);
      productionLog(`üìÖ [NOTIFICATIONS] Updated last seen for ${itemId}`);
    }

    // Get time since last seen (in human readable format)
    function getTimeSinceLastSeen(itemId) {
      const notifications = UnifiedState.data.settings.notifications;

      // Map UI names to shop IDs for celestial seeds
      // UI shows "Moonbinder" but shop stores as "MoonCelestial"
      const reverseNameMap = {
        Moonbinder: 'MoonCelestial',
        Dawnbinder: 'DawnCelestial'
      };
      const lookupId = reverseNameMap[itemId] || itemId;

      const timestamp = notifications.lastSeenTimestamps[lookupId];
      if (!timestamp) return 'Never seen';

      const diff = Date.now() - timestamp;
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const days = Math.floor(hours / 24);

      if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
      if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;

      const minutes = Math.floor(diff / (1000 * 60));
      return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
    }

    // Notification queue system for batching multiple notifications
    let notificationQueue = [];
    let currentNotificationModal = null;
    let notificationQueueTimer = null;
    const NOTIFICATION_BATCH_DELAY = 2000; // 2 seconds to batch notifications

    // Add notification to queue and show batched modal
    function queueNotification(message, requiresAcknowledgment = false) {
      notificationQueue.push({ message, requiresAcknowledgment, timestamp: Date.now() });

      // Clear existing timer and start new one
      if (notificationQueueTimer) {
        clearTimeout(notificationQueueTimer);
      }

      // If there's already a modal open, update it immediately
      if (currentNotificationModal) {
        updateNotificationModal();
        return;
      }

      // Otherwise, batch notifications for a short period
      notificationQueueTimer = setTimeout(() => {
        showBatchedNotificationModal();
      }, NOTIFICATION_BATCH_DELAY);
    }

    // Update existing notification modal with new notifications
    function updateNotificationModal() {
      if (!currentNotificationModal) return;

      const messageContainer = currentNotificationModal.querySelector('.notification-messages');
      if (messageContainer) {
        messageContainer.innerHTML = generateNotificationListHTML();
      }

      const countDisplay = currentNotificationModal.querySelector('.notification-count');
      if (countDisplay) {
        countDisplay.textContent = `${notificationQueue.length} Notification${notificationQueue.length > 1 ? 's' : ''}`;
      }
    }

    // Generate HTML for notification list
    function generateNotificationListHTML() {
      return notificationQueue
        .map(
          (notif, index) => `
              <div style="margin-bottom: 10px; padding: 10px; background: rgba(255, 255, 255, 0.57); border-radius: 5px; border-left: 3px solid #fff;">
                  <div style="font-size: 14px; margin-bottom: 5px;">${notif.message}</div>
                  <div style="font-size: 10px; opacity: 0.8;">${new Date(notif.timestamp).toLocaleTimeString()}</div>
              </div>
          `
        )
        .join('');
    }

    // Show batched notification modal
    function showBatchedNotificationModal() {
      if (notificationQueue.length === 0) return;

      // Ensure only one modal exists at a time - cleanup any existing modal
      if (currentNotificationModal) {
        dismissAllNotifications();
        // Wait a bit for the dismiss animation to complete
        setTimeout(() => showBatchedNotificationModal(), 350);
        return;
      }

      const hasAcknowledgmentRequired = notificationQueue.some(n => n.requiresAcknowledgment);

      // If only one notification and no acknowledgment required, use regular notification
      if (notificationQueue.length === 1 && !hasAcknowledgmentRequired) {
        const notif = notificationQueue[0];
        showVisualNotification(notif.message, notif.requiresAcknowledgment);
        notificationQueue = [];
        return;
      }

      // If multiple notifications but NONE require acknowledgment, show them as simple toasts
      if (!hasAcknowledgmentRequired) {
        // Show each notification as a simple non-blocking toast
        notificationQueue.forEach(notif => {
          showVisualNotification(notif.message, false);
        });
        notificationQueue = [];
        return;
      }

      // Create batched modal (only if acknowledgment is required)
      const notification = targetDocument.createElement('div');
      notification.className = 'mga-batched-notification';

      notification.style.cssText = `
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              background: linear-gradient(135deg, #ff6b6b 0%, #ff0000 100%);
              color: white;
              padding: 20px;
              border-radius: 15px;
              box-shadow: 0 20px 60px rgba(255,0,0,0.4), 0 0 100px rgba(255, 0, 0, 0.48);
              z-index: 9999999;
              font-weight: bold;
              animation: mga-modal-entrance 0.5s ease-out;
              border: 3px solid #ffffff;
              text-align: center;
              max-width: 500px;
              max-height: 400px;
              overflow-y: auto;
          `;

      notification.innerHTML = `
              <div class="notification-count" style="font-size: 20px; margin-bottom: 15px;">
                  ${notificationQueue.length} Notification${notificationQueue.length > 1 ? 's' : ''}
              </div>
              <div class="notification-messages" style="text-align: left; margin-bottom: 20px; max-height: 200px; overflow-y: auto;">
                  ${generateNotificationListHTML()}
              </div>
              <button class="acknowledge-all-btn" style="
                  background: white;
                  color: #ff0000;
                  border: none;
                  padding: 12px 24px;
                  border-radius: 5px;
                  font-weight: bold;
                  font-size: 16px;
                  cursor: pointer;
                  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                  transition: all 0.2s;
              ">
                  ACKNOWLEDGE ALL (${notificationQueue.length})
              </button>
          `;

      // Add button interactivity
      const ackButton = notification.querySelector('.acknowledge-all-btn');
      ackButton.onmouseover = () => {
        ackButton.style.transform = 'scale(1.05)';
        ackButton.style.boxShadow = '0 6px 15px rgba(0,0,0,0.4)';
      };
      ackButton.onmouseout = () => {
        ackButton.style.transform = 'scale(1)';
        ackButton.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
      };
      ackButton.onclick = () => {
        dismissAllNotifications();
      };

      // Add backdrop
      const backdrop = targetDocument.createElement('div');
      backdrop.className = 'mga-notification-backdrop';
      backdrop.style.cssText = `
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.7);
              z-index: 9999998;
              animation: fadeIn 0.3s ease-in;
          `;
      backdrop.onclick = () => {
        backdrop.style.animation = 'flash 0.3s ease-in-out';
      };

      targetDocument.body.appendChild(backdrop);
      targetDocument.body.appendChild(notification);

      currentNotificationModal = notification;

      // NOTE: Don't stop continuous alarm here - it should keep playing until acknowledged
      // The alarm will be stopped when the user clicks the acknowledge button
    }

    // Dismiss all notifications
    function dismissAllNotifications() {
      stopContinuousAlarm();

      if (currentNotificationModal) {
        const backdrop = targetDocument.querySelector('.mga-notification-backdrop');

        currentNotificationModal.style.animation = 'fadeOut 0.3s ease-out';
        if (backdrop) backdrop.style.animation = 'fadeOut 0.3s ease-out';

        setTimeout(() => {
          if (currentNotificationModal) currentNotificationModal.remove();
          if (backdrop) backdrop.remove();
          currentNotificationModal = null;
        }, 300);
      }

      notificationQueue = [];

      if (notificationQueueTimer) {
        clearTimeout(notificationQueueTimer);
        notificationQueueTimer = null;
      }
    }

    // Format timestamp based on user preference
    function formatTimestamp(timestamp) {
      // PERFORMANCE: Check cache first (cache key includes timestamp + settings mode)
      const cacheKey = `${timestamp}_${UnifiedState.data.settings.detailedTimestamps}`;
      // eslint-disable-next-line no-use-before-define
      if (MGA_AbilityCache.timestamps.has(cacheKey)) {
        // eslint-disable-next-line no-use-before-define -- cache is initialized below; usage occurs after init at runtime
        return MGA_AbilityCache.timestamps.get(cacheKey);
      }

      const date = new Date(timestamp);
      let formatted;
      if (UnifiedState.data.settings.detailedTimestamps) {
        // Return HH:MM:SS format in user's local timezone
        formatted = date.toLocaleTimeString(undefined, {
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
      } else {
        // Return default H:MM AM/PM format in user's local timezone
        formatted = date.toLocaleTimeString(undefined, {
          hour: 'numeric',
          minute: '2-digit'
        });
      }

      // PERFORMANCE: Cache result (cleared every minute via setInterval)
      // eslint-disable-next-line no-use-before-define -- cache is initialized below; usage occurs after init at runtime
      MGA_AbilityCache.timestamps.set(cacheKey, formatted);

      return formatted;
    }

    // Show visual notification in game (legacy function, now routes through queue)
    function showVisualNotification(message, requiresAcknowledgment = false) {
      // Ensure only one modal exists at a time for acknowledgment-required notifications
      if (requiresAcknowledgment && currentNotificationModal) {
        dismissAllNotifications();
        // Wait a bit for the dismiss animation to complete
        setTimeout(() => showVisualNotification(message, requiresAcknowledgment), 350);
        return;
      }

      const notification = targetDocument.createElement('div');

      if (requiresAcknowledgment) {
        // Create persistent modal that requires acknowledgment
        notification.style.cssText = `
                  position: fixed;
                  top: 50%;
                  left: 50%;
                  transform: translate(-50%, -50%);
                  background: linear-gradient(135deg, #ff6b6b 0%, #ff0000 100%);
                  color: white;
                  padding: 30px;
                  border-radius: 15px;
                  box-shadow: 0 20px 60px rgba(255,0,0,0.4), 0 0 100px rgba(255, 0, 0, 0.48);
                  z-index: 9999999;
                  font-weight: bold;
                  font-size: 20px;
                  animation: mga-modal-entrance 0.5s ease-out;
                  border: 3px solid #ffffff;
                  text-align: center;
                  min-width: 400px;
              `;

        // Create message div
        const messageDiv = targetDocument.createElement('div');
        messageDiv.textContent = message;
        messageDiv.style.marginBottom = '20px';
        notification.appendChild(messageDiv);

        // Create acknowledge button
        const ackButton = targetDocument.createElement('button');
        ackButton.textContent = 'ACKNOWLEDGE (Stop Alarm)';
        ackButton.style.cssText = `
                  background: white;
                  color: #ff0000;
                  border: none;
                  padding: 10px 20px;
                  border-radius: 5px;
                  font-weight: bold;
                  font-size: 16px;
                  cursor: pointer;
                  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                  transition: all 0.2s;
              `;
        ackButton.onmouseover = () => {
          ackButton.style.transform = 'scale(1.05)';
          ackButton.style.boxShadow = '0 6px 15px rgba(0,0,0,0.4)';
        };
        ackButton.onmouseout = () => {
          ackButton.style.transform = 'scale(1)';
          ackButton.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
        };
        ackButton.onclick = () => {
          stopContinuousAlarm();
          notification.style.animation = 'fadeOut 0.3s ease-out';
          setTimeout(() => notification.remove(), 300);
        };
        notification.appendChild(ackButton);

        // Add backdrop
        const backdrop = targetDocument.createElement('div');
        backdrop.style.cssText = `
                  position: fixed;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  background: rgba(0, 0, 0, 0.7);
                  z-index: 9999998;
                  animation: fadeIn 0.3s ease-in;
              `;
        backdrop.onclick = () => {
          backdrop.style.animation = 'flash 0.3s ease-in-out';
        };
        targetDocument.body.appendChild(backdrop);

        // Append notification to body
        targetDocument.body.appendChild(notification);

        // Set as current modal for tracking
        currentNotificationModal = notification;

        // Link backdrop removal to button click
        ackButton.onclick = () => {
          stopContinuousAlarm();
          notification.style.animation = 'fadeOut 0.3s ease-out';
          backdrop.style.animation = 'fadeOut 0.3s ease-out';
          setTimeout(() => {
            notification.remove();
            backdrop.remove();
            currentNotificationModal = null;
          }, 300);
        };
      } else {
        // Regular auto-dismiss notification
        notification.style.cssText = `
                  position: fixed;
                  top: 20px;
                  right: 20px;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  padding: 15px 20px;
                  border-radius: 10px;
                  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                  z-index: 999999;
                  font-weight: bold;
                  font-size: 16px;
                  animation: slideInRight 0.5s ease-out;
                  border: 2px solid rgba(255,255,255,0.3);
              `;
        notification.textContent = message;

        // Remove after 5 seconds
        setTimeout(() => {
          notification.style.animation = 'slideOutRight 0.5s ease-out';
          setTimeout(() => notification.remove(), 500);
        }, 5000);
      }

      // Add animation styles if not exists
      if (!targetDocument.getElementById('mga-notification-animations')) {
        const style = targetDocument.createElement('style');
        style.id = 'mga-notification-animations';
        style.textContent = `
                  @keyframes slideInRight {
                      from { transform: translateX(100%); opacity: 0; }
                      to { transform: translateX(0); opacity: 1; }
                  }
                  @keyframes slideOutRight {
                      from { transform: translateX(0); opacity: 1; }
                      to { transform: translateX(100%); opacity: 0; }
                  }
                  @keyframes mga-notification-pulse {
                      from { transform: translate(-50%, -50%) scale(1); }
                      to { transform: translate(-50%, -50%) scale(1.05); }
                  }
                  @keyframes mga-modal-entrance {
                      from {
                          opacity: 0;
                          transform: translate(-50%, -50%) scale(0.8);
                      }
                      to {
                          opacity: 1;
                          transform: translate(-50%, -50%) scale(1);
                      }
                  }
                  @keyframes fadeIn {
                      from { opacity: 0; }
                      to { opacity: 1; }
                  }
                  @keyframes fadeOut {
                      from { opacity: 1; }
                      to { opacity: 0; }
                  }
                  @keyframes flash {
                      0%, 100% { background: rgba(0, 0, 0, 0.7); }
                      50% { background: rgba(255, 0, 0, 0.3); }
                  }
              `;
        targetDocument.head.appendChild(style);
      }

      targetDocument.body.appendChild(notification);
    }

    // Track current shop inventory and restock state
    let previousSeedInventory = [];
    let previousEggInventory = [];
    let previousDecorInventory = [];
    const previousToolInventory = [];
    let previousSeedQuantities = {};
    let previousEggQuantities = {};
    let previousDecorQuantities = {};
    const previousToolQuantities = {};
    let lastRestockCheck = 0;
    const lastNotificationTime = 0;
    let lastSeedTimer = 999;
    let lastEggTimer = 999;
    let lastDecorTimer = 999;
    let lastSeedRestock = 0;
    let lastEggRestock = 0;
    let lastDecorRestock = 0;
    const seedRestockNotifiedItems = new Set(); // Track items notified during current restock
    const eggRestockNotifiedItems = new Set(); // Track items notified during current restock
    const decorRestockNotifiedItems = new Set(); // Track items notified during current restock
    let isFirstRun = true; // Track if this is the first check to notify for watched items already in stock
    const CHECK_INTERVAL = 2000; // Check every 2 seconds for better timing

    // Restock detection constants (same as Buy UI for maximum reliability)
    const SMALL_EDGE = 5; // Timer at or below 5s means near restock
    const LARGE_EDGE = 180; // Timer at or above 180s means just restocked
    const BIG_JUMP_DELTA = 60; // Timer jump of 60+ seconds indicates restock
    const NOTIFICATION_COOLDOWN = 30000; // 30 seconds between notifications for same item to prevent duplicates
    const RESTOCK_COOLDOWN = 30000; // 30 seconds cooldown after restock to catch all new items

    // Check for new watched items in shop
    function checkForWatchedItems() {
      const notifications = UnifiedState.data.settings.notifications;
      if (!notifications || !notifications.enabled) return;

      try {
        const now = Date.now();

        // Collect all detected items in this check cycle for batch notification
        const detectedItems = [];

        // Check every 5 seconds to catch items quickly
        if (now - lastRestockCheck < CHECK_INTERVAL) return;
        lastRestockCheck = now;

        // Get timer data - use both sources for reliability
        const quinoaData = UnifiedState.atoms.quinoaData || targetWindow?.globalShop;
        if (!quinoaData && !targetWindow?.globalShop) return; // No shop data available

        // Use targetWindow.globalShop as primary source, quinoaData as fallback
        const shopData = targetWindow?.globalShop || UnifiedState.atoms.quinoaData || quinoaData;
        const seedTimer = shopData?.shops?.seed?.secondsUntilRestock || 999;
        const eggTimer = shopData?.shops?.egg?.secondsUntilRestock || 999;
        const decorTimer = shopData?.shops?.decor?.secondsUntilRestock || 999;

        // Detect restock using robust edge-detection (same method as Buy UI)
        // Method 1: Timer was ‚â§5s and now ‚â•180s (actual reset moment)
        // Method 2: Timer jumped by ‚â•60s (big jump indicates restock)
        const seedRestocked =
          (lastSeedTimer <= SMALL_EDGE && seedTimer >= LARGE_EDGE) ||
          (seedTimer - lastSeedTimer >= BIG_JUMP_DELTA && lastSeedTimer > 0);

        const eggRestocked =
          (lastEggTimer <= SMALL_EDGE && eggTimer >= LARGE_EDGE) ||
          (eggTimer - lastEggTimer >= BIG_JUMP_DELTA && lastEggTimer > 0);

        const decorRestocked =
          (lastDecorTimer <= SMALL_EDGE && decorTimer >= LARGE_EDGE) ||
          (decorTimer - lastDecorTimer >= BIG_JUMP_DELTA && lastDecorTimer > 0);

        // Timer tracking (silent unless restock detected)

        if (seedRestocked) {
          productionLog(`üîÑ [NOTIFICATIONS] SEED SHOP RESTOCKED! (Edge detection: ${lastSeedTimer}‚Üí${seedTimer})`);
          previousSeedInventory = []; // Clear for new cycle
          previousSeedQuantities = {}; // Clear quantity tracking
          seedRestockNotifiedItems.clear(); // Clear restock notification tracking
          lastSeedRestock = now;
        }

        if (eggRestocked) {
          productionLog(`üîÑ [NOTIFICATIONS] EGG SHOP RESTOCKED! (Edge detection: ${lastEggTimer}‚Üí${eggTimer})`);
          previousEggInventory = []; // Clear for new cycle
          previousEggQuantities = {}; // Clear quantity tracking
          eggRestockNotifiedItems.clear(); // Clear restock notification tracking
          lastEggRestock = now;
        }

        if (decorRestocked) {
          productionLog(`üîÑ [NOTIFICATIONS] DECOR SHOP RESTOCKED! (Edge detection: ${lastDecorTimer}‚Üí${decorTimer})`);
          previousDecorInventory = []; // Clear for new cycle
          previousDecorQuantities = {}; // Clear quantity tracking
          decorRestockNotifiedItems.clear(); // Clear restock notification tracking
          lastDecorRestock = now;
        }

        // Update last timer values
        lastSeedTimer = seedTimer;
        lastEggTimer = eggTimer;
        lastDecorTimer = decorTimer;

        // Check seed shop
        const currentSeeds = targetWindow?.globalShop?.shops?.seed?.inventory || [];
        const inStockSeeds = currentSeeds.filter(item => item.initialStock > 0);
        const currentSeedIds = inStockSeeds.map(item => item.species);

        // OPTIMIZED: Removed excessive debug logging

        // Track seed quantities (FIXED APPROACH)
        const currentSeedQuantities = {};
        inStockSeeds.forEach(item => {
          currentSeedQuantities[item.species] = item.initialStock;
        });

        // Initialize previous quantities if empty (first run)
        if (Object.keys(previousSeedQuantities).length === 0 && !seedRestocked) {
          productionLog(`üîß [NOTIFICATIONS] Initializing previous seed quantities...`);
          Object.keys(currentSeedQuantities).forEach(seedId => {
            previousSeedQuantities[seedId] = currentSeedQuantities[seedId];
          });
        }

        productionLog(
          `üõí [NOTIFICATIONS] Current seed quantities:`,
          currentSeedQuantities,
          `| Previous:`,
          previousSeedQuantities
        );

        // Find seeds with increased quantities or new items (after restock)
        Object.keys(currentSeedQuantities).forEach(seedId => {
          const oldQuantity = previousSeedQuantities[seedId] || 0;
          const newQuantity = currentSeedQuantities[seedId];

          // Always log each seed being processed for debugging
          productionLog(`üîç [NOTIFICATIONS] Processing seed: ${seedId} (${oldQuantity}‚Üí${newQuantity})`);

          // Determine if we should check for notification
          const quantityIncreased = newQuantity > oldQuantity;
          const isRestockWindow = seedRestocked && now - lastSeedRestock < RESTOCK_COOLDOWN;
          const alreadyNotifiedInRestock = seedRestockNotifiedItems.has(seedId);

          productionLog(
            `üîç [NOTIFICATIONS] ${seedId} check logic: quantityIncreased=${quantityIncreased}, isRestockWindow=${isRestockWindow}, alreadyNotifiedInRestock=${alreadyNotifiedInRestock}`
          );

          // Only trigger notification if:
          // 1) First run and item is in stock, OR
          // 2) Quantity increased AND not in restock window, OR
          // 3) In restock window AND item hasn't been notified in this restock cycle, OR
          // 4) New item appears (oldQuantity was 0)
          const shouldCheck =
            (isFirstRun && newQuantity > 0) ||
            (quantityIncreased && !isRestockWindow) ||
            (isRestockWindow && !alreadyNotifiedInRestock) ||
            (oldQuantity === 0 && newQuantity > 0);

          productionLog(`üîç [NOTIFICATIONS] ${seedId} shouldCheck: ${shouldCheck}`);

          if (shouldCheck) {
            productionLog(
              `üÜï [NOTIFICATIONS] Seed stock change: ${seedId} (${oldQuantity}‚Üí${newQuantity}) | Restock: ${seedRestocked} | RestockWindow: ${isRestockWindow}`
            );

            // Update last seen for ANY seed that appears or increases
            updateLastSeen(seedId);

            // Check if it's a watched seed with detailed logging
            const isWatched = isWatchedItem(seedId, 'seed');
            productionLog(`üîç [NOTIFICATIONS] Is ${seedId} watched? ${isWatched}`);
            productionLog(`üîç [NOTIFICATIONS] Watched list: [${notifications.watchedSeeds.join(', ')}]`);
            productionLog(
              `üîç [NOTIFICATIONS] Exact match check:`,
              notifications.watchedSeeds.map(w => ({
                watched: w,
                current: seedId,
                exactMatch: w === seedId,
                lowerMatch: w.toLowerCase() === seedId.toLowerCase()
              }))
            );

            if (isWatched) {
              // Check cooldown (1 minute per item, but allow Carrot for testing)
              const itemKey = `seed_${seedId}`;
              const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
              const canNotify = now - lastNotified > NOTIFICATION_COOLDOWN;

              productionLog(
                `üîç [NOTIFICATIONS] ${seedId} cooldown check: lastNotified=${lastNotified}, now=${now}, diff=${now - lastNotified}, canNotify=${canNotify}`
              );

              if (canNotify) {
                productionLog(`üéâ [NOTIFICATIONS] RARE SEED DETECTED: ${seedId} (${newQuantity} in stock)`);
                notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;

                // Track that we notified this item during restock
                if (isRestockWindow) {
                  seedRestockNotifiedItems.add(seedId);
                }

                MGA_saveJSON('MGA_data', UnifiedState.data);

                // Collect item for batch notification instead of notifying immediately
                detectedItems.push({
                  type: 'seed',
                  id: seedId,
                  quantity: newQuantity,
                  icon: 'üå±'
                });
              } else {
                productionLog(`‚è∞ [NOTIFICATIONS] ${seedId} on cooldown, not notifying`);
              }
            } else {
              productionLog(`‚ùå [NOTIFICATIONS] ${seedId} is not watched, skipping notification`);
            }
          } else {
            productionLog(`‚è≠Ô∏è [NOTIFICATIONS] ${seedId} shouldCheck=false, skipping`);
          }
        });

        productionLog(`‚úÖ [NOTIFICATIONS] Finished checking seeds, moving to eggs...`);

        // Check egg shop
        // Declare variables OUTSIDE try block to fix scope issue
        let currentEggIds = [];
        const currentEggQuantities = {};

        try {
          productionLog(`ü•ö [NOTIFICATIONS] === CHECKING EGG SHOP ===`);
          const currentEggs = targetWindow?.globalShop?.shops?.egg?.inventory || [];
          const inStockEggs = currentEggs.filter(item => item.initialStock > 0);
          currentEggIds = inStockEggs.map(item => item.eggId);

          // Always log current egg state for debugging (like seeds)
          productionLog(
            `ü•ö [NOTIFICATIONS] Current eggs in shop: [${currentEggIds.join(', ')}] | Previous: [${previousEggInventory.join(', ')}]`
          );
          productionLog(
            `ü•ö [NOTIFICATIONS] Raw egg inventory:`,
            currentEggs.map(e => `${e.eggId}(stock:${e.initialStock})`)
          );

          // Debug egg shop structure
          if (currentEggs.length === 0) {
            productionLog(`ü•ö [NOTIFICATIONS] No eggs found. Shop structure:`, {
              hasGlobalShop: !!targetWindow?.globalShop,
              hasShops: !!targetWindow?.globalShop?.shops,
              hasEggShop: !!targetWindow?.globalShop?.shops?.egg,
              hasEggInventory: !!targetWindow?.globalShop?.shops?.egg?.inventory,
              eggInventoryLength: targetWindow?.globalShop?.shops?.egg?.inventory?.length || 0
            });
          }

          // Track egg quantities (FIXED APPROACH)
          // Use the variable declared outside try block
          inStockEggs.forEach(item => {
            currentEggQuantities[item.eggId] = item.initialStock;
          });

          // Initialize previous quantities if empty (first run)
          if (Object.keys(previousEggQuantities).length === 0 && !eggRestocked) {
            productionLog(`üîß [NOTIFICATIONS] Initializing previous egg quantities...`);
            Object.keys(currentEggQuantities).forEach(eggId => {
              previousEggQuantities[eggId] = currentEggQuantities[eggId];
            });
          }

          productionLog(
            `ü•ö [NOTIFICATIONS] Current egg quantities:`,
            currentEggQuantities,
            `| Previous:`,
            previousEggQuantities
          );

          // Find eggs with increased quantities or new items (after restock)
          Object.keys(currentEggQuantities).forEach(eggId => {
            const oldQuantity = previousEggQuantities[eggId] || 0;
            const newQuantity = currentEggQuantities[eggId];

            // Always log each egg being processed for debugging (like seeds)
            productionLog(`üîç [NOTIFICATIONS] Processing egg: ${eggId} (${oldQuantity}‚Üí${newQuantity})`);

            // Determine if we should check for notification
            const quantityIncreased = newQuantity > oldQuantity;
            const isRestockWindow = eggRestocked && now - lastEggRestock < RESTOCK_COOLDOWN;
            const alreadyNotifiedInRestock = eggRestockNotifiedItems.has(eggId);

            productionLog(
              `üîç [NOTIFICATIONS] ${eggId} check logic: quantityIncreased=${quantityIncreased}, isRestockWindow=${isRestockWindow}, alreadyNotifiedInRestock=${alreadyNotifiedInRestock}`
            );

            // Only trigger notification if:
            // 1) First run and item is in stock, OR
            // 2) Quantity increased AND not in restock window, OR
            // 3) In restock window AND item hasn't been notified in this restock cycle, OR
            // 4) New item appears (oldQuantity was 0)
            const shouldCheck =
              (isFirstRun && newQuantity > 0) ||
              (quantityIncreased && !isRestockWindow) ||
              (isRestockWindow && !alreadyNotifiedInRestock) ||
              (oldQuantity === 0 && newQuantity > 0);

            productionLog(`üîç [NOTIFICATIONS] ${eggId} shouldCheck: ${shouldCheck}`);

            if (shouldCheck) {
              productionLog(
                `üÜï [NOTIFICATIONS] Egg stock change: ${eggId} (${oldQuantity}‚Üí${newQuantity}) | Restock: ${eggRestocked} | RestockWindow: ${isRestockWindow}`
              );

              // Update last seen for ANY egg that appears or increases
              updateLastSeen(eggId);

              // Check if it's a watched egg with detailed logging
              const isWatched = isWatchedItem(eggId, 'egg');
              productionLog(`üîç [NOTIFICATIONS] Is ${eggId} watched? ${isWatched}`);
              productionLog(`üîç [NOTIFICATIONS] Watched list: [${notifications.watchedEggs.join(', ')}]`);
              productionLog(
                `üîç [NOTIFICATIONS] Exact match check:`,
                notifications.watchedEggs.map(w => ({
                  watched: w,
                  current: eggId,
                  exactMatch: w === eggId,
                  lowerMatch: w.toLowerCase() === eggId.toLowerCase()
                }))
              );

              if (isWatched) {
                // Check cooldown (1 minute per item, allow MythicalEgg/CommonEgg for testing)
                const itemKey = `egg_${eggId}`;
                const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
                const canNotify = now - lastNotified > NOTIFICATION_COOLDOWN;

                if (canNotify) {
                  productionLog(`üéâ [NOTIFICATIONS] RARE EGG DETECTED: ${eggId} (${newQuantity} in stock)`);
                  notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;

                  // Track that we notified this item during restock
                  if (isRestockWindow) {
                    eggRestockNotifiedItems.add(eggId);
                  }

                  MGA_saveJSON('MGA_data', UnifiedState.data);

                  // Collect item for batch notification instead of notifying immediately
                  detectedItems.push({
                    type: 'egg',
                    id: eggId,
                    quantity: newQuantity,
                    icon: 'ü•ö'
                  });
                } else {
                  productionLog(`‚è∞ [NOTIFICATIONS] ${eggId} on cooldown, not notifying`);
                }
              } else {
                productionLog(`‚ùå [NOTIFICATIONS] ${eggId} is not watched, skipping notification`);
              }
            } else {
              productionLog(`‚è≠Ô∏è [NOTIFICATIONS] ${eggId} shouldCheck=false, skipping`);
            }
          });

          productionLog(`‚úÖ [NOTIFICATIONS] Finished checking all eggs`);

          // Update egg inventory and quantities INSIDE try block
          // CRITICAL FIX: Create copies instead of reference assignment
          previousEggInventory = [...currentEggIds];
          previousEggQuantities = { ...currentEggQuantities };
        } catch (eggError) {
          console.error(`‚ùå [NOTIFICATIONS] Error checking eggs:`, eggError);
        }

        productionLog(`‚úÖ [NOTIFICATIONS] Finished checking eggs, moving to decor...`);

        // Check decor shop (hourly resets)
        let currentDecorIds = [];
        const currentDecorQuantities = {};

        try {
          // Ensure watchedDecor exists (backwards compatibility)
          if (!notifications.watchedDecor) {
            notifications.watchedDecor = [];
          }

          productionLog(`üé® [NOTIFICATIONS] === CHECKING DECOR SHOP ===`);
          const currentDecor = targetWindow?.globalShop?.shops?.decor?.inventory || [];
          const inStockDecor = currentDecor.filter(item => item.initialStock > 0);
          currentDecorIds = inStockDecor.map(item => item.decorId);

          // Always log current decor state for debugging
          productionLog(
            `üé® [NOTIFICATIONS] Current decor in shop: [${currentDecorIds.join(', ')}] | Previous: [${previousDecorInventory.join(', ')}]`
          );
          productionLog(
            `üé® [NOTIFICATIONS] Raw decor inventory:`,
            currentDecor.map(d => `${d.decorId}(stock:${d.initialStock})`)
          );

          // Debug decor shop structure
          if (currentDecor.length === 0) {
            productionLog(`üé® [NOTIFICATIONS] No decor found. Shop structure:`, {
              hasGlobalShop: !!targetWindow?.globalShop,
              hasShops: !!targetWindow?.globalShop?.shops,
              hasDecorShop: !!targetWindow?.globalShop?.shops?.decor,
              hasDecorInventory: !!targetWindow?.globalShop?.shops?.decor?.inventory,
              decorInventoryLength: targetWindow?.globalShop?.shops?.decor?.inventory?.length || 0
            });
          }

          // Track decor quantities
          inStockDecor.forEach(item => {
            currentDecorQuantities[item.decorId] = item.initialStock;
          });

          // Initialize previous quantities if empty (first run)
          if (Object.keys(previousDecorQuantities).length === 0 && !decorRestocked) {
            productionLog(`üîß [NOTIFICATIONS] Initializing previous decor quantities...`);
            Object.keys(currentDecorQuantities).forEach(decorId => {
              previousDecorQuantities[decorId] = currentDecorQuantities[decorId];
            });
          }

          productionLog(
            `üé® [NOTIFICATIONS] Current decor quantities:`,
            currentDecorQuantities,
            `| Previous:`,
            previousDecorQuantities
          );

          // Find decor with increased quantities or new items (after restock)
          Object.keys(currentDecorQuantities).forEach(decorId => {
            const oldQuantity = previousDecorQuantities[decorId] || 0;
            const newQuantity = currentDecorQuantities[decorId];

            // Always log each decor being processed for debugging
            productionLog(`üîç [NOTIFICATIONS] Processing decor: ${decorId} (${oldQuantity}‚Üí${newQuantity})`);

            // Determine if we should check for notification
            const quantityIncreased = newQuantity > oldQuantity;
            const isRestockWindow = decorRestocked && now - lastDecorRestock < RESTOCK_COOLDOWN;
            const alreadyNotifiedInRestock = decorRestockNotifiedItems.has(decorId);

            productionLog(
              `üîç [NOTIFICATIONS] ${decorId} check logic: quantityIncreased=${quantityIncreased}, isRestockWindow=${isRestockWindow}, alreadyNotifiedInRestock=${alreadyNotifiedInRestock}`
            );

            const shouldCheck =
              (isFirstRun && newQuantity > 0) ||
              (quantityIncreased && !isRestockWindow) ||
              (isRestockWindow && !alreadyNotifiedInRestock) ||
              (oldQuantity === 0 && newQuantity > 0);

            productionLog(`üîç [NOTIFICATIONS] ${decorId} shouldCheck: ${shouldCheck}`);

            if (shouldCheck) {
              productionLog(
                `üÜï [NOTIFICATIONS] Decor stock change: ${decorId} (${oldQuantity}‚Üí${newQuantity}) | Restock: ${decorRestocked} | RestockWindow: ${isRestockWindow}`
              );

              // Update last seen for ANY decor that appears or increases
              updateLastSeen(decorId);

              // Check if it's a watched decor item
              const isWatched = isWatchedItem(decorId, 'decor');
              productionLog(`üîç [NOTIFICATIONS] Is ${decorId} watched? ${isWatched}`);
              productionLog(`üîç [NOTIFICATIONS] Watched list: [${notifications.watchedDecor.join(', ')}]`);

              if (isWatched) {
                // Check cooldown (1 minute per item)
                const itemKey = `decor_${decorId}`;
                const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
                const canNotify = now - lastNotified > NOTIFICATION_COOLDOWN;

                if (canNotify) {
                  productionLog(`üéâ [NOTIFICATIONS] WATCHED DECOR DETECTED: ${decorId} (${newQuantity} in stock)`);
                  notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;

                  // Track that we notified this item during restock
                  if (isRestockWindow) {
                    decorRestockNotifiedItems.add(decorId);
                  }

                  MGA_saveJSON('MGA_data', UnifiedState.data);

                  // Collect item for batch notification
                  detectedItems.push({
                    type: 'decor',
                    id: decorId,
                    quantity: newQuantity,
                    icon: 'üé®'
                  });
                } else {
                  productionLog(`‚è∞ [NOTIFICATIONS] ${decorId} on cooldown, not notifying`);
                }
              } else {
                productionLog(`‚ùå [NOTIFICATIONS] ${decorId} is not watched, skipping notification`);
              }
            } else {
              productionLog(`‚è≠Ô∏è [NOTIFICATIONS] ${decorId} shouldCheck=false, skipping`);
            }
          });

          productionLog(`‚úÖ [NOTIFICATIONS] Finished checking all decor`);

          // Update decor inventory and quantities
          previousDecorInventory = [...currentDecorIds];
          previousDecorQuantities = { ...currentDecorQuantities };
        } catch (decorError) {
          console.error(`‚ùå [NOTIFICATIONS] Error checking decor:`, decorError);
        }

        // Process batch notifications if any items were detected
        if (detectedItems.length > 0) {
          productionLog(`üéâ [NOTIFICATIONS] Batch detected: ${detectedItems.length} items`);

          // Play notification sound once for all items (custom or default)
          const volume = UnifiedState.data.settings.notifications.volume || 0.3;
          playShopNotificationSound(volume);

          // Create notification message based on number of items
          let notificationMessage;
          if (detectedItems.length === 1) {
            const item = detectedItems[0];
            notificationMessage = `${item.icon} Rare ${item.type} in shop: ${item.id}! (${item.quantity} available)`;
          } else {
            notificationMessage = `üéâ Multiple items in stock:\n`;
            detectedItems.forEach(item => {
              notificationMessage += `${item.icon} ${item.id} (${item.quantity} available)\n`;
            });
          }

          // Queue the batch notification
          queueNotification(notificationMessage.trim(), notifications.requiresAcknowledgment);
          productionLog(`üì¢ [NOTIFICATIONS] Batched notification sent for ${detectedItems.length} items`);
        }

        // Update previous seed inventory and quantities (seeds already succeeded if we got here)
        // CRITICAL FIX: Create copies instead of reference assignment
        previousSeedInventory = [...currentSeedIds];
        previousSeedQuantities = { ...currentSeedQuantities };

        // Clear first run flag after first check completes
        if (isFirstRun) {
          productionLog(`‚úÖ [NOTIFICATIONS] First run complete - will now only notify on changes`);
          isFirstRun = false;
        }
      } catch (error) {
        console.error('‚ùå [NOTIFICATIONS] Error checking for watched items:', error);
        console.error('Stack trace:', error.stack);
        // Don't let errors stop the notification system - it will try again next interval
      }
    }

    // ==================== HUA AUTO-BUY SYSTEM ====================

    const AUTO_BUY_ITEMS = ['Carrot'];

    let autoBuyInitizlied = false;
    let autoBuyInterval = null;

    function initializeAutoBuy() {
      if (autoBuyInitizlied) return;

      productionLog('Auto buy initializing auto buy system', AUTO_BUY_ITEMS);

      autoBuyInterval = setInterval(() => {
        checkAndBuyItems()
      }, 3000);

      autoBuyInitizlied = true;
      productionLog('Auto buy initializied');
     }

     function checkAndBuyItems() {
      try {
        if (AUTO_BUY_ITEMS.length === 0) {
          return;
        }

        const shop = targetWindow?.globalShop?.shop;
        if(!shop) {
          return;
        }

        AUTO_BUY_ITEMS.forEach(itemId => {
          const shopTypes = ['seed', 'egg', 'tool', 'decor'];
          for (const shopType of shopTypes) {
            if (!shop || !shop.item) continue;
            const item = shop.items.find(i => i.id === itemId || i.species === itemId || i.name === itemId);

            if (item && item.stock > 0) {
                const stock = item.stock;

                if (UnifiedState.data.settings.debugMode) {
                  productionLog(`Auto buy found ${itemId} with stock: ${stock}`);
                }

                autoBuyItem(itemId, shopType, 1);

                break;
            }
          }
        })
      } catch (error) {
        console.error('Auto buy error checking for itesm: ', error);
      }
     }

     async function autoBuyItem(itemId, shopType, amount) {
      try {
        if (UnifiedState.data.settings.debugMode) {
          productionLog(`Auto buy attemping to buy ${itemId} with stock: ${stock}`);
        }

        const payload = {
          type: 'BuyShopItem',
          shopType: shopType,
          itemId: itemId,
          amount: amount
        };
        await rcSend(payload);
        productionLog(`Auto buy Purchased  ${itemId} with stock: ${stock}`);
        showNotificationToast(`Auto buy ${itemId} x  ${stock}`, 'success');
      } catch (error) {
        console.error(`Auto buy error checking for ${itemId}: `, error);
      }
     }

     targetWindow.autoBuyDebug = {
      checkAndBuyItems,
      getItems: () => AUTO_BUY_ITEMS,
      testBuy: () => {
        productionLog('Auto buy manula tet trigger');
        checkAndBuyItems()
      }
     };

    // ==================== EVENT-DRIVEN SHOP MONITORING ====================

    let shopWatcherInitialized = false;

    // Pattern-based egg restock detection variables
    let lastEggSeconds = null;
    let eggWasDecreasing = false;
    let refreshDebounceTimer = null;

    // Debounced refresh function to prevent multiple rapid refreshes
    function scheduleRefresh(type, shopValue) {
      if (refreshDebounceTimer) {
        clearTimeout(refreshDebounceTimer);
      }

      refreshDebounceTimer = setTimeout(() => {
        productionLog(`üîÑ [SHOP-REFRESH] Refreshing ${type} shop after pattern-based restock detection`);
        checkForWatchedItems();
        refreshAllShopWindows();
        refreshDebounceTimer = null;
      }, 100);
    }

    function handleEggRestockDetection(curr, shopValue) {
      // first reading
      if (lastEggSeconds === null) {
        lastEggSeconds = curr;
        return;
      }

      // detect pattern change
      if (curr < lastEggSeconds) {
        // countdown decreasing normally
        eggWasDecreasing = true;
      } else if (eggWasDecreasing && curr > lastEggSeconds + 2) {
        // countdown started increasing again after decreasing
        productionLog('üê£ Egg restock detected (pattern-based jump)', { curr, lastEggSeconds });

        // reset tracker
        eggWasDecreasing = false;
        lastEggSeconds = curr;

        // reset local purchase tracking for egg shop
        resetLocalPurchases('egg');

        // trigger refresh safely (debounced)
        scheduleRefresh('egg', shopValue);
        return;
      }

      // keep tracking
      lastEggSeconds = curr;
    }

    // Tool shop restock detection
    let toolWasDecreasing = false;
    let lastToolSeconds = 0;

    setManagedInterval(
      'toolRestockWatch',
      () => {
        const toolShop = targetWindow?.globalShop?.shops?.tool;
        if (!toolShop || !toolShop.secondsUntilRestock) return;

        const curr = toolShop.secondsUntilRestock;

        if (curr < lastToolSeconds) {
          toolWasDecreasing = true;
        } else if (toolWasDecreasing && curr > lastToolSeconds + 2) {
          productionLog('üîß Tool restock detected (pattern-based jump)', { curr, lastToolSeconds });
          toolWasDecreasing = false;
          lastToolSeconds = curr;
          resetLocalPurchases('tool');
          scheduleRefresh('tool', toolShop);
        }

        lastToolSeconds = curr;
      },
      1000
    );

    function initializeShopWatcher() {
      if (shopWatcherInitialized) return;

      productionLog('üîÑ [SHOP-WATCHER] Initializing event-driven shop monitoring...');

      // Try to find and watch globalShop
      function watchShopData() {
        if (!targetWindow.globalShop) {
          productionWarn('‚ö†Ô∏è [SHOP-WATCHER] globalShop not found, will retry...');
          setTimeout(watchShopData, 5000);
          return;
        }

        productionLog('‚úÖ [SHOP-WATCHER] Found globalShop, setting up watchers...');

        // Store original shop data
        const lastSeedData = JSON.stringify(targetWindow.globalShop?.shops?.seed || {});
        const lastEggData = JSON.stringify(targetWindow.globalShop?.shops?.egg || {});
        const lastDecorData = JSON.stringify(targetWindow.globalShop?.shops?.decor || {});

        // Use lightweight restock detection instead of heavy JSON.stringify
        let lastSeedRestock = 0;
        let lastEggRestock = 0;
        let lastDecorRestock = 0;

        setInterval(() => {
          try {
            if (!targetWindow.globalShop || !targetWindow.globalShop.shops) return;

            const shops = targetWindow.globalShop.shops;

            // Lightweight check: only compare secondsUntilRestock (resets to high number on restock)
            if (shops.seed) {
              const currentRestock = shops.seed.secondsUntilRestock || 0;
              if (lastSeedRestock > 100 && currentRestock > lastSeedRestock) {
                // Restock detected (timer reset to high value)
                productionLog('üîÑ [SHOP-WATCHER] Seed shop restocked');
                resetLocalPurchases('seed');
                setTimeout(() => {
                  checkForWatchedItems();
                  refreshAllShopWindows();
                }, 0);
              }
              lastSeedRestock = currentRestock;
            }

            if (shops.egg) {
              const currentRestock = shops.egg.secondsUntilRestock || 0;

              // Use pattern-based detection for egg shop
              if (typeof currentRestock === 'number') {
                handleEggRestockDetection(currentRestock, shops.egg);
              }

              // Keep the fallback detection too
              if (lastEggRestock > 100 && currentRestock > lastEggRestock) {
                productionLog('üîÑ [SHOP-WATCHER] Egg shop restocked (fallback detection)');
                resetLocalPurchases('egg');
                setTimeout(() => {
                  checkForWatchedItems();
                  refreshAllShopWindows();
                }, 0);
              }
              lastEggRestock = currentRestock;
            }

            if (shops.decor) {
              const currentRestock = shops.decor.secondsUntilRestock || 0;
              if (lastDecorRestock > 100 && currentRestock > lastDecorRestock) {
                productionLog('üîÑ [SHOP-WATCHER] Decor shop restocked');
                setTimeout(() => checkForWatchedItems(), 0);
              }
              lastDecorRestock = currentRestock;
            }
          } catch (e) {
            // Silent fail
          }
        }, 5000); // Poll every 5 seconds - lightweight check

        productionLog('‚úÖ [SHOP-WATCHER] Using lightweight restock detection (5s interval)');

        // Also watch for complete globalShop replacement
        const globalShopDescriptor = Object.getOwnPropertyDescriptor(targetWindow, 'globalShop');
        if (!globalShopDescriptor || globalShopDescriptor.configurable !== false) {
          Object.defineProperty(targetWindow, 'globalShop', {
            get() {
              return this._globalShop;
            },
            set(newValue) {
              productionLog('üîÑ [SHOP-WATCHER] globalShop replaced entirely!');
              this._globalShop = newValue;

              // Re-initialize watchers for the new shop
              shopWatcherInitialized = false;
              setTimeout(() => initializeShopWatcher(), 100);

              // Trigger immediate check
              setTimeout(() => checkForWatchedItems(), 0);
            },
            configurable: true
          });

          // Set initial value
          targetWindow._globalShop = targetWindow.globalShop;
          productionLog('‚úÖ [SHOP-WATCHER] globalShop setter installed');
        }

        shopWatcherInitialized = true;
      }

      // Start watching
      watchShopData();

      // HUA AUTO-BUY SYSTEM
      initializeAutoBuy();

      // DISABLED: MutationObserver causes severe FPS lag - relying on Proxy and polling only
      // if (typeof MutationObserver !== 'undefined') {
      //     const observer = new MutationObserver((mutations) => {
      //         for (const mutation of mutations) {
      //             if (mutation.target.classList?.contains('shop') ||
      //                 mutation.target.id?.includes('shop') ||
      //                 mutation.target.textContent?.includes('Restock')) {
      //                 productionLog('üîÑ [SHOP-WATCHER] Shop DOM changed, checking items...');
      //                 setTimeout(() => checkForWatchedItems(), 100);
      //                 break;
      //             }
      //         }
      //     });
      //     const gameContainer = targetDocument.querySelector('#game-container, .game-wrapper, body');
      //     if (gameContainer) {
      //         observer.observe(gameContainer, { childList: true, subtree: true, characterData: true });
      //     }
      // }
    }

    // ==================== PET HUNGER MONITORING ====================

    // Species max hunger values from wiki
    // Source: https://magicgarden.fandom.com/wiki/Pets
    const SPECIES_MAX_HUNGER = {
      Worm: 500,
      Snail: 1000,
      Bee: 1500,
      Chicken: 3000,
      Bunny: 750,
      Dragonfly: 250,
      Pig: 50000,
      Cow: 25000,
      Turtle: 100000,
      Goat: 20000,
      Squirrel: 15000,
      Capybara: 150000,
      Butterfly: 25000,
      Peacock: 100000
    };

    // Per-species hunger depletion times (milliseconds from full to 0)
    // Source: https://magicgarden.fandom.com/wiki/Pets
    const SPECIES_HUNGER_DEPLETION_TIME = {
      Worm: 30 * 60 * 1000,
      Snail: 60 * 60 * 1000,
      Bee: 15 * 60 * 1000,
      Chicken: 60 * 60 * 1000,
      Bunny: 45 * 60 * 1000,
      Dragonfly: 15 * 60 * 1000,
      Pig: 60 * 60 * 1000,
      Cow: 75 * 60 * 1000,
      Turtle: 90 * 60 * 1000,
      Goat: 60 * 60 * 1000,
      Squirrel: 30 * 60 * 1000,
      Capybara: 60 * 60 * 1000,
      Butterfly: 30 * 60 * 1000,
      Peacock: 60 * 60 * 1000
    };

    const HUNGER_BOOST_VALUES = {
      'Hunger Boost I': 0.12, // 12% reduction per 100 STR
      'Hunger Boost II': 0.16 // 16% reduction per 100 STR
    };

    // Track previous hunger states for each pet (declared earlier at top scope, initialized there)
    // lastPetHungerStates already initialized at declaration
    const petHungerLastAlertTime = {}; // BUGFIX: Track when we last alerted per pet (timestamp) for time-based throttle

    function checkPetHunger() {
      if (!UnifiedState.data.settings.notifications.petHungerEnabled) return;

      try {
        // BUGFIX: Use window.activePets which has the REAL atom data with full hunger values
        // UnifiedState.atoms.activePets might be stale or incomplete
        const activePets = window.activePets || UnifiedState.atoms.activePets || [];
        // Threshold is a PERCENTAGE (0-100)
        // Default: 25 = alert when pet drops below 25% full
        const thresholdPercent = UnifiedState.data.settings.notifications.petHungerThreshold || 25;

        activePets.forEach(pet => {
          if (!pet || !pet.id) return;

          // BUGFIX: Check if hunger data exists before processing
          const currentHunger = pet.hunger !== undefined ? Number(pet.hunger) : null;
          if (currentHunger === null || isNaN(currentHunger)) {
            productionLog(`‚ö†Ô∏è [PET-HUNGER] ${pet.petSpecies || 'Pet'} has no hunger data - skipping`);
            return; // Skip this pet if no hunger data
          }

          const petName = pet.petSpecies || 'Pet';

          // BUGFIX: Different species have different max hunger values
          // Source: https://magicgarden.fandom.com/wiki/Pets
          // Lower hunger = hungrier (inverse system!)
          const estimatedMaxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 100000;

          // Calculate percentage based on species max
          const hungerPercent = (currentHunger / estimatedMaxHunger) * 100;

          // Get previous hunger percentage for comparison
          const lastHunger = lastPetHungerStates[pet.id] ?? currentHunger;
          const lastPercent = (lastHunger / estimatedMaxHunger) * 100;

          // BUGFIX: Time-based throttle instead of boolean flag to allow re-alerting
          const ALERT_THROTTLE_MS = 5 * 60 * 1000; // 5 minutes between alerts
          const now = Date.now();
          const lastAlertTime = petHungerLastAlertTime[pet.id] || 0;
          const timeSinceLastAlert = now - lastAlertTime;

          // Debug logging (only when enabled)
          if (UnifiedState.data.settings?.debugMode) {
            productionLog(
              `üêæ [PET-HUNGER-DEBUG] ${petName} (ID: ${pet.id}): ${hungerPercent.toFixed(1)}% (hunger=${currentHunger}/${estimatedMaxHunger}), threshold=${thresholdPercent}%, lastPercent=${lastPercent.toFixed(1)}%, timeSinceLastAlert=${(timeSinceLastAlert / 1000).toFixed(0)}s`
            );
          }

          // Critical thresholds that alert every 1 minute (more urgent than normal 5 min throttle)
          const CRITICAL_THROTTLE_MS = 60 * 1000; // 1 minute for critical alerts
          const isCritical = hungerPercent <= 1;
          const criticalNeedsAlert = isCritical && (timeSinceLastAlert >= CRITICAL_THROTTLE_MS || !lastAlertTime);

          // Alert if below threshold and enough time has passed since last alert
          const needsAlert =
            hungerPercent < thresholdPercent &&
            hungerPercent > 1 &&
            (timeSinceLastAlert >= ALERT_THROTTLE_MS || !lastAlertTime);

          // Also alert if hunger DROPPED below threshold since last check (crossing behavior)
          const justCrossed = hungerPercent < thresholdPercent && lastPercent >= thresholdPercent;

          if (needsAlert || justCrossed || criticalNeedsAlert) {
            const reason = isCritical
              ? 'CRITICAL hunger level'
              : justCrossed
                ? 'crossed threshold'
                : 'below threshold (throttle expired)';
            productionLog(
              `üêæ [PET-HUNGER] ${petName} is getting hungry! (${hungerPercent.toFixed(1)}% < ${thresholdPercent}%) - Reason: ${reason}`
            );

            // Play different sound for pet hunger (custom or default)
            const volume = UnifiedState.data.settings.notifications.volume || 0.3;
            playPetNotificationSound(volume);

            // Show visual notification with percentage
            showNotificationToast(`‚ö†Ô∏è ${petName} needs feeding! Only ${Math.round(hungerPercent)}% full`, 'warning');

            // Update last alert timestamp
            petHungerLastAlertTime[pet.id] = now;
          }

          // Reset alert timestamp if pet is fed above threshold (allows immediate alert on next drop)
          if (hungerPercent >= thresholdPercent && lastAlertTime > 0) {
            delete petHungerLastAlertTime[pet.id];
            if (UnifiedState.data.settings?.debugMode) {
              productionLog(`üêæ [PET-HUNGER-DEBUG] ${petName} fed above threshold, reset alert timer`);
            }
          }

          // Store hunger value for next comparison
          lastPetHungerStates[pet.id] = currentHunger;
        });
      } catch (error) {
        console.error('‚ùå [PET-HUNGER] Error checking pet hunger:', error);
      }
    }

    // BUGFIX: Scan all active pets and alert for any currently below threshold
    // This is called when user enables pet hunger alerts
    function scanAndAlertHungryPets() {
      if (!UnifiedState.data.settings.notifications.petHungerEnabled) return;

      try {
        // BUGFIX: Use window.activePets which has the REAL atom data with full hunger values
        const activePets = window.activePets || UnifiedState.atoms.activePets || [];
        const thresholdPercent = UnifiedState.data.settings.notifications.petHungerThreshold || 25;
        const MAX_HUNGER = 100000;
        const now = Date.now();

        let hungryCount = 0;

        activePets.forEach(pet => {
          if (!pet || !pet.id) return;

          // BUGFIX: Check if hunger data exists before processing
          const currentHunger = pet.hunger !== undefined ? Number(pet.hunger) : null;
          if (currentHunger === null || isNaN(currentHunger)) {
            productionLog(`‚ö†Ô∏è [PET-HUNGER] ${pet.petSpecies || 'Pet'} has no hunger data in scan - skipping`);
            return; // Skip this pet if no hunger data
          }

          // BUGFIX: Different species have different max hunger values
          // Source: https://magicgarden.fandom.com/wiki/Pets
          const estimatedMaxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 100000;
          const hungerPercent = (currentHunger / estimatedMaxHunger) * 100;
          const petName = pet.petSpecies || 'Pet';

          // Alert for any pet currently below threshold
          if (hungerPercent < thresholdPercent) {
            hungryCount++;
            productionLog(
              `üêæ [PET-HUNGER] Initial scan: ${petName} needs feeding! (${hungerPercent.toFixed(1)}% < ${thresholdPercent}%)`
            );

            // Show notification for this pet
            showNotificationToast(`‚ö†Ô∏è ${petName} needs feeding! Only ${Math.round(hungerPercent)}% full`, 'warning');

            // Mark with timestamp to enable time-based throttle
            petHungerLastAlertTime[pet.id] = now;
            lastPetHungerStates[pet.id] = currentHunger;
          }
        });

        if (hungryCount > 0) {
          // Play sound once for all hungry pets (custom or default)
          const volume = UnifiedState.data.settings.notifications.volume || 0.3;
          playPetNotificationSound(volume);
          productionLog(`üêæ [PET-HUNGER] Initial scan found ${hungryCount} hungry pet(s)`);
        } else {
          productionLog(`üêæ [PET-HUNGER] Initial scan: All pets are well-fed`);
        }
      } catch (error) {
        console.error('‚ùå [PET-HUNGER] Error scanning for hungry pets:', error);
      }
    }

    // Calculate time until pet becomes hungry (returns milliseconds)
    function calculateTimeUntilHungry(pet) {
      if (!pet || typeof pet.hunger === 'undefined') return null;

      const currentHunger = Number(pet.hunger) || 0;
      const maxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 100000;
      const baseDepletionTime = SPECIES_HUNGER_DEPLETION_TIME[pet.petSpecies] || 60 * 60 * 1000;

      // If already hungry, return 0
      if (currentHunger <= 0) return 0;

      // Calculate total hunger reduction from all pets' Hunger Boost abilities
      let totalHungerReduction = 0;
      const activePets = window.activePets || UnifiedState.atoms.activePets || [];

      // DEBUG: Log active pets and their abilities (using console.log to bypass PRODUCTION mode)
      if (UnifiedState.data.settings?.debugMode) {
        console.log('üçñ [HUNGER-CALC] Calculating for pet:', pet.petSpecies);
        console.log('üçñ [HUNGER-CALC] Active pets:', activePets.length);
        activePets.forEach((p, i) => {
          console.log(`üçñ [HUNGER-CALC] Pet ${i}:`, {
            species: p.petSpecies,
            abilities: p.abilities,
            strength: p.strength,
            str: p.str
          });
        });
      }

      activePets.forEach(p => {
        if (p.abilities && Array.isArray(p.abilities)) {
          p.abilities.forEach(ability => {
            if (UnifiedState.data.settings?.debugMode) {
              console.log('üçñ [HUNGER-CALC] Checking ability:', ability);
            }
            // Ability can be either a string directly or an object with properties
            const abilityType = typeof ability === 'string' ? ability : ability.abilityType || ability.type || ability;
            if (typeof abilityType === 'string') {
              // Check for both "Hunger Boost" (with space) and "HungerBoost" (without space)
              if (abilityType.includes('HungerBoost') || abilityType.includes('Hunger Boost')) {
                // Hunger Boost I = 12% per 100 STR, Hunger Boost II = 16% per 100 STR
                const reduction = abilityType.includes('II')
                  ? HUNGER_BOOST_VALUES['Hunger Boost II']
                  : HUNGER_BOOST_VALUES['Hunger Boost I'];
                const strength = (p.strength || p.str || 100) / 100;
                totalHungerReduction += reduction * strength;

                if (UnifiedState.data.settings?.debugMode) {
                  console.log(
                    `üçñ [HUNGER-CALC] Found ${abilityType} on ${p.petSpecies}, STR: ${p.strength || p.str}, reduction: ${reduction}, strength mult: ${strength}`
                  );
                }
              }
            }
          });
        }
      });

      if (UnifiedState.data.settings?.debugMode && totalHungerReduction > 0) {
        console.log(`üçñ [HUNGER-CALC] Total hunger reduction: ${(totalHungerReduction * 100).toFixed(1)}%`);
      }

      // Cap reduction at 90% to avoid division by zero
      totalHungerReduction = Math.min(totalHungerReduction, 0.9);

      // Calculate time remaining: baseTime / (1 - reductions) * (current/max)
      const timeRemaining = (baseDepletionTime / Math.max(0.1, 1 - totalHungerReduction)) * (currentHunger / maxHunger);

      return Math.max(0, Math.round(timeRemaining));
    }

    // Format milliseconds as readable timer string (minutes only)
    function formatHungerTimer(milliseconds) {
      if (!milliseconds || milliseconds <= 0) return 'Hungry!';

      const totalMinutes = Math.ceil(milliseconds / (60 * 1000));
      return `${totalMinutes}m`;
    }

    // Helper function to show toast notifications
    function showNotificationToast(message, type = 'info') {
      try {
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.cssText = `
                  position: fixed;
                  top: 80px;
                  right: 20px;
                  padding: 12px 20px;
                  background: ${type === 'warning' ? 'rgba(255, 165, 0, 0.9)' : type === 'success' ? 'rgba(76, 175, 80, 0.9)' : 'rgba(33, 150, 243, 0.9)'};
                  color: white;
                  border-radius: 8px;
                  font-size: 14px;
                  font-weight: bold;
                  z-index: 2147483647;
                  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                  max-width: 300px;
                  word-wrap: break-word;
                  transition: opacity 0.3s ease;
              `;

        document.body.appendChild(toast);

        // Fade out and remove after 5 seconds
        setTimeout(() => {
          toast.style.opacity = '0';
          setTimeout(() => toast.remove(), 300);
        }, 5000);
      } catch (error) {
        console.error('‚ùå [TOAST] Error showing notification toast:', error);
      }
    }

    // ==================== WEATHER EVENT DETECTION ====================

    // Weather event tracking
    let lastWeatherState = null;

    function detectWeatherEvents() {
      if (!UnifiedState.data.settings.notifications.weatherNotificationsEnabled) return;

      try {
        // Check game state for weather (adjust based on actual game structure)
        const roomState = targetWindow?.MagicCircle_RoomConnection?.lastRoomStateJsonable;
        const currentWeather = roomState?.child?.data?.weather || roomState?.weather || null;

        if (currentWeather && currentWeather !== lastWeatherState) {
          const watchedEvents = UnifiedState.data.settings.notifications.watchedWeatherEvents || [];

          // Check if this is a watched weather event
          const eventMapping = {
            snow: 'Snow',
            rain: 'Rain',
            amber_moon: 'AmberMoon',
            ambermoon: 'AmberMoon',
            dawn: 'Dawn'
          };

          const mappedEvent = eventMapping[currentWeather.toLowerCase()] || currentWeather;

          if (watchedEvents.includes(mappedEvent)) {
            productionLog(`üå§Ô∏è [WEATHER] ${mappedEvent} event detected!`);

            // Play weather notification (custom or default)
            const volume = UnifiedState.data.settings.notifications.volume || 0.3;
            playWeatherNotificationSound(volume);

            // Show notification
            showNotificationToast(`üå§Ô∏è Weather Event: ${mappedEvent}`, 'info');
          }

          lastWeatherState = currentWeather;
        }
      } catch (error) {
        console.error('‚ùå [WEATHER] Error detecting weather events:', error);
      }
    }

    function getProtectTabContent() {
      const lockedCrops = UnifiedState.data.lockedCrops || {};
      const sellThreshold = UnifiedState.data.sellBlockThreshold || 1.0;

      return `
              <div class="mga-section">
                  <div class="mga-section-title">üîí Crop Protection</div>
                  <div style="padding: 12px; background: rgba(74, 158, 255, 0.30); border-radius: 6px; border-left: 3px solid #4a9eff; margin-bottom: 16px;">
                      <p style="margin-bottom: 8px; font-size: 13px;"><strong>How it works:</strong></p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ <strong>Lock crops</strong> to prevent accidental harvesting</p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ All crops are <strong>unlocked by default</strong></p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ Locked crops <strong>cannot be harvested</strong> until unlocked</p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ <strong>Lock All Mutations:</strong> Locks all mutation types at once</p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ <strong>Lock Only Non-Mutated:</strong> Locks ONLY crops with 0 mutations</p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üå± Lock Specific Crops</div>
                  <div style="margin-bottom: 12px;">
                      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock by Species:</label>
                      <div id="protect-species-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-bottom: 12px;">
                          <!-- Species checkboxes will be generated here -->
                      </div>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock by Mutations:</label>
                      <div id="protect-mutations-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-bottom: 12px;">
                          <!-- Mutation checkboxes will be generated here -->
                      </div>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <button id="protect-clear-all" class="mga-button" style="background: rgba(239, 68, 68, 0.48); border: 1px solid rgba(239, 68, 68, 0.4);">
                          üîì Unlock All Crops
                      </button>
                  </div>

                  <div style="margin-top: 20px; padding: 15px; background: rgba(100, 200, 255, 0.30); border-radius: 8px; border: 1px solid rgba(100,200,255,0.3);">
                      <div style="font-weight: 600; margin-bottom: 10px; color: #64b5f6;">‚Ñó Advanced Settings</div>
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px;">
                          <input type="checkbox" id="allow-frozen-pickup" class="mga-checkbox"
                                 ${UnifiedState.data.protectionSettings?.allowFrozenPickup ? 'checked' : ''}>
                          <span>Allow pickup of protected crops when frozen</span>
                      </label>
                      <div style="font-size: 11px; color: #888; margin-top: 5px; margin-left: 26px;">
                          When enabled, locked Rainbow/Gold crops can still be harvested if they're frozen
                      </div>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üí∞ Crop Sell Protection</div>
                  <div style="margin-bottom: 12px;">
                      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Minimum Friend Bonus to Allow Selling Crops:</label>
                      <div style="display: flex; align-items: center; gap: 12px;">
                          <input type="range" id="protect-sell-threshold" min="1.0" max="1.5" step="0.05" value="${sellThreshold}"
                              style="flex: 1; height: 6px; background: rgba(74,158,255,0.3); border-radius: 3px; outline: none;">
                          <span id="protect-sell-threshold-value" style="min-width: 80px; font-weight: 600; color: #4a9eff;">${sellThreshold.toFixed(2)}x (${((sellThreshold - 1) * 100).toFixed(0)}%)</span>
                      </div>
                      <p style="font-size: 11px; color: #888; margin-top: 8px;">
                          Set to 1.0x to allow selling anytime. Max 1.5x (50% bonus). Higher values require better friend bonus.
                      </p>
                      <p style="font-size: 11px; color: #4a9eff; margin-top: 8px; font-weight: 600;">
                          Note: Friend bonus does NOT affect pet selling in the game.
                      </p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üêæ Pet Protection</div>
                  <div style="padding: 12px; background: rgba(74, 158, 255, 0.30); border-radius: 6px; border-left: 3px solid #4a9eff; margin-bottom: 16px;">
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ Lock pets by ability to prevent accidental selling</p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ Protect valuable pets with rare abilities</p>
                  </div>
                  <div style="margin-bottom: 12px;">
                      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock Pets with These Abilities:</label>
                      <div id="protect-pet-abilities-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px;">
                          <!-- Pet ability checkboxes will be generated here -->
                      </div>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üèõÔ∏è Decor Protection</div>
                  <div style="padding: 12px; background: rgba(74, 158, 255, 0.30); border-radius: 6px; border-left: 3px solid #4a9eff; margin-bottom: 16px;">
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ Lock decor items to prevent accidental pickup</p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ All decor is <strong>unlocked by default</strong></p>
                  </div>
                  <div style="margin-bottom: 12px;">
                      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock by Decor Type:</label>
                      <div id="protect-decor-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; max-height: 300px; overflow-y: auto; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                          <!-- Decor checkboxes will be generated here -->
                      </div>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üìã Currently Protected</div>
                  <div id="protect-status-display" style="padding: 12px; background: rgba(0, 0, 0, 0.48); border-radius: 6px; font-size: 12px; min-height: 60px;">
                      <div style="color: #888;">No crops are currently locked.</div>
                  </div>
              </div>
          `;
    }

    function getHelpTabContent() {
      return `
              <div class="mga-section">
                  <div class="mga-section-title">üöÄ Getting Started</div>
                  <div style="margin-bottom: 16px;">
                      <p style="margin-bottom: 8px;"><strong>Magic Garden Unified</strong> provides a hybrid dock interface with powerful tools for managing pets, tracking abilities, shop automation, and resource monitoring.</p>
                      <p style="margin-bottom: 8px;">Click dock icons to open sidebars, or Shift+Click to open floating widgets. Drag the dock from its edges to reposition.</p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üéõÔ∏è Dock Controls</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Click Icon:</strong> Opens slide-out sidebar</li>
                      <li style="margin-bottom: 4px;"><strong>Shift+Click Icon:</strong> Opens floating popout widget</li>
                      <li style="margin-bottom: 4px;"><strong>Drag from edges:</strong> Reposition the dock (grab cursor appears near edges)</li>
                      <li style="margin-bottom: 4px;"><strong>‚Üî Icon:</strong> Toggle horizontal/vertical orientation</li>
                      <li style="margin-bottom: 4px;"><strong>‚ãØ Icon:</strong> Hover to reveal Tools, Settings, Hotkeys, Notifications, Help</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">‚å®Ô∏è Keyboard Shortcuts</div>
                  <div class="mga-help-grid" style="display: grid; grid-template-columns: auto 1fr; gap: 8px 12px; margin-bottom: 16px;">
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+=</code>
                      <span>Increase dock size (Micro ‚Üí Mini ‚Üí Tiny ‚Üí Small ‚Üí Medium ‚Üí Large)</span>
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+-</code>
                      <span>Decrease dock size (Large ‚Üí Medium ‚Üí Small ‚Üí Tiny ‚Üí Mini ‚Üí Micro)</span>
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+M</code>
                      <span>Toggle toolbar visibility (show/hide entire dock and sidebar)</span>
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+B</code>
                      <span>Toggle Shop (opens/closes both seed and egg sidebars)</span>
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Escape</code>
                      <span>Close shop sidebars</span>
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Custom</code>
                      <span>Set your own hotkeys for tabs and pet presets in Hotkeys tab (‚å®Ô∏è)</span>
                  </div>
                  <p style="font-size: 11px; color: #888; margin-top: 12px; padding: 8px; background: rgba(255, 200, 100, 0.30); border-radius: 4px; border-left: 3px solid #ffc864;">
                      <strong>‚ö†Ô∏è Note:</strong> Ctrl+1-9 removed to avoid conflicts with game hotbar controls.<br>
                      Use the Hotkeys tab to set custom keys for opening tabs and loading pet presets!
                  </p>
                  <p style="font-size: 11px; color: #888; margin-top: 8px; padding: 8px; background: rgba(74, 158, 255, 0.30); border-radius: 4px; border-left: 3px solid #4a9eff;">
                      <strong>üéÆ Pet Preset Hotkeys:</strong><br>
                      ‚Ä¢ Click "Set Hotkey" button next to any preset<br>
                      ‚Ä¢ Press your desired key combination<br>
                      ‚Ä¢ Hotkey will instantly load that preset when pressed<br>
                      ‚Ä¢ Perfect for quick pet swapping during gameplay!
                  </p>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üìä Turtle Timer & Slot Value</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Slot Value:</strong> Always shows when standing on crops (üí∞ gold text)</li>
                      <li style="margin-bottom: 4px;"><strong>Turtle Timer:</strong> Green countdown shown when turtle pet is active</li>
                      <li style="margin-bottom: 4px;"><strong>Display Location:</strong> Appears below crop growth timer in-game</li>
                      <li style="margin-bottom: 4px;"><strong>Values:</strong> Calculated from species value √ó scale √ó hybrid multiplier √ó friend bonus</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üî¥üü¢ Version Indicator</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Green Dot (‚óè):</strong> You're up to date! ‚úì</li>
                      <li style="margin-bottom: 4px;"><strong>Yellow Dot (‚óè):</strong> Development version (newer than GitHub)</li>
                      <li style="margin-bottom: 4px;"><strong>Red Dot (‚óè):</strong> Update available</li>
                      <li style="margin-bottom: 4px;"><strong>Orange Dot (‚óè):</strong> Version check failed (network/404 error)</li>
                      <li style="margin-bottom: 4px;"><strong>Click Dot:</strong> Manually refresh version check (bypasses GitHub cache)</li>
                      <li style="margin-bottom: 4px;"><strong>Shift+Click Dot:</strong> Open script on GitHub (when red/orange)</li>
                      <li style="margin-bottom: 4px;"><strong>Location:</strong> Hover ‚ãØ icon in dock to reveal version dot</li>
                      <li style="margin-bottom: 4px;"><strong>How it works:</strong> Checks GitHub for version.json or magicgardenunified.user.js (tries main/master branches with cache-busting)</li>
                      <li style="margin-bottom: 4px;"><strong>Cache delay:</strong> GitHub CDN caches files ~2-5 min, click dot to force refresh</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üêæ Pet Management</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Save Presets:</strong> Store your current pet setup with a custom name</li>
                      <li style="margin-bottom: 4px;"><strong>Load Presets:</strong> Quickly deploy saved pet configurations</li>
                      <li style="margin-bottom: 4px;"><strong>Reorder Presets:</strong> Use ‚Üë‚Üì arrows or drag-and-drop to organize your preset list</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üîí Crop Protection</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Lock Species:</strong> Prevent harvesting specific crop types (e.g., Pepper, Starweaver)</li>
                      <li style="margin-bottom: 4px;"><strong>Lock Mutations:</strong> Block harvesting crops with certain mutations (Rainbow, Frozen)</li>
                      <li style="margin-bottom: 4px;"><strong>All Unlocked by Default:</strong> Crops can be harvested normally until you lock them</li>
                      <li style="margin-bottom: 4px;"><strong>Sell Protection:</strong> Set minimum friend bonus threshold (1.0x-1.5x / 0%-50%) before selling allowed</li>
                      <li style="margin-bottom: 4px;"><strong>Smart Blocking:</strong> Prevents both manual and automated harvesting of locked crops</li>
                      <li style="margin-bottom: 4px;"><strong>Real-time Updates:</strong> Changes take effect immediately without reload</li>
                      <li style="margin-bottom: 4px;"><strong>Status Display:</strong> View all currently protected crops at a glance</li>
                  </ul>
                  <p style="font-size: 11px; color: #888; margin-top: 12px; padding: 8px; background: rgba(74, 158, 255, 0.30); border-radius: 4px; border-left: 3px solid #4a9eff;">
                      <strong>üí° Pro Tip:</strong> Use crop protection to safeguard valuable mutations while auto-harvesting everything else. Set sell protection to 1.5x (50% bonus) to ensure you only sell during maximum friend bonus!
                  </p>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">‚ö° Ability Tracking</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Automatic Logging:</strong> All pet abilities are tracked automatically</li>
                      <li style="margin-bottom: 4px;"><strong>Filter by Category:</strong> View specific types of abilities (XP, Selling, etc.)</li>
                      <li style="margin-bottom: 4px;"><strong>Filter by Pet:</strong> See abilities from specific pet species</li>
                      <li style="margin-bottom: 4px;"><strong>Detailed Timestamps:</strong> Enable to show HH:MM:SS format timestamps</li>
                      <li style="margin-bottom: 4px;"><strong>Export Data:</strong> Download ability logs as CSV for analysis</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üå± Seeds & Automation</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Mass Deletion:</strong> Select multiple seed types for bulk deletion</li>
                      <li style="margin-bottom: 4px;"><strong>Auto-Delete:</strong> Automatically remove unwanted seeds as they appear</li>
                      <li style="margin-bottom: 4px;"><strong>Value Calculation:</strong> See total value of selected seeds before deletion</li>
                      <li style="margin-bottom: 4px;"><strong>Quick Selection:</strong> Use preset buttons for common seed types</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üõí Shop Interface</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Dual Sidebars:</strong> Seeds on left, eggs on right (both open together)</li>
                      <li style="margin-bottom: 4px;"><strong>Color-Coded Names:</strong> Item rarity shown by text color (rainbow for celestial)</li>
                      <li style="margin-bottom: 4px;"><strong>Auto-Restock Detection:</strong> Purchase tracking resets when shop restocks</li>
                      <li style="margin-bottom: 4px;"><strong>Sort & Filter:</strong> Show available only, sort by value</li>
                      <li style="margin-bottom: 4px;"><strong>Quick Purchase:</strong> Buy 1 or All buttons for each item</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üîî Notifications</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Shop Monitoring:</strong> Get alerts when rare seeds/eggs appear</li>
                      <li style="margin-bottom: 4px;"><strong>Multiple Notifications:</strong> Single click dismisses all pending alerts</li>
                      <li style="margin-bottom: 4px;"><strong>Continuous Mode:</strong> Must be enabled via checkbox for persistent alerts</li>
                      <li style="margin-bottom: 4px;"><strong>Sound Types:</strong> Choose from beep, alarm, fanfare, or continuous alerts</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üé® Customization</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Themes:</strong> Switch between normal, dark, and other visual themes</li>
                      <li style="margin-bottom: 4px;"><strong>Compact Modes:</strong> Use compact or ultra-compact layouts to save space</li>
                      <li style="margin-bottom: 4px;"><strong>Overlays:</strong> Pop out tabs into separate in-game overlays</li>
                      <li style="margin-bottom: 4px;"><strong>Crop Highlighting:</strong> Visually highlight specific crops in your garden</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">‚ùì Troubleshooting</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Crop Highlighting Not Working:</strong> Ensure the game is fully loaded before using highlighting</li>
                      <li style="margin-bottom: 4px;"><strong>Notifications Not Playing:</strong> Check volume settings and browser audio permissions</li>
                      <li style="margin-bottom: 4px;"><strong>Pet Presets Not Saving:</strong> Wait for success confirmation before switching tabs</li>
                      <li style="margin-bottom: 4px;"><strong>Performance Issues:</strong> Try compact mode or disable debug logging in settings</li>
                  </ul>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üí° Tips & Best Practices</div>
                  <ul style="margin-left: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Regular Backups:</strong> Export ability logs periodically for data safety</li>
                      <li style="margin-bottom: 4px;"><strong>Preset Organization:</strong> Use descriptive names and reorder presets by frequency of use</li>
                      <li style="margin-bottom: 4px;"><strong>Notification Management:</strong> Enable continuous mode only for critical alerts</li>
                      <li style="margin-bottom: 4px;"><strong>Resource Monitoring:</strong> Use the Values tab to track inventory and garden worth</li>
                  </ul>
              </div>
          `;
    }

    function getHotkeysTabContent() {
      const hotkeys = UnifiedState.data.hotkeys;
      const currentlyRecording = null;

      return `
              <div class="mga-section">
                  <div class="mga-section-title">üéÆ Custom Hotkeys</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Click any key button to set a custom keybind. Press ESC to cancel.
                  </p>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px;">
                          <input type="checkbox" id="hotkeys-enabled" class="mga-checkbox"
                                 ${hotkeys.enabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>Enable custom hotkeys</span>
                      </label>
                  </div>

                  <div class="mga-section">
                      <div class="mga-section-title" style="font-size: 13px;">Game Controls</div>
                      ${Object.entries(hotkeys.gameKeys)
                        .map(
                          ([key, config]) => `
                          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 5px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                              <span style="font-size: 12px; flex: 1;">${config.name}</span>
                              <button class="hotkey-button" data-key="${key}" style="
                                  padding: 4px 8px;
                                  background: ${config.custom ? 'rgba(100, 255, 100, 0.48)' : 'rgba(74, 158, 255, 0.48)'};
                                  border: 1px solid ${config.custom ? '#64ff64' : '#4a9eff'};
                                  border-radius: 4px;
                                  color: white;
                                  font-size: 11px;
                                  min-width: 80px;
                                  cursor: pointer;
                              ">
                                  ${config.custom ? `${config.original.toUpperCase()} ‚Üí ${config.custom.toUpperCase()}` : config.original.toUpperCase()}
                              </button>
                              ${
                                config.custom
                                  ? `
                                  <button class="hotkey-reset" data-key="${key}" style="
                                      margin-left: 5px;
                                      padding: 2px 6px;
                                      background: rgba(255, 100, 100, 0.48);
                                      border: 1px solid #ff6464;
                                      border-radius: 3px;
                                      color: white;
                                      font-size: 10px;
                                      cursor: pointer;
                                  ">‚Ü∫</button>
                              `
                                  : ''
                              }
                          </div>
                      `
                        )
                        .join('')}
                  </div>

                  <div class="mga-section">
                      <div class="mga-section-title" style="font-size: 13px;">MGTools Navigation & Features</div>
                      ${Object.entries(hotkeys.mgToolsKeys)
                        .map(
                          ([key, config]) => `
                          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 5px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                              <span style="font-size: 12px; flex: 1;">${config.name}</span>
                              <button class="hotkey-button-mgtools" data-key="${key}" style="
                                  padding: 4px 8px;
                                  background: ${config.custom ? 'rgba(100, 255, 100, 0.48)' : 'rgba(74, 158, 255, 0.48)'};
                                  border: 1px solid ${config.custom ? '#64ff64' : '#4a9eff'};
                                  border-radius: 4px;
                                  color: white;
                                  font-size: 11px;
                                  min-width: 80px;
                                  cursor: pointer;
                              ">
                                  ${config.custom ? config.custom.toUpperCase() : 'Not Set'}
                              </button>
                              ${
                                config.custom
                                  ? `
                                  <button class="hotkey-reset-mgtools" data-key="${key}" style="
                                      margin-left: 5px;
                                      padding: 2px 6px;
                                      background: rgba(255, 100, 100, 0.48);
                                      border: 1px solid #ff6464;
                                      border-radius: 3px;
                                      color: white;
                                      font-size: 10px;
                                      cursor: pointer;
                                  ">‚Ü∫</button>
                              `
                                  : ''
                              }
                          </div>
                      `
                        )
                        .join('')}
                  </div>

                  <div style="display: flex; gap: 10px; margin-top: 15px;">
                      <button id="hotkeys-reset-all" class="mga-button" style="flex: 1;">
                          Reset All
                      </button>
                      <button id="hotkeys-export" class="mga-button" style="flex: 1;">
                          Export Config
                      </button>
                  </div>
              </div>
          `;
    }

    function getNotificationsTabContent() {
      const settings = UnifiedState.data.settings;

      // Ensure new notification properties exist (for backwards compatibility with old saved data)
      if (!settings.notifications.petHungerEnabled && settings.notifications.petHungerEnabled !== false) {
        settings.notifications.petHungerEnabled = false;
      }
      if (!settings.notifications.petHungerThreshold) {
        settings.notifications.petHungerThreshold = 20;
      }
      if (
        !settings.notifications.abilityNotificationsEnabled &&
        settings.notifications.abilityNotificationsEnabled !== false
      ) {
        settings.notifications.abilityNotificationsEnabled = false;
      }
      if (!settings.notifications.watchedAbilities) {
        settings.notifications.watchedAbilities = [];
      }
      if (!settings.notifications.watchedAbilityCategories) {
        settings.notifications.watchedAbilityCategories = {
          xpBoost: true,
          cropSizeBoost: true,
          selling: true,
          harvesting: true,
          growthSpeed: true,
          specialMutations: true,
          other: true
        };
      }
      if (
        !settings.notifications.weatherNotificationsEnabled &&
        settings.notifications.weatherNotificationsEnabled !== false
      ) {
        settings.notifications.weatherNotificationsEnabled = false;
      }
      if (!settings.notifications.watchedDecor) {
        settings.notifications.watchedDecor = [];
      }
      if (!settings.notifications.watchedWeatherEvents) {
        settings.notifications.watchedWeatherEvents = ['Snow', 'Rain', 'AmberMoon', 'Dawn'];
      }
      if (!settings.notifications.abilityNotificationSound) {
        settings.notifications.abilityNotificationSound = 'single';
      }
      if (settings.notifications.abilityNotificationVolume === undefined) {
        settings.notifications.abilityNotificationVolume = 0.2;
      }
      // Ensure continuousEnabled is explicitly false if undefined
      if (settings.notifications.continuousEnabled === undefined || settings.notifications.continuousEnabled === null) {
        settings.notifications.continuousEnabled = false;
      }
      // Ensure debugMode exists
      if (settings.debugMode === undefined) {
        settings.debugMode = false;
      }

      return `
              <div class="mga-section">
                  <div class="mga-section-title">üîî Shop Alert Notifications</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Get audio and visual alerts when rare seeds or eggs appear in the shop.
                  </p>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="notifications-enabled-checkbox" class="mga-checkbox"
                                 ${settings.notifications.enabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üîä Enable Notifications</span>
                      </label>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Volume: ${Math.round(settings.notifications.volume * 100)}%
                      </label>
                      <input type="range" class="mga-slider" id="notification-volume-slider"
                             min="0" max="100" value="${settings.notifications.volume * 100}"
                             style="width: 100%; accent-color: #4a9eff;">
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="notification-continuous-checkbox" class="mga-checkbox"
                                 ${settings.notifications.continuousEnabled ? 'checked' : ''}
                                 style="accent-color: #ff9900;">
                          <span>‚ö†Ô∏è Enable Continuous Mode</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Allows selection of continuous notification type that plays until acknowledged.
                      </p>
                  </div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Notification Sound Type
                      </label>
                      <select class="mga-select" id="notification-type-select">
                          <option value="simple" ${settings.notifications.notificationType === 'simple' ? 'selected' : ''}>üîä Simple Beep</option>
                          <option value="triple" ${settings.notifications.notificationType === 'triple' ? 'selected' : ''}>üîî Triple Beep</option>
                          <option value="alarm" ${settings.notifications.notificationType === 'alarm' ? 'selected' : ''}>üö® Alarm Siren</option>
                          <option value="epic" ${settings.notifications.notificationType === 'epic' ? 'selected' : ''}>üéµ Epic Fanfare</option>
                          <option value="continuous" ${settings.notifications.notificationType === 'continuous' ? 'selected' : ''} ${!settings.notifications.continuousEnabled ? 'disabled' : ''}>‚ö†Ô∏è Continuous (Until Acknowledged)</option>
                      </select>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="notification-acknowledgment-checkbox" class="mga-checkbox"
                                 ${settings.notifications.requiresAcknowledgment ? 'checked' : ''}
                                 style="accent-color: #ff4444;">
                          <span>üö® Require acknowledgment (persistent alert)</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          When enabled, notifications will show a modal that must be clicked to dismiss.
                      </p>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <button class="mga-btn mga-btn-sm" id="test-notification-btn" style="background: #4a5568;">
                          üîî Test Notification
                      </button>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üéµ Custom Notification Sounds</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Upload your own .mp3/.wav/.ogg files to replace default beep sounds. Max 2MB per file.
                  </p>

                  <div id="custom-sounds-container" style="display: grid; gap: 12px;">
                      <!-- Custom sound upload controls will be populated by setupNotificationsTabHandlers -->
                  </div>
              </div>

              <div class="mga-section">
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Watched Seeds
                      </label>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-carrot" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Carrot') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ï Carrot</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-strawberry" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Strawberry') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçì Strawberry</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-aloe" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Aloe') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåø Aloe</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-blueberry" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Blueberry') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü´ê Blueberry</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-apple" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Apple') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçé Apple</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-tulip" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Tulip') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üå∑ Tulip</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-tomato" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Tomato') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçÖ Tomato</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-daffodil" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Daffodil') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåº Daffodil</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-corn" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Corn') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåΩ Corn</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-watermelon" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Watermelon') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçâ Watermelon</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-pumpkin" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Pumpkin') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üéÉ Pumpkin</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-echeveria" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Echeveria') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü™¥ Echeveria</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-coconut" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Coconut') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•• Coconut</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-banana" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Banana') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçå Banana</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-lily" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Lily') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üå∫ Lily</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-burrostail" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('BurrosTail') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üå± Burro's Tail</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-mushroom" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Mushroom') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçÑ Mushroom</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-cactus" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Cactus') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåµ Cactus</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-bamboo" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Bamboo') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üéã Bamboo</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-grape" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Grape') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçá Grape</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-pepper" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Pepper') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üå∂Ô∏è Pepper</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-lemon" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Lemon') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçã Lemon</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-passionfruit" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('PassionFruit') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üß° PassionFruit</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-dragonfruit" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('DragonFruit') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üêâ DragonFruit</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-lychee" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Lychee') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçá Lychee</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-sunflower" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Sunflower') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåª Sunflower</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-starweaver" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Starweaver') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>‚≠ê Starweaver</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-dawnbinder" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Dawnbinder') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåÖ Dawnbinder</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-moonbinder" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Moonbinder') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåô Moonbinder</span>
                          </label>
                      </div>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Watched Eggs
                      </label>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-common-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('CommonEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö Common Egg</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-uncommon-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('UncommonEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö Uncommon Egg</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-rare-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('RareEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö Rare Egg</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-legendary-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('LegendaryEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö Legendary Egg</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-mythical-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('MythicalEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö‚ú® Mythical Egg</span>
                          </label>
                      </div>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Watched Decor (Hourly Shop)
                      </label>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                          ${DECOR_ITEMS.map(
                            decor => `
                              <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                                  <input type="checkbox" id="watch-decor-${decor.id.toLowerCase()}" class="mga-checkbox"
                                         ${settings.notifications.watchedDecor.includes(decor.id) ? 'checked' : ''}
                                         style="accent-color: #4a9eff; transform: scale(0.8);">
                                  <span>üé® ${decor.name}</span>
                              </label>
                          `
                          ).join('')}
                      </div>
                  </div>

                  <div style="margin-bottom: 12px; padding: 10px; background: rgba(255,255,255,0.15); border-radius: 4px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px; font-size: 12px;">
                          Last Seen
                      </label>
                      <div id="last-seen-display" style="font-size: 11px; color: #888; line-height: 1.3;">
                          Loading...
                      </div>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üêæ Pet Hunger Alerts</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Get notified when your pets' hunger drops below a threshold.
                  </p>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="pet-hunger-enabled" class="mga-checkbox"
                                 ${settings.notifications.petHungerEnabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üîä Enable Pet Hunger Notifications</span>
                      </label>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Alert when hunger below: ${settings.notifications.petHungerThreshold || 20}%
                      </label>
                      <input type="range" class="mga-slider" id="pet-hunger-threshold"
                             min="5" max="50" step="5" value="${settings.notifications.petHungerThreshold || 20}"
                             style="width: 100%; accent-color: #ff9900;">
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">‚ú® Ability Trigger Alerts</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Get notified when your pets trigger abilities. Leave all unchecked to be notified for all abilities.
                  </p>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="ability-notifications-enabled" class="mga-checkbox"
                                 ${settings.notifications.abilityNotificationsEnabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üîä Enable Ability Notifications</span>
                      </label>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Ability Sound Type
                      </label>
                      <select class="mga-select" id="ability-notification-sound-select"
                              style="width: 100%; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; color: white; font-size: 12px;">
                          <option value="single" ${settings.notifications.abilityNotificationSound === 'single' ? 'selected' : ''}>üîä Single Beep (Subtle)</option>
                          <option value="double" ${settings.notifications.abilityNotificationSound === 'double' ? 'selected' : ''}>üîî Double Beep</option>
                          <option value="triple" ${settings.notifications.abilityNotificationSound === 'triple' ? 'selected' : ''}>üéµ Triple Beep</option>
                          <option value="chime" ${settings.notifications.abilityNotificationSound === 'chime' ? 'selected' : ''}>üéê Chime (Pleasant)</option>
                          <option value="alert" ${settings.notifications.abilityNotificationSound === 'alert' ? 'selected' : ''}>üö® Alert (Urgent)</option>
                          <option value="buzz" ${settings.notifications.abilityNotificationSound === 'buzz' ? 'selected' : ''}>üì≥ Buzz (Energetic)</option>
                          <option value="ding" ${settings.notifications.abilityNotificationSound === 'ding' ? 'selected' : ''}>üîî Ding (Clear)</option>
                          <option value="chirp" ${settings.notifications.abilityNotificationSound === 'chirp' ? 'selected' : ''}>üê¶ Chirp (Cute)</option>
                          <option value="epic" ${settings.notifications.abilityNotificationSound === 'epic' ? 'selected' : ''}>üéµ Epic Fanfare</option>
                      </select>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Ability Alert Volume: ${Math.round((settings.notifications.abilityNotificationVolume || 0.2) * 100)}%
                      </label>
                      <input type="range" class="mga-slider" id="ability-notification-volume-slider"
                             min="0" max="100" value="${(settings.notifications.abilityNotificationVolume || 0.2) * 100}"
                             style="width: 100%; accent-color: #9f7aea;">
                  </div>

                  <div style="margin-bottom: 16px; padding-top: 12px; border-top: 1px solid rgba(255, 255, 255, 0.57);">
                      <label class="mga-label" style="display: block; margin-bottom: 8px; font-weight: 600;">
                          üìã Which Abilities to Notify For
                      </label>
                      <p style="font-size: 11px; color: #888; margin-bottom: 8px;">
                          Select individual abilities that will trigger notifications. All abilities start enabled by default.
                      </p>

                      <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                          <button id="select-all-individual-abilities" class="mga-btn mga-btn-secondary" style="flex: 1; padding: 6px; font-size: 11px;">Select All</button>
                          <button id="select-none-individual-abilities" class="mga-btn mga-btn-secondary" style="flex: 1; padding: 6px; font-size: 11px;">Select None</button>
                      </div>

                      <input type="text" id="ability-search-box" placeholder="üîç Search abilities..."
                             style="width: 100%; padding: 8px; margin-bottom: 12px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; color: #fff; font-size: 12px;">

                      <div id="individual-abilities-notification-list" style="display: grid; grid-template-columns: 1fr; gap: 4px; max-height: 400px; overflow-y: auto; padding: 4px;">
                          ${(() => {
                            // Comprehensive list of all abilities organized by category
                            const abilities = [
                              // XP Boosts
                              { name: 'XP Boost I', category: 'üí´ XP Boosts' },
                              { name: 'XP Boost II', category: 'üí´ XP Boosts' },
                              { name: 'XP Boost III', category: 'üí´ XP Boosts' },
                              { name: 'XP Boost IV', category: 'üí´ XP Boosts' },
                              { name: 'Hatch XP Boost', category: 'üí´ XP Boosts' },
                              // Crop Size Boosts (only I and II exist in game)
                              { name: 'Crop Size Boost I', category: 'üìà Crop Size Boosts' },
                              { name: 'Crop Size Boost II', category: 'üìà Crop Size Boosts' },
                              // Selling
                              { name: 'Sell Boost I', category: 'üí∞ Selling' },
                              { name: 'Sell Boost II', category: 'üí∞ Selling' },
                              { name: 'Sell Boost III', category: 'üí∞ Selling' },
                              { name: 'Sell Boost IV', category: 'üí∞ Selling' },
                              { name: 'Selling Refund', category: 'üí∞ Selling' },
                              // Harvesting
                              { name: 'Double Harvest', category: 'üåæ Harvesting' },
                              // Growth Speed
                              { name: 'Plant Growth Boost I', category: 'üê¢ Growth Speed' },
                              { name: 'Plant Growth Boost II', category: 'üê¢ Growth Speed' },
                              { name: 'Plant Growth Boost III', category: 'üê¢ Growth Speed' },
                              // Special Mutations
                              { name: 'Rainbow Mutation', category: 'üåà Special' },
                              { name: 'Gold Mutation', category: 'üåà Special' },
                              // Other
                              { name: 'Seed Finder I', category: 'üîß Other' },
                              { name: 'Seed Finder II', category: 'üîß Other' },
                              { name: 'Hunger Boost I', category: 'üîß Other' },
                              { name: 'Hunger Boost II', category: 'üîß Other' },
                              { name: 'Max Strength Boost I', category: 'üîß Other' },
                              { name: 'Max Strength Boost II', category: 'üîß Other' },
                              { name: 'Crop Eater', category: 'üîß Other' }
                            ];

                            const watchedAbilities = settings.notifications.watchedAbilities || [];

                            // Group abilities by category
                            const grouped = {};
                            abilities.forEach(ability => {
                              if (!grouped[ability.category]) grouped[ability.category] = [];
                              grouped[ability.category].push(ability.name);
                            });

                            let html = '';
                            Object.keys(grouped)
                              .sort()
                              .forEach(category => {
                                html += `<div class="ability-category-group" style="margin-bottom: 8px;">
                                      <div style="font-size: 11px; font-weight: 600; color: #aaa; margin-bottom: 4px; padding: 4px 8px; background: rgba(255,255,255,0.03); border-radius: 4px;">${category}</div>`;

                                grouped[category].forEach(abilityName => {
                                  const isChecked =
                                    watchedAbilities.length === 0 || watchedAbilities.includes(abilityName);
                                  html += `
                                          <label class="mga-checkbox-group ability-checkbox-item" data-ability="${abilityName}" style="display: flex; align-items: center; gap: 8px; padding: 6px 12px; cursor: pointer; transition: background 0.2s; border-radius: 4px;">
                                              <input type="checkbox"
                                                     class="mga-checkbox individual-ability-checkbox"
                                                     data-ability-name="${abilityName}"
                                                     ${isChecked ? 'checked' : ''}
                                                     style="accent-color: #4a9eff;">
                                              <span style="font-size: 11px; color: #ddd;">${abilityName}</span>
                                          </label>`;
                                });
                                html += '</div>';
                              });

                            return html;
                          })()}
                      </div>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üå§Ô∏è Weather Event Alerts</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Get notified when weather events occur in the game.
                  </p>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="weather-notifications-enabled" class="mga-checkbox"
                                 ${settings.notifications.weatherNotificationsEnabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üîä Enable Weather Notifications</span>
                      </label>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Watched Weather Events
                      </label>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-snow" class="mga-checkbox"
                                     ${settings.notifications.watchedWeatherEvents.includes('Snow') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>‚ùÑÔ∏è Snow</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-rain" class="mga-checkbox"
                                     ${settings.notifications.watchedWeatherEvents.includes('Rain') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåßÔ∏è Rain</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-amber-moon" class="mga-checkbox"
                                     ${settings.notifications.watchedWeatherEvents.includes('AmberMoon') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåô Amber Moon</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-dawn" class="mga-checkbox"
                                     ${settings.notifications.watchedWeatherEvents.includes('Dawn') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåÖ Dawn</span>
                          </label>
                      </div>
                  </div>
              </div>
          `;
    }

    function getSettingsTabContent() {
      const settings = UnifiedState.data.settings;

      return `
              <div class="mga-section">
                  <div class="mga-section-title">Appearance</div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Main HUD Opacity: ${settings.opacity}%
                      </label>
                      <input type="range" class="mga-slider" id="opacity-slider"
                             min="0" max="100" value="${settings.opacity}"
                             style="width: 100%; accent-color: #4a9eff;">
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Pop-out Opacity: ${settings.popoutOpacity}%
                      </label>
                      <input type="range" class="mga-slider" id="popout-opacity-slider"
                             min="0" max="100" value="${settings.popoutOpacity}"
                             style="width: 100%; accent-color: #4a9eff;">
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Gradient Style
                      </label>
                      <select class="mga-select" id="gradient-select" style="margin-bottom: 8px;">
                          <optgroup label="‚ö´ Black Accent Themes">
                              <option value="black-void" ${settings.gradientStyle === 'black-void' ? 'selected' : ''}>‚ö´‚¨õ Pure Void</option>
                              <option value="black-crimson" ${settings.gradientStyle === 'black-crimson' ? 'selected' : ''}>‚ö´üî¥ Midnight Crimson</option>
                              <option value="black-emerald" ${settings.gradientStyle === 'black-emerald' ? 'selected' : ''}>‚ö´üíö Shadow Emerald</option>
                              <option value="black-royal" ${settings.gradientStyle === 'black-royal' ? 'selected' : ''}>‚ö´üíú Void Royal</option>
                              <option value="black-gold" ${settings.gradientStyle === 'black-gold' ? 'selected' : ''}>‚ö´üíõ Obsidian Gold</option>
                              <option value="black-ice" ${settings.gradientStyle === 'black-ice' ? 'selected' : ''}>‚ö´üíô Carbon Ice</option>
                              <option value="black-flame" ${settings.gradientStyle === 'black-flame' ? 'selected' : ''}>‚ö´üß° Inferno Black</option>
                              <option value="black-toxic" ${settings.gradientStyle === 'black-toxic' ? 'selected' : ''}>‚ö´‚ò¢Ô∏è Toxic Shadow</option>
                              <option value="black-pink" ${settings.gradientStyle === 'black-pink' ? 'selected' : ''}>‚ö´üíó Noir Pink</option>
                              <option value="black-matrix" ${settings.gradientStyle === 'black-matrix' ? 'selected' : ''}>‚ö´üü¢ Matrix Black</option>
                              <option value="black-sunset" ${settings.gradientStyle === 'black-sunset' ? 'selected' : ''}>‚ö´üåÖ Eclipse Sunset</option>
                              <option value="black-blood" ${settings.gradientStyle === 'black-blood' ? 'selected' : ''}>‚ö´ü©∏ Midnight Blood</option>
                              <option value="black-neon" ${settings.gradientStyle === 'black-neon' ? 'selected' : ''}>‚ö´‚ö° Shadow Neon</option>
                              <option value="black-storm" ${settings.gradientStyle === 'black-storm' ? 'selected' : ''}>‚ö´‚õàÔ∏è Obsidian Storm</option>
                              <option value="black-sapphire" ${settings.gradientStyle === 'black-sapphire' ? 'selected' : ''}>‚ö´üí† Void Sapphire</option>
                              <option value="black-aqua" ${settings.gradientStyle === 'black-aqua' ? 'selected' : ''}>‚ö´üåä Dark Aqua</option>
                              <option value="black-phantom" ${settings.gradientStyle === 'black-phantom' ? 'selected' : ''}>‚ö´ü™ô Phantom Silver</option>
                              <option value="black-violet" ${settings.gradientStyle === 'black-violet' ? 'selected' : ''}>‚ö´üíú Deep Violet</option>
                              <option value="black-amber" ${settings.gradientStyle === 'black-amber' ? 'selected' : ''}>‚ö´üü† Shadow Amber</option>
                              <option value="black-jade" ${settings.gradientStyle === 'black-jade' ? 'selected' : ''}>‚ö´üü¢ Mystic Jade</option>
                              <option value="black-coral" ${settings.gradientStyle === 'black-coral' ? 'selected' : ''}>‚ö´ü™∏ Dark Coral</option>
                              <option value="black-steel" ${settings.gradientStyle === 'black-steel' ? 'selected' : ''}>‚ö´üîµ Carbon Steel</option>
                              <option value="black-lavender" ${settings.gradientStyle === 'black-lavender' ? 'selected' : ''}>‚ö´üíú Void Lavender</option>
                              <option value="black-mint" ${settings.gradientStyle === 'black-mint' ? 'selected' : ''}>‚ö´üåø Shadow Mint</option>
                              <option value="black-ruby" ${settings.gradientStyle === 'black-ruby' ? 'selected' : ''}>‚ö´üíé Obsidian Ruby</option>
                              <option value="black-cobalt" ${settings.gradientStyle === 'black-cobalt' ? 'selected' : ''}>‚ö´üî∑ Deep Cobalt</option>
                              <option value="black-bronze" ${settings.gradientStyle === 'black-bronze' ? 'selected' : ''}>‚ö´üü§ Dark Bronze</option>
                              <option value="black-teal" ${settings.gradientStyle === 'black-teal' ? 'selected' : ''}>‚ö´ü©µ Shadow Teal</option>
                              <option value="black-magenta" ${settings.gradientStyle === 'black-magenta' ? 'selected' : ''}>‚ö´ü©∑ Void Magenta</option>
                              <option value="black-lime" ${settings.gradientStyle === 'black-lime' ? 'selected' : ''}>‚ö´üü¢ Electric Lime</option>
                              <option value="black-indigo" ${settings.gradientStyle === 'black-indigo' ? 'selected' : ''}>‚ö´üíô Midnight Indigo</option>
                          </optgroup>
                          <optgroup label="üåà Classic Themes">
                              <option value="blue-purple" ${settings.gradientStyle === 'blue-purple' ? 'selected' : ''}>üåå Blue-Purple</option>
                              <option value="green-blue" ${settings.gradientStyle === 'green-blue' ? 'selected' : ''}>üåä Green-Blue</option>
                              <option value="red-orange" ${settings.gradientStyle === 'red-orange' ? 'selected' : ''}>üî• Red-Orange</option>
                              <option value="purple-pink" ${settings.gradientStyle === 'purple-pink' ? 'selected' : ''}>üíú Purple-Pink</option>
                              <option value="gold-yellow" ${settings.gradientStyle === 'gold-yellow' ? 'selected' : ''}>üëë Gold-Yellow</option>
                          </optgroup>
                          <optgroup label="‚ú® Vibrant Themes">
                              <option value="electric-neon" ${settings.gradientStyle === 'electric-neon' ? 'selected' : ''}>‚ö° Electric Neon</option>
                              <option value="sunset-fire" ${settings.gradientStyle === 'sunset-fire' ? 'selected' : ''}>üåÖ Sunset Fire</option>
                              <option value="emerald-cyan" ${settings.gradientStyle === 'emerald-cyan' ? 'selected' : ''}>üíé Emerald Cyan</option>
                              <option value="royal-gold" ${settings.gradientStyle === 'royal-gold' ? 'selected' : ''}>üèÜ Royal Gold</option>
                              <option value="crimson-blaze" ${settings.gradientStyle === 'crimson-blaze' ? 'selected' : ''}>üî• Crimson Blaze</option>
                              <option value="ocean-deep" ${settings.gradientStyle === 'ocean-deep' ? 'selected' : ''}>üåä Ocean Deep</option>
                              <option value="forest-mystique" ${settings.gradientStyle === 'forest-mystique' ? 'selected' : ''}>üå≤ Forest Mystique</option>
                              <option value="cosmic-purple" ${settings.gradientStyle === 'cosmic-purple' ? 'selected' : ''}>üåå Cosmic Purple</option>
                              <option value="rainbow-burst" ${settings.gradientStyle === 'rainbow-burst' ? 'selected' : ''}>üåà Rainbow Burst</option>
                          </optgroup>
                          <optgroup label="üõ°Ô∏è Metallic Themes">
                              <option value="steel-blue" ${settings.gradientStyle === 'steel-blue' ? 'selected' : ''}>üõ°Ô∏è Steel Blue</option>
                              <option value="chrome-silver" ${settings.gradientStyle === 'chrome-silver' ? 'selected' : ''}>‚ö™ Chrome Silver</option>
                              <option value="titanium-gray" ${settings.gradientStyle === 'titanium-gray' ? 'selected' : ''}>üå´Ô∏è Titanium Gray</option>
                              <option value="platinum-white" ${settings.gradientStyle === 'platinum-white' ? 'selected' : ''}>üíç Platinum White</option>
                          </optgroup>
                      </select>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Effect Style
                      </label>
                      <select class="mga-select" id="effect-select">
                          <option value="none" ${settings.effectStyle === 'none' ? 'selected' : ''}>‚ú® None</option>
                          <option value="metallic" ${settings.effectStyle === 'metallic' ? 'selected' : ''}>‚ö° Metallic</option>
                          <option value="glass" ${settings.effectStyle === 'glass' ? 'selected' : ''}>üíé Glass</option>
                          <option value="neon" ${settings.effectStyle === 'neon' ? 'selected' : ''}>üåü Neon Glow</option>
                          <option value="plasma" ${settings.effectStyle === 'plasma' ? 'selected' : ''}>üî• Plasma</option>
                          <option value="aurora" ${settings.effectStyle === 'aurora' ? 'selected' : ''}>üåå Aurora</option>
                          <option value="crystal" ${settings.effectStyle === 'crystal' ? 'selected' : ''}>üí† Crystal</option>
                          <option value="steel" ${settings.effectStyle === 'steel' ? 'selected' : ''}>üõ°Ô∏è Steel</option>
                          <option value="chrome" ${settings.effectStyle === 'chrome' ? 'selected' : ''}>‚ö™ Chrome</option>
                          <option value="titanium" ${settings.effectStyle === 'titanium' ? 'selected' : ''}>üå´Ô∏è Titanium</option>
                      </select>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Texture Overlay
                      </label>
                      <select class="mga-select" id="texture-select">
                          <option value="none" ${settings.textureStyle === 'none' || !settings.textureStyle ? 'selected' : ''}>üö´ None</option>

                          <optgroup label="üåü Modern Glass">
                              <option value="frosted-glass" ${settings.textureStyle === 'frosted-glass' ? 'selected' : ''}>‚ùÑÔ∏è Frosted Glass</option>
                              <option value="crystal-prism" ${settings.textureStyle === 'crystal-prism' ? 'selected' : ''}>üíé Crystal Prism</option>
                              <option value="ice-frost" ${settings.textureStyle === 'ice-frost' ? 'selected' : ''}>üßä Ice Frost</option>
                              <option value="smoke-flow" ${settings.textureStyle === 'smoke-flow' ? 'selected' : ''}>üí® Smoke Flow</option>
                              <option value="water-ripple" ${settings.textureStyle === 'water-ripple' ? 'selected' : ''}>üåä Water Ripple</option>
                          </optgroup>

                          <optgroup label="‚öôÔ∏è Premium Materials">
                              <option value="carbon-fiber-pro" ${settings.textureStyle === 'carbon-fiber-pro' ? 'selected' : ''}>üèÅ Carbon Fiber Pro</option>
                              <option value="brushed-aluminum" ${settings.textureStyle === 'brushed-aluminum' ? 'selected' : ''}>‚ö™ Brushed Aluminum</option>
                              <option value="brushed-titanium" ${settings.textureStyle === 'brushed-titanium' ? 'selected' : ''}>‚ö´ Brushed Titanium</option>
                              <option value="leather-grain" ${settings.textureStyle === 'leather-grain' ? 'selected' : ''}>üß≥ Leather Grain</option>
                              <option value="fabric-weave" ${settings.textureStyle === 'fabric-weave' ? 'selected' : ''}>üßµ Fabric Weave</option>
                              <option value="wood-grain" ${settings.textureStyle === 'wood-grain' ? 'selected' : ''}>ü™µ Wood Grain</option>
                          </optgroup>

                          <optgroup label="‚ö° Tech/Futuristic">
                              <option value="circuit-board" ${settings.textureStyle === 'circuit-board' ? 'selected' : ''}>üîå Circuit Board</option>
                              <option value="hexagon-grid-pro" ${settings.textureStyle === 'hexagon-grid-pro' ? 'selected' : ''}>‚¨° Hexagon Grid Pro</option>
                              <option value="hologram-scan" ${settings.textureStyle === 'hologram-scan' ? 'selected' : ''}>üì° Hologram Scan</option>
                              <option value="matrix-rain" ${settings.textureStyle === 'matrix-rain' ? 'selected' : ''}>üíö Matrix Rain</option>
                              <option value="energy-waves" ${settings.textureStyle === 'energy-waves' ? 'selected' : ''}>‚ö° Energy Waves</option>
                              <option value="cyberpunk-grid" ${settings.textureStyle === 'cyberpunk-grid' ? 'selected' : ''}>üî∑ Cyberpunk Grid</option>
                          </optgroup>

                          <optgroup label="üìê Geometric Clean">
                              <option value="dots-pro" ${settings.textureStyle === 'dots-pro' ? 'selected' : ''}>‚ö´ Dots Professional</option>
                              <option value="grid-pro" ${settings.textureStyle === 'grid-pro' ? 'selected' : ''}>‚¨ú Grid Professional</option>
                              <option value="diagonal-pro" ${settings.textureStyle === 'diagonal-pro' ? 'selected' : ''}>üìê Diagonal Pro</option>
                              <option value="waves" ${settings.textureStyle === 'waves' ? 'selected' : ''}>„Ä∞Ô∏è Waves</option>
                              <option value="triangles" ${settings.textureStyle === 'triangles' ? 'selected' : ''}>üî∫ Triangles</option>
                              <option value="crosshatch" ${settings.textureStyle === 'crosshatch' ? 'selected' : ''}>‚úñÔ∏è Crosshatch</option>
                          </optgroup>

                          <optgroup label="üé™ Special Effects">
                              <option value="perlin-noise" ${settings.textureStyle === 'perlin-noise' ? 'selected' : ''}>üì∫ Perlin Noise</option>
                              <option value="gradient-mesh" ${settings.textureStyle === 'gradient-mesh' ? 'selected' : ''}>üåà Gradient Mesh</option>
                          </optgroup>
                      </select>
                  </div>

                  <!-- Texture Intensity Slider -->
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                          <span>Texture Intensity</span>
                          <span id="texture-intensity-value" style="color: #4a9eff; font-weight: 600;">${settings.textureIntensity !== undefined ? settings.textureIntensity : 75}%</span>
                      </label>
                      <input type="range" id="texture-intensity-slider" min="0" max="100" value="${settings.textureIntensity !== undefined ? settings.textureIntensity : 75}"
                             style="width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(90deg, rgba(74, 158, 255, 0.48) 0%, rgba(74,158,255,0.8) 100%); outline: none; cursor: pointer;">
                  </div>

                  <!-- Texture Scale Control -->
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Texture Scale
                      </label>
                      <div style="display: flex; gap: 8px;">
                          <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="small" style="flex: 1; ${settings.textureScale === 'small' ? 'background: #4a9eff; color: white;' : ''}">Small</button>
                          <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="medium" style="flex: 1; ${settings.textureScale === 'medium' || !settings.textureScale ? 'background: #4a9eff; color: white;' : ''}">Medium</button>
                          <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="large" style="flex: 1; ${settings.textureScale === 'large' ? 'background: #4a9eff; color: white;' : ''}">Large</button>
                      </div>
                  </div>

                  <!-- Blend Mode Selector -->
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Blend Mode
                      </label>
                      <select class="mga-select" id="texture-blend-mode">
                          <option value="overlay" ${settings.textureBlendMode === 'overlay' || !settings.textureBlendMode ? 'selected' : ''}>Overlay (Balanced)</option>
                          <option value="multiply" ${settings.textureBlendMode === 'multiply' ? 'selected' : ''}>Multiply (Darken)</option>
                          <option value="screen" ${settings.textureBlendMode === 'screen' ? 'selected' : ''}>Screen (Lighten)</option>
                          <option value="soft-light" ${settings.textureBlendMode === 'soft-light' ? 'selected' : ''}>Soft Light (Subtle)</option>
                      </select>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Quick Presets</div>
                  <div class="mga-grid">
                      <button class="mga-btn mga-btn-sm" data-preset="gaming">üéÆ Gaming</button>
                      <button class="mga-btn mga-btn-sm" data-preset="minimal">‚ö™ Minimal</button>
                      <button class="mga-btn mga-btn-sm" data-preset="vibrant">üåà Vibrant</button>
                      <button class="mga-btn mga-btn-sm" data-preset="dark">‚ö´ Dark</button>
                      <button class="mga-btn mga-btn-sm" data-preset="luxury">‚ú® Luxury</button>
                      <button class="mga-btn mga-btn-sm" data-preset="steel">üõ°Ô∏è Steel</button>
                      <button class="mga-btn mga-btn-sm" data-preset="chrome">‚ö™ Chrome</button>
                      <button class="mga-btn mga-btn-sm" data-preset="titanium">üå´Ô∏è Titanium</button>
                      <button class="mga-btn mga-btn-sm" data-preset="reset">üîÑ Reset</button>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">UI Mode</div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="ultra-compact-checkbox" class="mga-checkbox"
                                 ${settings.ultraCompactMode ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üì± Ultra-compact mode</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Maximum space efficiency with condensed layouts and smaller text.
                      </p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Pet Interface</div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="hide-feed-buttons-checkbox" class="mga-checkbox"
                                 ${settings.hideFeedButtons ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üçÉ Hide instant feed buttons</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Hide the 3 quick-feed buttons next to active pet avatars. Applies immediately without page reload.
                      </p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Pop-out Behavior</div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="use-overlays-checkbox" class="mga-checkbox"
                                 ${settings.useInGameOverlays ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üéÆ Use in-game overlays instead of separate windows</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          When enabled, tabs will open as draggable overlays within the game window instead of separate browser windows.
                      </p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üõ°Ô∏è Compatibility Mode</div>
                  <div style="margin-bottom: 16px;">
                      <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px;
                                  background: ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled ? 'rgba(34, 197, 94, 0.30)' : 'rgba(255, 255, 255, 0.05)'};
                                  border: 1px solid ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled ? 'rgba(34, 197, 94, 0.3)' : 'rgba(255, 255, 255, 0.57)'};
                                  border-radius: 8px; margin-bottom: 12px;">
                          <div>
                              <div style="font-weight: 600; margin-bottom: 4px;">
                                  ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled ? '‚úÖ Enabled' : '‚ö™ Disabled'}
                              </div>
                              <div style="font-size: 11px; color: #aaa;">
                                  ${
                                    typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled
                                      ? 'Reason: ' + (CompatibilityMode.detectionReason || 'manual')
                                      : 'Auto-detects CSP restrictions'
                                  }
                              </div>
                          </div>
                          <button id="compat-toggle-btn" class="mga-btn mga-btn-sm"
                                  style="padding: 8px 16px; font-size: 12px; min-width: 100px;">
                              ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled ? 'Disable' : 'Force Enable'}
                          </button>
                      </div>
                      <p style="font-size: 11px; color: #aaa; line-height: 1.6;">
                          <strong>What it does:</strong><br>
                          ‚Ä¢ Bypasses CSP restrictions for Discord/managed devices<br>
                          ‚Ä¢ Uses system fonts instead of Google Fonts<br>
                          ‚Ä¢ Forces WebSocket reconnection even when tab is hidden<br>
                          ‚Ä¢ Uses GM_xmlhttpRequest for external network requests<br>
                          <br>
                          <strong>When to use:</strong><br>
                          ‚Ä¢ Playing in Discord Activities<br>
                          ‚Ä¢ Work/school computers with strict security policies<br>
                          ‚Ä¢ Browser extensions or embeds<br>
                          <br>
                          <em style="opacity: 0.7;">Note: Changes require page refresh</em>
                      </p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Developer Options</div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="debug-mode-checkbox" class="mga-checkbox"
                                 ${settings.debugMode ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üêõ Enable Debug Mode</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Shows detailed console logs for troubleshooting pet hunger, notifications, and more.
                      </p>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="room-debug-mode-checkbox" class="mga-checkbox"
                                 ${settings.roomDebugMode ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üåê Enable Room Debug Mode</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Shows detailed console logs for room API requests and player count fetching.
                      </p>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="hide-weather-checkbox" class="mga-checkbox"
                                 ${settings.hideWeather ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üåßÔ∏è Hide Weather Effects</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Hide visual weather effects like snow, rain, and other weather animations for better performance.
                      </p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Data Management</div>
                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <button class="mga-btn mga-btn-sm" id="export-settings-btn">Export Settings</button>
                      <button class="mga-btn mga-btn-sm" id="import-settings-btn">Import Settings</button>
                      <button class="mga-btn mga-btn-sm" id="reset-loadouts-btn" style="background: #dc2626;">Reset Pet Loadouts</button>
                      <button class="mga-btn mga-btn-sm" id="clear-hotkeys-btn" style="background: #ea580c;">Clear All Hotkeys</button>
                  </div>
                  <p style="font-size: 11px; color: #aaa; margin-top: 4px;">
                      Reset button clears all saved pet loadouts. Clear hotkeys button removes all preset hotkey assignments.
                  </p>
              </div>
          `;
    }

    // Helper function to refresh separate window popouts
    function refreshSeparateWindowPopouts(tabName) {
      try {
        UnifiedState.data.popouts.windows.forEach((windowRef, popoutTabName) => {
          if (windowRef && !windowRef.closed && popoutTabName === tabName) {
            // Force update pets data first for pets tab
            if (tabName === 'pets') {
              updateActivePetsFromRoomState();
            }

            // Trigger refresh in the separate window
            if (windowRef.refreshPopoutContent) {
              windowRef.refreshPopoutContent(tabName);
              productionLog(`üîÑ [POPOUT] Refreshed ${tabName} window popout`);
            } else if (windowRef.location) {
              // Fallback: force reload if refresh function not available
              productionWarn(`‚ö†Ô∏è [POPOUT] No refresh function for ${tabName}, reloading window`);
              windowRef.location.reload();
            }
          }
        });
      } catch (error) {
        debugError('OVERLAY_LIFECYCLE', 'Failed to refresh separate window popouts', error, { tabName });
      }
    }

    // Place a pet preset - used by both main tab and popout Place buttons
    // Uses native SwapPet to work even when inventory is full
    function placePetPreset(presetName) {
      const preset = UnifiedState.data.petPresets[presetName];
      if (!preset) {
        productionWarn(`[PETS] Preset "${presetName}" not found`);
        return;
      }

      const maxSlots = 3;

      // Native swap approach - works even with full inventory!
      let delay = 0;

      for (let slotIndex = 0; slotIndex < maxSlots; slotIndex++) {
        const desiredPet = preset[slotIndex];

        // BUGFIX: Capture delay value in closure to prevent race conditions
        ((currentDelay, slot) => {
          setTimeout(() => {
            // BUGFIX: Read FRESH state inside timeout (not stale reference)
            const currentPets = UnifiedState.atoms.activePets || window.activePets || [];
            const currentPet = currentPets[slot];

            if (currentPet && desiredPet) {
              // Check if desired pet is already equipped
              if (currentPet.id === desiredPet.id) {
                if (UnifiedState.data.settings?.debugMode) {
                  productionLog(`[PET-SWAP] Slot ${slot + 1}: Already equipped (${currentPet.id}), skipping`);
                }
                return; // Skip swap, pet already in place
              }

              // Both exist: Use native SwapPet (no inventory space needed!)
              if (UnifiedState.data.settings?.debugMode) {
                productionLog(`[PET-SWAP] Slot ${slot + 1}: Swapping ${currentPet.id} ‚Üí ${desiredPet.id}`);
              }

              safeSendMessage({
                scopePath: ['Room', 'Quinoa'],
                type: 'SwapPet',
                petSlotId: currentPet.id,
                petInventoryId: desiredPet.id
              });
            } else if (!currentPet && desiredPet) {
              // Empty slot: Place new pet
              if (UnifiedState.data.settings?.debugMode) {
                productionLog(`[PET-SWAP] Slot ${slot + 1}: Placing ${desiredPet.id} (empty slot)`);
              }

              safeSendMessage({
                scopePath: ['Room', 'Quinoa'],
                type: 'PlacePet',
                itemId: desiredPet.id,
                position: { x: 17 + slot * 2, y: 13 },
                localTileIndex: 64,
                tileType: 'Boardwalk'
              });
            } else if (currentPet && !desiredPet) {
              // Remove excess pet (preset has fewer pets)
              if (UnifiedState.data.settings?.debugMode) {
                productionLog(`[PET-SWAP] Slot ${slot + 1}: Storing ${currentPet.id} (no preset pet)`);
              }

              safeSendMessage({
                scopePath: ['Room', 'Quinoa'],
                type: 'StorePet',
                itemId: currentPet.id
              });
            }
          }, currentDelay);
        })(delay, slotIndex);

        // Increase delay: 100ms ‚Üí 200ms for better network latency tolerance
        delay += 200;
      }

      // Update all displays after pets are placed (with backup refresh)
      const refreshAllPetDisplays = () => {
        // Force update from room state
        updateActivePetsFromRoomState();

        // Update main tab if active
        if (UnifiedState.activeTab === 'pets') {
          updateTabContent();
        }

        // Update overlays
        UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
          if (overlay && document.contains(overlay) && tabName === 'pets') {
            if (overlay.className.includes('mga-overlay-content-only')) {
              updatePureOverlayContent(overlay, tabName);
            }
          }
        });

        // Update separate window popouts
        refreshSeparateWindowPopouts('pets');
      };

      // First refresh after swaps complete + 500ms
      setTimeout(() => {
        refreshAllPetDisplays();
      }, delay + 500);

      // Backup refresh after swaps + 1.5s to catch slow updates
      setTimeout(() => {
        refreshAllPetDisplays();
      }, delay + 1500);
    }

    // Global debounced wrapper for placePetPreset (accessible from all handlers)
    let _placePetPresetDebounceTimer = null;
    window.debouncedPlacePetPreset = function (presetName) {
      if (_placePetPresetDebounceTimer) return; // Ignore if already pending
      _placePetPresetDebounceTimer = setTimeout(() => {
        _placePetPresetDebounceTimer = null;
      }, 500);
      placePetPreset(presetName);
    };

    // Helper function to check if preset contains Worm with Crop Eater ability
    // Uses same detection pattern as turtle timer (checks abilities array)
    function presetHasCropEater(preset) {
      if (!preset || !Array.isArray(preset)) {
        return false;
      }

      // Filter for Worms with Crop Eater ability (same pattern as turtle timer)
      const wormsWithCropEater = preset.filter(
        p =>
          p &&
          p.petSpecies === 'Worm' &&
          p.abilities?.some(
            a =>
              a === 'Crop Eater' ||
              a === 'CropEater' ||
              (typeof a === 'string' && a.toLowerCase().includes('crop') && a.toLowerCase().includes('eater'))
          )
      );

      if (wormsWithCropEater.length > 0) {
        productionLog(
          `[Crop Eater Check] Preset contains ${wormsWithCropEater.length} Worm(s) with Crop Eater - skipping`
        );
      }

      return wormsWithCropEater.length > 0;
    }

    // Cycle to next preset in the order list (NEW v3.7.8)
    // Auto-skips presets with Crop Eater pets
    function cycleToNextPreset() {
      ensurePresetOrder(); // Ensure order array is up to date

      if (UnifiedState.data.petPresetsOrder.length === 0) {
        productionLog('[Cycle Presets] No presets available');
        return;
      }

      const startIndex = UnifiedState.data.currentPresetIndex;
      let attempts = 0;
      const maxAttempts = UnifiedState.data.petPresetsOrder.length;

      do {
        // Move to next preset
        UnifiedState.data.currentPresetIndex++;

        // Loop back to start if at end
        if (UnifiedState.data.currentPresetIndex >= UnifiedState.data.petPresetsOrder.length) {
          UnifiedState.data.currentPresetIndex = 0;
        }

        const presetName = UnifiedState.data.petPresetsOrder[UnifiedState.data.currentPresetIndex];
        const preset = UnifiedState.data.petPresets[presetName];

        attempts++;

        // Check if preset has Crop Eater
        if (preset && !presetHasCropEater(preset)) {
          productionLog(
            `[Cycle Presets] Loading: ${presetName} (${UnifiedState.data.currentPresetIndex + 1}/${UnifiedState.data.petPresetsOrder.length})`
          );
          placePetPreset(presetName);
          return; // Found valid preset
        } else if (preset && presetHasCropEater(preset)) {
          productionLog(`[Cycle Presets] Skipping ${presetName} - contains Crop Eater`);
        }
      } while (attempts < maxAttempts);

      // All presets have Crop Eater
      productionLog('[Cycle Presets] All presets contain Crop Eater - cannot cycle');
    }

    // ==================== PETS UI HELPER FUNCTIONS ====================
    function updatePetPresetDropdown(context) {
      const select = context.querySelector('#preset-quick-select');
      if (!select) return;

      // Preserve current selection
      const currentValue = select.value;

      // Clear existing options except the first one
      select.innerHTML = '<option value="">-- Select Preset --</option>';

      // Add all presets
      Object.keys(UnifiedState.data.petPresets).forEach(name => {
        const preset = UnifiedState.data.petPresets[name];
        const option = targetDocument.createElement('option');
        option.value = name;
        option.textContent = `${name} (${preset.map(p => p.petSpecies).join(', ')})`;
        select.appendChild(option);
      });

      // Restore selection if it still exists
      if (currentValue && UnifiedState.data.petPresets[currentValue]) {
        select.value = currentValue;
      }

      debugLog('PETS_UI', 'Updated preset dropdown without full refresh');
    }

    function updateActivePetsDisplay(context = document, retryCount = 0) {
      // Only log in debug mode to reduce console spam
      if (UnifiedState.data.settings?.debugMode) {
        productionLog('üêæ [ACTIVE-PETS] Updating display', {
          retryCount,
          unifiedStateActivePets: UnifiedState.atoms.activePets?.length || 0,
          windowActivePets: window.activePets?.length || 0,
          context: context === document ? 'document' : 'overlay'
        });
      }

      // Try multiple sources for pet data (React timing issue workaround)
      const activePets = UnifiedState.atoms.activePets || window.activePets || [];

      // If no pets found and this is first try, wait and retry (DOM timing fix)
      if (activePets.length === 0 && retryCount < 3) {
        if (UnifiedState.data.settings?.debugMode) {
          productionLog(`üêæ [ACTIVE-PETS] No pets found, retrying in ${100 * (retryCount + 1)}ms...`);
        }
        setTimeout(() => updateActivePetsDisplay(context, retryCount + 1), 100 * (retryCount + 1));
        return;
      }

      // Find all Active Pets display elements in the given context
      const activePetsDisplays = context.querySelectorAll('.mga-active-pets-display');

      activePetsDisplays.forEach(display => {
        const innerHTML =
          activePets.length > 0
            ? `
                  <div class="mga-active-pets-header">Currently Equipped:</div>
                  <div class="mga-active-pets-list">
                      ${activePets
                        .map((p, index) => {
                          const timeUntilHungry = calculateTimeUntilHungry(p);
                          const timerText = formatHungerTimer(timeUntilHungry);
                          const timerColor =
                            timeUntilHungry === null
                              ? '#999'
                              : timeUntilHungry <= 0
                                ? '#8B0000'
                                : timeUntilHungry < 5 * 60 * 1000
                                  ? '#ff4444'
                                  : timeUntilHungry < 15 * 60 * 1000
                                    ? '#ffa500'
                                    : '#4caf50';
                          return `
                              <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                  <span class="mga-pet-badge">${p.petSpecies}</span>
                                  <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                              </div>
                          `;
                        })
                        .join('')}
                  </div>
              `
            : `
                  <div class="mga-empty-state">
                      <div class="mga-empty-state-icon">‚Äî</div>
                      <div class="mga-empty-state-description">No pets currently active</div>
                  </div>
              `;

        display.innerHTML = innerHTML;
      });

      if (UnifiedState.data.settings?.debugMode) {
        productionLog('üêæ [ACTIVE-PETS] Updated display elements:', {
          elementsFound: activePetsDisplays.length,
          activePetsCount: activePets.length
        });
      }
    }

    // Initialize preset order array if not exists
    function ensurePresetOrder() {
      if (!UnifiedState.data.petPresetsOrder || !Array.isArray(UnifiedState.data.petPresetsOrder)) {
        UnifiedState.data.petPresetsOrder = Object.keys(UnifiedState.data.petPresets);
      } else {
        // Ensure all existing presets are in the order array
        Object.keys(UnifiedState.data.petPresets).forEach(name => {
          if (!UnifiedState.data.petPresetsOrder.includes(name)) {
            UnifiedState.data.petPresetsOrder.push(name);
          }
        });
        // Remove any presets from order array that no longer exist
        UnifiedState.data.petPresetsOrder = UnifiedState.data.petPresetsOrder.filter(name =>
          Object.prototype.hasOwnProperty.call(UnifiedState.data.petPresets, name)
        );
      }
    }

    // Move preset up or down in the order
    function movePreset(presetName, direction, context) {
      productionLog(`üö® [CRITICAL] movePreset called: ${presetName} ${direction}`);
      productionLog(`üö® [CRITICAL] Current order:`, UnifiedState.data.petPresetsOrder);
      ensurePresetOrder();
      const currentIndex = UnifiedState.data.petPresetsOrder.indexOf(presetName);

      if (currentIndex === -1) return;

      let newIndex;
      if (direction === 'up' && currentIndex > 0) {
        newIndex = currentIndex - 1;
      } else if (direction === 'down' && currentIndex < UnifiedState.data.petPresetsOrder.length - 1) {
        newIndex = currentIndex + 1;
      } else {
        return; // Can't move
      }

      // Swap elements
      const temp = UnifiedState.data.petPresetsOrder[currentIndex];
      UnifiedState.data.petPresetsOrder[currentIndex] = UnifiedState.data.petPresetsOrder[newIndex];
      UnifiedState.data.petPresetsOrder[newIndex] = temp;

      // Save the new order
      MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);

      // Force UI refresh after reorder
      productionLog(`üö® [CRITICAL] Order after swap:`, UnifiedState.data.petPresetsOrder);

      // Refresh the preset list display
      refreshPresetsList(context);

      // Refresh popout windows
      refreshSeparateWindowPopouts('pets');

      // Also update main tab content if needed
      if (UnifiedState.activeTab === 'pets') {
        updateTabContent();
      }

      productionLog(`üìã [PET-PRESETS] Moved preset "${presetName}" ${direction}`);
    }

    // Refresh the presets list with new order
    // Helper function for drag and drop positioning
    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.mga-preset:not(.dragging)')];

      return draggableElements.reduce(
        (closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;

          if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
          } else {
            return closest;
          }
        },
        { offset: Number.NEGATIVE_INFINITY }
      ).element;
    }

    function refreshPresetsList(context) {
      const presetsList = context.querySelector('#presets-list');
      if (!presetsList) return;

      // Clear current list
      presetsList.innerHTML = '';

      // Re-add presets in order
      ensurePresetOrder();
      UnifiedState.data.petPresetsOrder.forEach(name => {
        if (UnifiedState.data.petPresets[name]) {
          addPresetToList(context, name, UnifiedState.data.petPresets[name]);
        }
      });
    }

    function addPresetToList(context, name, preset) {
      const presetsList = context.querySelector('#presets-list');
      if (!presetsList) return;

      // Create new preset element
      const presetDiv = targetDocument.createElement('div');
      presetDiv.className = 'mga-preset';
      presetDiv.draggable = true;
      presetDiv.dataset.presetName = name;
      const hotkey = UnifiedState.data.petPresetHotkeys[name];
      presetDiv.innerHTML = `
              <div class="mga-preset-header" style="cursor: move;">
                  <span class="mga-preset-name">‚ãÆ‚ãÆ ${name}</span>
                  <button class="mga-hotkey-btn" data-preset="${name}" style="margin-left: auto; padding: 2px 8px; font-size: 11px; background: rgba(100, 200, 255, 0.48); border: 1px solid #4a9eff; border-radius: 4px; color: white; cursor: pointer;">
                      ${hotkey || 'Set Hotkey'}
                  </button>
              </div>
              <div class="mga-preset-pets">${preset.map(p => p.petSpecies).join(', ')}</div>
              <div class="mga-preset-actions">
                  <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                      <button class="mga-btn mga-btn-sm" data-action="move-up" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">‚Üë</button>
                      <button class="mga-btn mga-btn-sm" data-action="move-down" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">‚Üì</button>
                      <button class="mga-btn mga-btn-sm" data-action="save" data-preset="${name}">Save Current</button>
                  </div>
                  <div style="display: flex; gap: 4px;">
                      <button class="mga-btn mga-btn-sm" data-action="place" data-preset="${name}">Place</button>
                      <button class="mga-btn mga-btn-sm" data-action="remove" data-preset="${name}">Remove</button>
                  </div>
              </div>
          `;

      // Add drag-and-drop handlers
      presetDiv.addEventListener('dragstart', e => {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', name);
        presetDiv.style.opacity = '0.5';
      });

      presetDiv.addEventListener('dragend', e => {
        presetDiv.style.opacity = '';
      });

      presetDiv.addEventListener('dragover', e => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const afterElement = getDragAfterElement(presetsList, e.clientY);
        if (afterElement == null) {
          presetsList.appendChild(presetDiv);
        } else {
          presetsList.insertBefore(presetDiv, afterElement);
        }
      });

      presetDiv.addEventListener('drop', e => {
        e.preventDefault();
        const draggedPresetName = e.dataTransfer.getData('text/plain');
        if (draggedPresetName && draggedPresetName !== name) {
          // Update order array based on current DOM order
          const newOrder = Array.from(presetsList.children)
            .map(el => el.dataset.presetName)
            .filter(Boolean);
          UnifiedState.data.petPresetsOrder = newOrder;
          MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);
          refreshPresetsList(context);
        }
      });

      // Add hotkey button handler
      const hotkeyBtn = presetDiv.querySelector('.mga-hotkey-btn');
      if (hotkeyBtn) {
        hotkeyBtn.addEventListener('click', e => {
          e.stopPropagation();
          showHotkeyRecordingModal(name, context);
        });
      }

      // Add event handlers to new buttons
      presetDiv.querySelectorAll('[data-action]').forEach(btn => {
        btn.setAttribute('data-handler-setup', 'true');
        btn.addEventListener('click', e => {
          e.preventDefault();
          const action = e.target.dataset.action;
          const presetName = e.target.dataset.preset;

          if (action === 'save') {
            UnifiedState.data.petPresets[presetName] = (UnifiedState.atoms.activePets || []).slice(0, 3);

            // Use safe save with user feedback for critical pet preset data
            const result = MGA_safeSave('MGA_petPresets', UnifiedState.data.petPresets, {
              description: `pet preset "${presetName}"`,
              criticalData: true,
              showUserAlert: true
            });

            if (result.success) {
              productionLog(`‚úÖ [PET-PRESETS] Successfully saved preset "${presetName}"`);
            } else {
              console.error(`‚ùå [PET-PRESETS] Failed to save preset "${presetName}":`, result.error);
            }

            updatePetPresetDropdown(context);
            refreshSeparateWindowPopouts('pets');
            debugLog('BUTTON_INTERACTIONS', `Saved preset: ${presetName} (from added element)`);
          } else if (action === 'place') {
            // CRITICAL: Stop event propagation to prevent game clicks
            e.stopPropagation();
            e.preventDefault();

            window.debouncedPlacePetPreset(presetName);
            debugLog('BUTTON_INTERACTIONS', `Placed preset: ${presetName} (from added element)`);
          } else if (action === 'remove') {
            delete UnifiedState.data.petPresets[presetName];

            // Clean up associated hotkey if it exists
            if (UnifiedState.data.petPresetHotkeys[presetName]) {
              const deletedHotkey = UnifiedState.data.petPresetHotkeys[presetName];
              delete UnifiedState.data.petPresetHotkeys[presetName];
              MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
              console.log(`[MGTOOLS] Cleared hotkey "${deletedHotkey}" for deleted preset: ${presetName}`);
            }

            // Remove from order array
            ensurePresetOrder();
            const orderIndex = UnifiedState.data.petPresetsOrder.indexOf(presetName);
            if (orderIndex !== -1) {
              UnifiedState.data.petPresetsOrder.splice(orderIndex, 1);
              MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);
            }

            // Use safe save for critical pet preset removal
            const result = MGA_safeSave('MGA_petPresets', UnifiedState.data.petPresets, {
              description: `pet preset deletion "${presetName}"`,
              criticalData: true,
              showUserAlert: true
            });

            if (result.success) {
              productionLog(`‚úÖ [PET-PRESETS] Successfully removed preset "${presetName}"`);
              presetDiv.remove();
            } else {
              console.error(`‚ùå [PET-PRESETS] Failed to remove preset "${presetName}":`, result.error);
              // Restore the preset in memory since save failed
              UnifiedState.data.petPresets[presetName] = UnifiedState.data.petPresets[presetName] || [];
              // Also restore to order array
              if (orderIndex !== -1 && !UnifiedState.data.petPresetsOrder.includes(presetName)) {
                UnifiedState.data.petPresetsOrder.splice(orderIndex, 0, presetName);
              }
            }
            updatePetPresetDropdown(context);
            refreshSeparateWindowPopouts('pets');
            debugLog('BUTTON_INTERACTIONS', `Removed preset: ${presetName} (from added element)`);
          } else if (action === 'move-up') {
            productionLog(`üö® [CRITICAL] Move up button clicked for ${presetName}`);
            movePreset(presetName, 'up', context);
          } else if (action === 'move-down') {
            productionLog(`üö® [CRITICAL] Move down button clicked for ${presetName}`);
            movePreset(presetName, 'down', context);
          }
        });
      });

      presetsList.appendChild(presetDiv);
      debugLog('PETS_UI', `Added preset ${name} to list without full refresh`);
    }

    /* ============================================================================
     * 11. EVENT MODULE - START
     * ============================================================================
     * Event handlers for all UI interactions and user inputs
     */

    /**
     * Sets up event handlers for the pets tab
     * @function setupPetsTabHandlers
     * @param {Document|Element} context - DOM context for event binding
     */
    function setupPetsTabHandlers(context = document) {
      productionLog('üö® [CRITICAL] Setting up pet preset handlers');

      // Use event delegation on the parent container for all preset buttons
      const presetsContainer = context.querySelector('#presets-list');
      if (presetsContainer) {
        productionLog('üö® [CRITICAL] Found presets container, adding delegation');

        // Remove old listener if it exists
        if (presetsContainer._mgaClickHandler) {
          presetsContainer.removeEventListener('click', presetsContainer._mgaClickHandler);
        }

        // Create new handler
        presetsContainer._mgaClickHandler = e => {
          const btn = e.target.closest('[data-action]');
          if (!btn) return;

          e.preventDefault();
          e.stopPropagation();

          const action = btn.dataset.action;
          const presetName = btn.dataset.preset;

          productionLog(`üö® [CRITICAL] Delegated click: action=${action}, preset=${presetName}`);

          if (action === 'move-up') {
            productionLog(`üö® [CRITICAL] Moving ${presetName} UP`);
            movePreset(presetName, 'up', context);
          } else if (action === 'move-down') {
            productionLog(`üö® [CRITICAL] Moving ${presetName} DOWN`);
            movePreset(presetName, 'down', context);
          } else if (action === 'save') {
            productionLog(`üö® [CRITICAL] Saving preset ${presetName}`);
            UnifiedState.data.petPresets[presetName] = (UnifiedState.atoms.activePets || []).slice(0, 3);
            MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
            refreshPresetsList(context);
          } else if (action === 'place') {
            productionLog(`üö® [CRITICAL] Placing preset ${presetName}`);
            window.debouncedPlacePetPreset(presetName);
          } else if (action === 'remove') {
            productionLog(`[CRITICAL] Removing preset ${presetName}`);
            delete UnifiedState.data.petPresets[presetName];

            // Clean up associated hotkey if it exists
            if (UnifiedState.data.petPresetHotkeys[presetName]) {
              const deletedHotkey = UnifiedState.data.petPresetHotkeys[presetName];
              delete UnifiedState.data.petPresetHotkeys[presetName];
              MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
              console.log(`[MGTOOLS] Cleared hotkey "${deletedHotkey}" for deleted preset: ${presetName}`);
            }

            MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
            refreshPresetsList(context);
          }
        };

        // Add the handler
        presetsContainer.addEventListener('click', presetsContainer._mgaClickHandler);
        productionLog('üö® [CRITICAL] Event delegation handler attached successfully');

        // Handle hotkey button clicks
        context.querySelectorAll('.mga-hotkey-btn').forEach(btn => {
          btn.addEventListener('click', e => {
            e.stopPropagation();
            const presetName = btn.dataset.preset;
            showHotkeyRecordingModal(presetName, context);
          });
        });
      } else {
        productionLog('üö® [CRITICAL] ERROR: presets container not found!');
      }

      const input = context.querySelector('#preset-name-input');
      if (input) {
        // Comprehensive input isolation to prevent game key interference and modal detection

        let handlingEvent = false;

        // Add additional isolation layer for the input container
        // Note: Removed aggressive event blocking that was preventing UI interactions

        // Create input isolation system
        const createInputIsolation = function (inputElement) {
          // Prevent ALL game key interference when input is focused
          const isolateKeyEvent = e => {
            if (document.activeElement === inputElement) {
              // Stop all propagation to prevent game from receiving keys
              e.stopImmediatePropagation();
              e.stopPropagation();

              // Handle special keys
              if (e.key === 'Escape') {
                e.preventDefault();
                inputElement.blur(); // Allow user to return to game
                return;
              }

              // Allow Enter to submit
              if (e.key === 'Enter') {
                e.preventDefault();
                const addBtn = context.querySelector('#add-preset-btn');
                if (addBtn) addBtn.click();
                return;
              }

              // For other keys, let the input handle them naturally
              // but prevent game from seeing them
            }
          };

          // Capture ALL key events before they reach the game
          ['keydown', 'keyup', 'keypress'].forEach(eventType => {
            inputElement.addEventListener(eventType, isolateKeyEvent, {
              capture: true,
              passive: false
            });
          });

          // Also isolate focus/blur events
          inputElement.addEventListener('focus', e => {
            if (UnifiedState.data.settings.debugMode) {
              productionLog('üîí Input focused - Game keys isolated');
            }
            e.stopPropagation();
          });

          inputElement.addEventListener('blur', e => {
            if (UnifiedState.data.settings.debugMode) {
              productionLog('üîì Input blurred - Game keys restored');
            }
            e.stopPropagation();
          });
        };

        // Apply input isolation
        createInputIsolation(input);

        // Existing click handlers with improved event handling
        input.addEventListener('mousedown', e => {
          if (handlingEvent) return;
          handlingEvent = true;
          e.stopPropagation();

          setTimeout(() => {
            handlingEvent = false;
          }, 50);
        });

        input.addEventListener('click', e => {
          if (handlingEvent) return;
          e.stopPropagation();

          // Only select all if the input is empty or user clicked when not focused
          if (input.value === '' || document.activeElement !== input) {
            setTimeout(() => {
              input.focus();
              input.select();
            }, 0);
          }
        });
      }

      // Cycle Presets Hotkey Button Handler
      const setCycleHotkeyBtn = context.querySelector('#set-cycle-hotkey-btn');
      if (setCycleHotkeyBtn && !setCycleHotkeyBtn.hasAttribute('data-handler-setup')) {
        setCycleHotkeyBtn.setAttribute('data-handler-setup', 'true');
        setCycleHotkeyBtn.addEventListener('click', () => {
          startRecordingHotkeyMGTools('cyclePresets', setCycleHotkeyBtn);
        });
      }

      // Quick Load Button Handler
      const quickLoadBtn = context.querySelector('#quick-load-btn');
      if (quickLoadBtn && !quickLoadBtn.hasAttribute('data-handler-setup')) {
        quickLoadBtn.setAttribute('data-handler-setup', 'true');
        quickLoadBtn.addEventListener('click', () => {
          const select = context.querySelector('#preset-quick-select');
          const presetName = select.value;

          if (!presetName) {
            productionWarn('[PETS] No preset selected');
            return;
          }

          if (!UnifiedState.data.petPresets[presetName]) {
            productionWarn('[PETS] Preset not found:', presetName);
            return;
          }

          const preset = UnifiedState.data.petPresets[presetName];

          // Validate preset
          if (!preset || !Array.isArray(preset) || preset.length === 0) {
            productionWarn('[PETS] Preset is empty or invalid:', preset);
            return;
          }

          const maxSlots = 3;

          // Native swap approach - works even with full inventory!
          let delay = 0;

          for (let slotIndex = 0; slotIndex < maxSlots; slotIndex++) {
            const desiredPet = preset[slotIndex];

            // BUGFIX: Capture delay value in closure to prevent race conditions
            ((currentDelay, slot) => {
              setTimeout(() => {
                // BUGFIX: Read FRESH state inside timeout (not stale reference)
                const currentPets = UnifiedState.atoms.activePets || window.activePets || [];
                const currentPet = currentPets[slot];

                if (currentPet && desiredPet) {
                  // Check if desired pet is already equipped
                  if (currentPet.id === desiredPet.id) {
                    if (UnifiedState.data.settings?.debugMode) {
                      productionLog(`[PET-SWAP] Slot ${slot + 1}: Already equipped (${currentPet.id}), skipping`);
                    }
                    return; // Skip swap, pet already in place
                  }

                  // Both exist: Use native SwapPet (no inventory space needed!)
                  if (UnifiedState.data.settings?.debugMode) {
                    productionLog(`[PET-SWAP] Slot ${slot + 1}: Swapping ${currentPet.id} ‚Üí ${desiredPet.id}`);
                  }

                  safeSendMessage({
                    scopePath: ['Room', 'Quinoa'],
                    type: 'SwapPet',
                    petSlotId: currentPet.id,
                    petInventoryId: desiredPet.id
                  });
                } else if (!currentPet && desiredPet) {
                  // Empty slot: Place new pet
                  if (UnifiedState.data.settings?.debugMode) {
                    productionLog(`[PET-SWAP] Slot ${slot + 1}: Placing ${desiredPet.id} (empty slot)`);
                  }

                  safeSendMessage({
                    scopePath: ['Room', 'Quinoa'],
                    type: 'PlacePet',
                    itemId: desiredPet.id,
                    position: { x: 17 + slot * 2, y: 13 },
                    localTileIndex: 64,
                    tileType: 'Boardwalk'
                  });
                } else if (currentPet && !desiredPet) {
                  // Remove excess pet (preset has fewer pets)
                  if (UnifiedState.data.settings?.debugMode) {
                    productionLog(`[PET-SWAP] Slot ${slot + 1}: Storing ${currentPet.id} (no preset pet)`);
                  }

                  safeSendMessage({
                    scopePath: ['Room', 'Quinoa'],
                    type: 'StorePet',
                    itemId: currentPet.id
                  });
                }
              }, currentDelay);
            })(delay, slotIndex);

            // Increase delay: 100ms ‚Üí 200ms for better network latency tolerance
            delay += 200;
          }

          // Refresh after swaps complete
          setTimeout(() => {
            updateActivePetsFromRoomState();
            updateActivePetsDisplay(context);
          }, delay + 200);

          setTimeout(() => {
            updateActivePetsFromRoomState();
            updateActivePetsDisplay(context);
          }, delay + 600);

          setTimeout(() => {
            updateActivePetsFromRoomState();
            updateActivePetsDisplay(context);
            refreshSeparateWindowPopouts('pets');
            UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === 'pets') {
                if (overlay.className.includes('mga-overlay-content-only')) {
                  updatePureOverlayContent(overlay, tabName);
                }
              }
            });
          }, delay + 1000);
        });
      }

      // Add/Save Preset Button Handler
      const addBtn = context.querySelector('#add-preset-btn');
      if (addBtn && !addBtn.hasAttribute('data-handler-setup')) {
        addBtn.setAttribute('data-handler-setup', 'true');
        addBtn.addEventListener('click', () => {
          const input = context.querySelector('#preset-name-input');
          const name = input.value.trim();
          if (name && UnifiedState.atoms.activePets && UnifiedState.atoms.activePets.length) {
            // Save full pet data including abilities for Crop Eater detection
            UnifiedState.data.petPresets[name] = UnifiedState.atoms.activePets.slice(0, 3);
            MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
            input.value = ''; // Clear input after successful add

            // Add preset name to order array
            ensurePresetOrder();
            if (!UnifiedState.data.petPresetsOrder.includes(name)) {
              UnifiedState.data.petPresetsOrder.push(name);
              MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);
            }

            // Refresh preset list to show in correct order
            refreshPresetsList(context);

            // Update dropdown
            updatePetPresetDropdown(context);

            // Update popouts
            refreshSeparateWindowPopouts('pets');
            UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === 'pets') {
                if (overlay.className.includes('mga-overlay-content-only')) {
                  updatePureOverlayContent(overlay, tabName);
                }
              }
            });

            debugLog('BUTTON_INTERACTIONS', `Created new preset: ${name} without full DOM refresh`);
          } else if (!name) {
            input.focus(); // Focus input if name is empty
          }
        });
      }

      // Prevent duplicate event listeners by checking if already handled
      context.querySelectorAll('[data-action]').forEach(btn => {
        if (btn.hasAttribute('data-handler-setup')) {
          return; // Skip if already has event listener
        }
        btn.setAttribute('data-handler-setup', 'true');

        btn.addEventListener('click', e => {
          e.preventDefault();
          debugLog('BUTTON_INTERACTIONS', `Button clicked: ${e.target.dataset.action}`, {
            preset: e.target.dataset.preset,
            buttonText: e.target.textContent
          });

          const action = e.target.dataset.action;
          const presetName = e.target.dataset.preset;

          if (action === 'save') {
            UnifiedState.data.petPresets[presetName] = (UnifiedState.atoms.activePets || []).slice(0, 3);
            MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);

            // Update only the quick select dropdown without full refresh
            updatePetPresetDropdown(context);

            // Update all pet overlays (they need full updates for popouts)
            UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === 'pets') {
                if (overlay.className.includes('mga-overlay-content-only')) {
                  updatePureOverlayContent(overlay, tabName);
                  debugLog('OVERLAY_LIFECYCLE', 'Updated pure pets overlay after saving preset');
                }
              }
            });

            // Update separate window popouts
            refreshSeparateWindowPopouts('pets');

            debugLog('BUTTON_INTERACTIONS', `Saved preset: ${presetName} without full DOM refresh`);
          } else if (action === 'place') {
            window.debouncedPlacePetPreset(presetName);
          } else if (action === 'remove') {
            delete UnifiedState.data.petPresets[presetName];

            // Clean up associated hotkey if it exists
            if (UnifiedState.data.petPresetHotkeys[presetName]) {
              const deletedHotkey = UnifiedState.data.petPresetHotkeys[presetName];
              delete UnifiedState.data.petPresetHotkeys[presetName];
              MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
              console.log(`[MGTOOLS] Cleared hotkey "${deletedHotkey}" for deleted preset: ${presetName}`);
            }

            MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);

            // Remove the preset element from DOM without full refresh
            const presetElement = e.target.closest('.mga-preset');
            if (presetElement) {
              presetElement.remove();
            }

            // Update the dropdown
            updatePetPresetDropdown(context);

            // Update all pet overlays
            UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === 'pets') {
                if (overlay.className.includes('mga-overlay-content-only')) {
                  updatePureOverlayContent(overlay, tabName);
                  debugLog('OVERLAY_LIFECYCLE', 'Updated pure pets overlay after removing preset');
                }
              }
            });

            // Update separate window popouts
            refreshSeparateWindowPopouts('pets');

            debugLog('BUTTON_INTERACTIONS', `Removed preset: ${presetName} without full DOM refresh`);
          }
        });
      });

      // Handle popout preset buttons (simplified interface)
      context.querySelectorAll('[data-preset]').forEach(btn => {
        if (btn.hasAttribute('data-handler-setup')) return;
        btn.setAttribute('data-handler-setup', 'true');

        btn.addEventListener('click', e => {
          e.preventDefault();
          const presetName = e.target.dataset.preset;
          const preset = UnifiedState.data.petPresets[presetName];

          if (!preset || !preset.length) {
            productionWarn(`‚ö†Ô∏è Preset "${presetName}" not found or empty!`);
            return;
          }

          debugLog('BUTTON_INTERACTIONS', `Loading preset from popout: ${presetName}`, { preset });

          const currentPets = UnifiedState.atoms.activePets || [];

          // Clear existing pets WITH DELAYS (50ms between each) - CRITICAL FIX for slow connections
          currentPets.forEach((p, i) => {
            setTimeout(() => {
              safeSendMessage({
                scopePath: ['Room', 'Quinoa'],
                type: 'RemovePet',
                itemId: p.id
              });
            }, i * 50);
          });

          // Calculate delay before placing new pets (wait for all RemovePet to complete)
          const removalDelay = currentPets.length * 50 + 200; // Extra 200ms buffer

          // Place preset pets with delays AFTER removal completes
          preset.forEach((p, i) => {
            setTimeout(
              () => {
                safeSendMessage({
                  scopePath: ['Room', 'Quinoa'],
                  type: 'PlacePet',
                  itemId: p.id,
                  position: { x: 17 + i * 2, y: 13 },
                  localTileIndex: 64,
                  tileType: 'Boardwalk'
                });
              },
              removalDelay + i * 50
            );
          });

          // Update popouts after removal + placement completes
          setTimeout(
            () => {
              updateActivePetsFromRoomState();
              refreshSeparateWindowPopouts('pets');
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                if (overlay && document.contains(overlay) && tabName === 'pets') {
                  if (overlay.className.includes('mga-overlay-content-only')) {
                    updatePureOverlayContent(overlay, tabName);
                  }
                }
              });
            },
            removalDelay + preset.length * 50 + 1000
          );
        });
      });

      // === EXPORT/IMPORT BUTTON HANDLERS (v3.8.7) ===
      const exportBtn = context.querySelector('#export-presets-btn');
      if (exportBtn && !exportBtn.hasAttribute('data-handler-setup')) {
        exportBtn.setAttribute('data-handler-setup', 'true');
        exportBtn.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
          exportPetPresets();
        });
      }

      const importBtn = context.querySelector('#import-presets-btn');
      if (importBtn && !importBtn.hasAttribute('data-handler-setup')) {
        importBtn.setAttribute('data-handler-setup', 'true');
        importBtn.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
          importPetPresets();
        });
      }

      // Pet management handlers will be added here when we detect actual Magic Garden pets
    }

    // ==================== MAGIC GARDEN PET HELPERS ====================
    // Pet helpers for actual Magic Garden pets (not generic fantasy pets)

    class ResourceDashboard {
      constructor() {
        this.resourceHistory = localStorage.getItem('MGA_resourceHistory') || [];
        this.resourceAlerts = localStorage.getItem('MGA_resourceAlerts') || {};

        // Initialize resource tracking if not exists
        if (!UnifiedState.data.resources) {
          UnifiedState.data.resources = {
            coins: 0,
            gems: 0,
            seeds: {},
            tiles: 0,
            lastUpdate: Date.now()
          };
        }
      }

      updateResourceHistory() {
        try {
          const currentResources = {
            timestamp: Date.now(),
            coins: UnifiedState.atoms.coinCount || 0,
            gems: UnifiedState.atoms.gems || 0,
            seeds: Object.keys(UnifiedState.atoms.seedInventory || {}).length,
            tiles: UnifiedState.atoms.tiles || 0
          };

          this.resourceHistory.push(currentResources);
          if (this.resourceHistory.length > 100) {
            this.resourceHistory = this.resourceHistory.slice(-100);
          }
          localStorage.setItem('MGA_resourceHistory', JSON.stringify(this.resourceHistory));
        } catch (error) {
          console.error('Error updating resource history:', error);
        }
      }

      generateDashboard() {
        const latest = this.resourceHistory[this.resourceHistory.length - 1];
        if (!latest) {
          return `<div class="mga-section"><div class="mga-section-title">üìä Resource Dashboard</div><div style="color: rgba(255,255,255,0.6); text-align: center; padding: 20px;">No resource data available yet.</div></div>`;
        }

        return `
                  <div class="mga-section">
                      <div class="mga-section-title">üìä Resource Dashboard</div>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin: 15px 0;">
                          <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px;">
                              <div style="color: #F59E0B; font-size: 24px; font-weight: bold;">${latest.coins.toLocaleString()}</div>
                              <div style="color: rgba(255,255,255,0.7); font-size: 12px;">üí∞ Coins</div>
                          </div>
                          <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px;">
                              <div style="color: #8B5CF6; font-size: 24px; font-weight: bold;">${latest.gems.toLocaleString()}</div>
                              <div style="color: rgba(255,255,255,0.7); font-size: 12px;">üíé Gems</div>
                          </div>
                          <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px;">
                              <div style="color: #10B981; font-size: 24px; font-weight: bold;">${latest.seeds}</div>
                              <div style="color: rgba(255,255,255,0.7); font-size: 12px;">üå± Seeds</div>
                          </div>
                      </div>
                  </div>
              `;
      }

      setupDashboardHandlers(context = document) {
        // Resource dashboard handlers
      }
    }

    // Create global instance
    window.resourceDashboard = new ResourceDashboard();

    // setupAbilitiesTabHandlers is defined later in file (line ~16772)

    // ==================== LOADING STATE UTILITIES ====================
    window.MGA_LoadingStates = {
      show: (element, text = 'Loading...') => {
        if (!element) return;
        const loadingHtml = `
                  <div class="mga-loading">
                      <div class="mga-loading-spinner"></div>
                      <span>${text}</span>
                  </div>
              `;
        element.innerHTML = loadingHtml;
      },

      showSkeleton: (element, lines = 3) => {
        if (!element) return;
        const skeletonLines = Array(lines)
          .fill(0)
          .map(
            () =>
              `<div class="mga-skeleton" style="height: 20px; margin-bottom: 8px; width: ${Math.floor(Math.random() * 40 + 60)}%;"></div>`
          )
          .join('');
        element.innerHTML = `<div style="padding: 20px;">${skeletonLines}</div>`;
      },

      hide: (element, content, fadeIn = true) => {
        if (!element) return;
        element.innerHTML = content;
        if (fadeIn) {
          element.classList.add('mga-fade-in');
          setTimeout(() => element.classList.remove('mga-fade-in'), 300);
        }
      }
    };

    // Forward declaration (initialized later in ability log display optimization)
    let lastLogCount;

    function setupAbilitiesTabHandlers(context = document) {
      debugLog('ABILITY_LOGS', 'Setting up abilities tab handlers with context', {
        isDocument: context === document,
        className: context.className || 'document'
      });

      // Filter mode switching
      const categoriesBtn = context.querySelector('#filter-mode-categories');
      const byPetBtn = context.querySelector('#filter-mode-bypet');
      const customBtn = context.querySelector('#filter-mode-custom');

      if (categoriesBtn && !categoriesBtn.hasAttribute('data-handler-setup')) {
        categoriesBtn.setAttribute('data-handler-setup', 'true');
        categoriesBtn.addEventListener('click', () => switchFilterMode('categories'));
      }
      if (byPetBtn && !byPetBtn.hasAttribute('data-handler-setup')) {
        byPetBtn.setAttribute('data-handler-setup', 'true');
        byPetBtn.addEventListener('click', () => switchFilterMode('byPet'));
      }
      if (customBtn && !customBtn.hasAttribute('data-handler-setup')) {
        customBtn.setAttribute('data-handler-setup', 'true');
        customBtn.addEventListener('click', () => switchFilterMode('custom'));
      }

      // All/None filter buttons (context-aware)
      const selectAllBtn = context.querySelector('#select-all-filters');
      const selectNoneBtn = context.querySelector('#select-none-filters');

      if (selectAllBtn && !selectAllBtn.hasAttribute('data-handler-setup')) {
        selectAllBtn.setAttribute('data-handler-setup', 'true');
        selectAllBtn.addEventListener('click', () => {
          const mode = UnifiedState.data.filterMode || 'categories';
          selectAllFilters(mode);
        });
      }

      if (selectNoneBtn && !selectNoneBtn.hasAttribute('data-handler-setup')) {
        selectNoneBtn.setAttribute('data-handler-setup', 'true');
        selectNoneBtn.addEventListener('click', () => {
          const mode = UnifiedState.data.filterMode || 'categories';
          selectNoneFilters(mode);
        });
      }

      // Category filter checkboxes - USE CONTEXT-AWARE SELECTORS
      context.querySelectorAll('#category-filters .mga-checkbox[data-filter]').forEach(checkbox => {
        if (!checkbox.hasAttribute('data-handler-setup')) {
          checkbox.setAttribute('data-handler-setup', 'true');
          checkbox.addEventListener('change', e => {
            const filterKey = e.target.dataset.filter;
            UnifiedState.data.abilityFilters[filterKey] = e.target.checked;
            MGA_saveJSON('MGA_abilityFilters', UnifiedState.data.abilityFilters);

            // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
            updateAllLogVisibility();
            debugLog('ABILITY_LOGS', `Filter ${filterKey} changed to ${e.target.checked}, updated visibility via CSS`);
          });
        }
      });

      // Basic action buttons
      const clearLogsBtn = context.querySelector('#clear-logs-btn');
      if (clearLogsBtn && !clearLogsBtn.hasAttribute('data-handler-setup')) {
        clearLogsBtn.setAttribute('data-handler-setup', 'true');
        clearLogsBtn.addEventListener('click', () => {
          logDebug('ABILITY-LOGS', 'Starting comprehensive ability log clear...');

          // BEFORE CLEAR: Show what exists in each storage
          const beforeClear = {
            memory: UnifiedState.data.petAbilityLogs?.length || 0,
            gmMain: (() => {
              try {
                const v = GM_getValue('MGA_petAbilityLogs', null);
                return v ? JSON.parse(v).length : 0;
              } catch (e) {
                return 0;
              }
            })(),
            gmArchive: (() => {
              try {
                const v = GM_getValue('MGA_petAbilityLogs_archive', null);
                return v ? JSON.parse(v).length : 0;
              } catch (e) {
                return 0;
              }
            })(),
            lsMain: (() => {
              try {
                const v = window.localStorage?.getItem('MGA_petAbilityLogs');
                return v ? JSON.parse(v).length : 0;
              } catch (e) {
                return 0;
              }
            })(),
            lsArchive: (() => {
              try {
                const v = window.localStorage?.getItem('MGA_petAbilityLogs_archive');
                return v ? JSON.parse(v).length : 0;
              } catch (e) {
                return 0;
              }
            })()
          };

          logDebug('ABILITY-LOGS', 'üìä BEFORE CLEAR - Log counts:', beforeClear);

          // Show individual logs from memory (to identify which one won't delete)
          if (UnifiedState.data.petAbilityLogs?.length > 0) {
            logDebug('ABILITY-LOGS', 'üìã Current logs in memory:');
            UnifiedState.data.petAbilityLogs.forEach((log, i) => {
              logDebug(
                'ABILITY-LOGS',
                `  ${i + 1}. ${log.abilityType} - ${log.petName} - ${new Date(log.timestamp).toLocaleString()}`
              );
            });
          }

          // 1. Clear memory
          UnifiedState.data.petAbilityLogs = [];
          logDebug('ABILITY-LOGS', '  ‚úì Cleared UnifiedState memory');

          // 2. Clear GM storage (Tampermonkey)
          MGA_saveJSON('MGA_petAbilityLogs', []);
          MGA_saveJSON('MGA_petAbilityLogs_archive', []);
          logDebug('ABILITY-LOGS', '  ‚úì Cleared GM storage (main + archive)');

          // 3. Clear window.localStorage directly (bypass sync logic)
          try {
            window.localStorage?.removeItem('MGA_petAbilityLogs');
            window.localStorage?.removeItem('MGA_petAbilityLogs_archive');
            logDebug('ABILITY-LOGS', '  ‚úì Cleared window.localStorage');
          } catch (e) {
            logWarn('ABILITY-LOGS', '  ‚ö†Ô∏è Could not clear window.localStorage:', e.message);
          }

          // 4. Clear targetWindow.localStorage (if different from window)
          try {
            if (typeof targetWindow !== 'undefined' && targetWindow && targetWindow !== window) {
              targetWindow.localStorage?.removeItem('MGA_petAbilityLogs');
              targetWindow.localStorage?.removeItem('MGA_petAbilityLogs_archive');
              logDebug('ABILITY-LOGS', '  ‚úì Cleared targetWindow.localStorage');
            }
          } catch (e) {
            logWarn('ABILITY-LOGS', '  ‚ö†Ô∏è Could not clear targetWindow.localStorage:', e.message);
          }

          // 5. Clear compatibility array
          try {
            if (typeof window.petAbilityLogs !== 'undefined') {
              window.petAbilityLogs = [];
              logDebug('ABILITY-LOGS', '  ‚úì Cleared window.petAbilityLogs compatibility array');
            }
          } catch (e) {
            logWarn('ABILITY-LOGS', '  ‚ö†Ô∏è Could not clear compatibility array:', e.message);
          }

          // 6. Set comprehensive clear flags with timestamp-based session lock
          const clearTimestamp = Date.now();
          localStorage.setItem('MGA_logs_manually_cleared', clearTimestamp.toString());
          localStorage.setItem('MGA_logs_clear_session', clearTimestamp.toString());
          try {
            GM_setValue('MGA_logs_manually_cleared', clearTimestamp.toString());
          } catch (e) {
            logWarn('ABILITY-LOGS', '  ‚ö†Ô∏è Could not set GM clear flag:', e.message);
          }
          logDebug('ABILITY-LOGS', '  ‚úì Set manual clear flags (session + GM + timestamp)');

          // 7. AFTER CLEAR: Comprehensive verification
          const verifyMain = MGA_loadJSON('MGA_petAbilityLogs', null);
          const verifyArchive = MGA_loadJSON('MGA_petAbilityLogs_archive', null);
          const verifyLS = window.localStorage?.getItem('MGA_petAbilityLogs');
          const verifyCompat = typeof window.petAbilityLogs !== 'undefined' ? window.petAbilityLogs?.length : 'N/A';

          // Recount all sources after clear
          const afterClear = {
            memory: UnifiedState.data.petAbilityLogs?.length || 0,
            gmMain: verifyMain?.length || 0,
            gmArchive: verifyArchive?.length || 0,
            lsMain: verifyLS
              ? (() => {
                  try {
                    return JSON.parse(verifyLS).length;
                  } catch (e) {
                    return 'parse-error';
                  }
                })()
              : 0,
            lsArchive: (() => {
              try {
                const v = window.localStorage?.getItem('MGA_petAbilityLogs_archive');
                return v ? JSON.parse(v).length : 0;
              } catch (e) {
                return 0;
              }
            })(),
            compatArray: verifyCompat
          };

          logDebug('ABILITY-LOGS', 'üìä AFTER CLEAR - Log counts:', afterClear);
          logDebug('ABILITY-LOGS', 'üìä COMPARISON:', {
            before: beforeClear,
            after: afterClear,
            clearedFlag: localStorage.getItem('MGA_logs_manually_cleared')
          });

          // If ANY logs remain, show which ones
          const totalRemaining = Object.values(afterClear).reduce(
            (sum, val) => sum + (typeof val === 'number' ? val : 0),
            0
          );

          if (totalRemaining > 0) {
            productionWarn(`‚ö†Ô∏è [ABILITIES] ${totalRemaining} log(s) persist after clear!`);
            logDebug('ABILITY-LOGS', 'üîç Logs that persisted - check these sources:', afterClear);

            // Show which specific logs remain (if any)
            if (verifyMain && verifyMain.length > 0) {
              logDebug('ABILITY-LOGS', '‚ùå PERSISTENT LOGS IN GM STORAGE:');
              verifyMain.forEach((log, i) => {
                logDebug(
                  'ABILITY-LOGS',
                  `  ${i + 1}. ${log.abilityType} - ${log.petName} - ${new Date(log.timestamp).toLocaleString()}`
                );
              });
            }
          } else {
            productionLog('‚úÖ [ABILITIES] Successfully cleared all ability logs from all storage locations');
          }

          lastLogCount = 0; // Reset log count tracker
          updateTabContent();
          updateAllAbilityLogDisplays();
        });
      }

      const exportLogsBtn = context.querySelector('#export-logs-btn');
      if (exportLogsBtn && !exportLogsBtn.hasAttribute('data-handler-setup')) {
        exportLogsBtn.setAttribute('data-handler-setup', 'true');
        exportLogsBtn.addEventListener('click', () => {
          exportAbilityLogs();
        });
      }

      // Diagnose logs button (only visible when debug mode is enabled)
      const diagnoseLogsBtn = context.querySelector('#diagnose-logs-btn');
      if (diagnoseLogsBtn && !diagnoseLogsBtn.hasAttribute('data-handler-setup')) {
        diagnoseLogsBtn.setAttribute('data-handler-setup', 'true');
        diagnoseLogsBtn.addEventListener('click', () => {
          console.log('üîç Running ability logs storage diagnostic...');
          const report = MGA_diagnoseAbilityLogStorage();

          // Show a user-friendly notification
          const totalWithLogs = report.summary.totalLocationsWithLogs;
          if (totalWithLogs === 0) {
            showNotificationToast('‚úÖ No ability logs found in any storage location', 'success');
          } else {
            showNotificationToast(
              `üìä Found logs in ${totalWithLogs} storage location(s). Check console for details.`,
              'info'
            );
          }
        });
      }

      // Detailed timestamps checkbox
      const detailedTimestampsCheckbox = context.querySelector('#detailed-timestamps-checkbox');
      if (detailedTimestampsCheckbox && !detailedTimestampsCheckbox.hasAttribute('data-handler-setup')) {
        detailedTimestampsCheckbox.setAttribute('data-handler-setup', 'true');
        detailedTimestampsCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.detailedTimestamps = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);

          // Clear timestamp cache and force full rebuild for timestamp format change
          // eslint-disable-next-line no-use-before-define -- cache is initialized below; usage occurs after init at runtime
          MGA_AbilityCache.timestamps.clear();

          // BUGFIX: Force overlay refresh to show new timestamp format
          // Update all overlays first to ensure they show the new format
          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
            if (tabName === 'abilities' && overlay && overlay.offsetParent !== null) {
              updateAbilityLogDisplay(overlay);
              debugLog('ABILITY_LOGS', 'Updated overlay with new timestamp format');
            }
          });

          // Then update main displays
          updateAllAbilityLogDisplays(true);
          productionLog(`üïê [ABILITIES] Detailed timestamps: ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }

      // Test Abilities button removed - function kept for potential debugging use

      // Initialize the current filter mode display
      const currentMode = UnifiedState.data.filterMode || 'categories';
      setTimeout(() => populateFilterModeContent(currentMode), 100);
    }

    // PERFORMANCE OPTIMIZATION: Caching for expensive operations
    const MGA_AbilityCache = {
      categories: new Map(),
      timestamps: new Map(),
      normalizedNames: new Map(),
      lastTimestampUpdate: 0
    };

    // Clear timestamp cache every minute (timestamps change over time)
    setInterval(() => {
      MGA_AbilityCache.timestamps.clear();
      MGA_AbilityCache.lastTimestampUpdate = Date.now();
    }, 60000);

    // Comprehensive ability categorization logic based on Pet Ability Logs 4
    function categorizeAbility(abilityType) {
      const cleanType = (abilityType || '').toLowerCase();

      // üí´ XP Boost (for pet experience)
      if (cleanType.includes('xp') && cleanType.includes('boost')) {
        return 'xp-boost';
      }
      if (cleanType.includes('hatch') && cleanType.includes('xp')) {
        return 'xp-boost';
      }

      // üìà Crop Size Boost (for scaling crops)
      if (cleanType.includes('crop') && (cleanType.includes('size') || cleanType.includes('scale'))) {
        return 'crop-size-boost';
      }

      // üí∞ Selling (for selling crops/pets)
      if (cleanType.includes('sell') && cleanType.includes('boost')) {
        return 'selling';
      }
      if (cleanType.includes('refund')) {
        return 'selling';
      }

      // üåæ Harvesting (for harvesting crops)
      if (cleanType.includes('double') && cleanType.includes('harvest')) {
        return 'harvesting';
      }

      // üê¢ Growth Speed (plant and egg growth)
      if (cleanType.includes('growth') && cleanType.includes('boost')) {
        return 'growth-speed';
      }
      if (cleanType.includes('plant') && cleanType.includes('growth')) {
        return 'growth-speed';
      }
      if (cleanType.includes('egg') && cleanType.includes('growth')) {
        return 'growth-speed';
      }

      // üåà‚ú® Special Mutations (Rainbow/Gold conversion)
      if (cleanType.includes('rainbow') || cleanType.includes('gold')) {
        return 'special-mutations';
      }

      // üîß Other (passive abilities, pet management, etc.)
      return 'other';
    }

    function updateAbilityLogDisplay(context = document) {
      const abilityLogs = context.querySelector('#ability-logs');
      if (!abilityLogs) {
        debugLog('ABILITY_LOGS', 'No ability logs element found in context', {
          isDocument: context === document,
          className: context.className || 'unknown'
        });
        return;
      }

      // Preserve drag state if this is a content-only overlay being updated
      const isOverlay = context.classList?.contains('mga-overlay-content-only');
      const isDragInProgress = context.getAttribute?.('data-dragging') === 'true';
      if (isOverlay && isDragInProgress) {
        debugLog('ABILITY_LOGS', 'Skipping content update during drag operation', {
          overlayId: context.id
        });
        return;
      }

      const logs = MGA_getAllLogs(); // Show all logs including archived - user requested 100% persistence
      const filteredLogs = logs.filter(log => {
        return shouldLogAbility(log.abilityType, log.petName);
      });

      debugLog('ABILITY_LOGS', 'Updating ability log display', {
        totalLogs: logs.length,
        filteredLogs: filteredLogs.length,
        filterMode: UnifiedState.data.filterMode
      });

      // Diagnostic logging for FIX_VALIDATION
      if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
        console.log('[FIX_ABILITY_LOGS] Update called:', {
          totalLogs: logs.length,
          filteredLogs: filteredLogs.length,
          filterMode: UnifiedState.data.filterMode,
          elementFound: !!abilityLogs,
          contextType: context === document ? 'document' : 'overlay'
        });
      }

      const htmlParts = [];
      filteredLogs.forEach((log, index) => {
        const category = categorizeAbilityToFilterKey(log.abilityType);
        const categoryData = {
          xpBoost: { icon: 'üí´', color: '#4a9eff', label: 'XP Boost' },
          cropSizeBoost: { icon: 'üìà', color: '#10b981', label: 'Crop Size' },
          selling: { icon: 'üí∞', color: '#f59e0b', label: 'Selling' },
          harvesting: { icon: 'üåæ', color: '#84cc16', label: 'Harvesting' },
          growthSpeed: { icon: 'üê¢', color: '#06b6d4', label: 'Growth Speed' },
          specialMutations: { icon: 'üåà‚ú®', color: '#8b5cf6', label: 'Special' },
          other: { icon: 'üîß', color: '#6b7280', label: 'Other' }
        };

        const catData = categoryData[category] || categoryData.other;
        const formattedTime = formatTimestamp(log.timestamp);
        const isRecent = Date.now() - log.timestamp < 10000; // Less than 10 seconds ago
        const displayAbilityName = normalizeAbilityName(log.abilityType);

        htmlParts.push(`
                  <div class="mga-log-item ${isRecent ? 'mga-log-recent' : ''}" data-category="${category}" data-ability-type="${log.abilityType}" data-pet-name="${log.petName}" style="--category-color: ${catData.color}">
                      <div class="mga-log-header">
                          <span class="mga-log-icon">${catData.icon}</span>
                          <span class="mga-log-meta">
                              <span class="mga-log-pet" style="color: ${catData.color}; font-weight: 600;">${log.petName}</span>
                              <span class="mga-log-time">${formattedTime}</span>
                          </span>
                      </div>
                      <div class="mga-log-ability">${displayAbilityName}</div>
                      ${
                        log.data && Object.keys(log.data).length > 0
                          ? `<div class="mga-log-details">${formatLogData(log.data)}</div>`
                          : ''
                      }
                  </div>
              `);
      });

      // PERFORMANCE: Use DocumentFragment for batch DOM updates
      const fragment = targetDocument.createDocumentFragment();
      const tempContainer = targetDocument.createElement('div');

      if (htmlParts.length === 0) {
        const mode = UnifiedState.data.filterMode || 'categories';
        const modeText =
          mode === 'categories' ? 'category filters' : mode === 'byPet' ? 'pet filters' : 'custom filters';
        tempContainer.innerHTML = `<div class="mga-log-empty">
                  <div style="color: #888; text-align: center; padding: 20px;">
                      <div style="font-size: 24px; margin-bottom: 8px;">üìã</div>
                      <div>No abilities match the current ${modeText}</div>
                      <div style="font-size: 11px; margin-top: 4px; opacity: 0.7;">Try adjusting your filter settings</div>
                  </div>
              </div>`;
      } else {
        tempContainer.innerHTML = htmlParts.join('');
        // Auto-scroll to newest if there are new entries
        setTimeout(() => {
          if (abilityLogs.scrollHeight > abilityLogs.clientHeight) {
            abilityLogs.scrollTop = 0; // Scroll to top (newest entries)
          }
        }, 100);
      }

      // Move all children to fragment, then update DOM once
      while (tempContainer.firstChild) {
        fragment.appendChild(tempContainer.firstChild);
      }

      abilityLogs.innerHTML = '';
      abilityLogs.appendChild(fragment);

      // Add enhanced log styles if not already present
      if (!context.querySelector('#mga-log-styles')) {
        const logStyles = targetDocument.createElement('style');
        logStyles.id = 'mga-log-styles';
        logStyles.textContent = `
                  .mga-log-item {
                      margin: 4px 0;
                      padding: 8px;
                      border-radius: 4px;
                      background: rgba(255, 255, 255, 0.02);
                      border-left: 2px solid var(--category-color, #6b7280);
                      transition: all 0.2s ease;
                      font-size: 11px;
                      line-height: 1.3;
                  }

                  .mga-log-item:hover {
                      background: rgba(255, 255, 255, 0.05);
                      transform: translateX(2px);
                  }

                  .mga-log-recent {
                      background: rgba(74, 158, 255, 0.30);
                      border-color: #4a9eff;
                      box-shadow: 0 0 8px rgba(74, 158, 255, 0.3);
                      animation: mgaLogPulse 2s ease-out;
                  }

                  @keyframes mgaLogPulse {
                      0% { box-shadow: 0 0 8px rgba(74, 158, 255, 0.6); }
                      100% { box-shadow: 0 0 8px rgba(74, 158, 255, 0.3); }
                  }

                  .mga-log-header {
                      display: flex;
                      align-items: center;
                      gap: 6px;
                      margin-bottom: 2px;
                  }

                  .mga-log-icon {
                      font-size: 12px;
                  }

                  .mga-log-meta {
                      display: flex;
                      align-items: center;
                      gap: 8px;
                      flex: 1;
                  }

                  .mga-log-pet {
                      font-weight: 600;
                      font-size: 11px;
                  }

                  .mga-log-time {
                      font-size: 9px;
                      color: rgba(255, 255, 255, 0.6);
                      margin-left: auto;
                  }

                  .mga-log-ability {
                      color: rgba(255, 255, 255, 0.9);
                      font-size: 10px;
                      margin: 2px 0 0 18px;
                  }

                  .mga-log-details {
                      font-size: 9px;
                      color: rgba(255, 255, 255, 0.5);
                      margin: 2px 0 0 18px;
                      font-style: italic;
                  }

                  .mga-log-empty {
                      text-align: center;
                      padding: 20px;
                      color: #888;
                  }
              `;
        (context.head || context.querySelector('head') || targetDocument.head).appendChild(logStyles);
      }
    }

    function formatRelativeTime(timestamp) {
      const now = Date.now();
      const diff = now - timestamp;

      if (diff < 60000) {
        // Less than 1 minute
        const seconds = Math.floor(diff / 1000);
        return `${seconds}s ago`;
      } else if (diff < 3600000) {
        // Less than 1 hour
        const minutes = Math.floor(diff / 60000);
        return `${minutes}m ago`;
      } else if (diff < 86400000) {
        // Less than 1 day
        const hours = Math.floor(diff / 3600000);
        return `${hours}h ago`;
      } else {
        return new Date(timestamp).toLocaleDateString();
      }
    }

    function formatLogData(data) {
      if (!data || typeof data !== 'object') return '';

      const formatted = Object.entries(data)
        .filter(([key, value]) => value !== null && value !== undefined)
        .map(([key, value]) => `${key}: ${value}`)
        .join(', ');

      return formatted.length > 60 ? formatted.substring(0, 60) + '...' : formatted;
    }

    // Update ability logs across ALL overlays and contexts
    // OPTIMIZED: Track log count to skip unnecessary updates (declared earlier at top scope)
    lastLogCount = 0;

    function updateAllAbilityLogDisplays(force = false) {
      // OPTIMIZED: Skip if no new logs (unless forced by settings change)
      const currentLogCount = UnifiedState.data.petAbilityLogs?.length || 0;

      // Debug logging for ability logs
      if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
        console.log('[FIX_ABILITY_LOGS] Update called:', {
          force,
          currentLogCount,
          lastLogCount,
          willUpdate: force || currentLogCount !== lastLogCount,
          petAbilityLogsExists: !!UnifiedState.data.petAbilityLogs
        });
      }

      if (!force && currentLogCount === lastLogCount) {
        debugLog('ABILITY_LOGS', 'Skipping update - no new logs');
        return;
      }
      lastLogCount = currentLogCount;

      debugLog('ABILITY_LOGS', 'Updating ability logs across all contexts');

      // Update main document context
      updateAbilityLogDisplay(document);

      // OPTIMIZED: Only query DOM once and filter for visible overlays and widgets
      const allOverlays = targetDocument.querySelectorAll('.mga-overlay-content-only, .mga-overlay, .mgh-popout');
      allOverlays.forEach(overlay => {
        // Skip if hidden
        if (overlay.offsetParent === null) return;

        if (overlay.querySelector('#ability-logs')) {
          updateAbilityLogDisplay(overlay);
          debugLog('ABILITY_LOGS', 'Updated overlay/widget ability logs', {
            overlayId: overlay.id || overlay.className
          });
        }
      });

      // BUGFIX: Update separate window pop-outs in real-time
      UnifiedState.data.popouts.windows.forEach((windowRef, tabName) => {
        if (windowRef && !windowRef.closed && tabName === 'abilities') {
          try {
            // Method 1: Direct DOM manipulation (most reliable)
            const popoutContent = windowRef.document?.getElementById('popout-content');
            if (popoutContent) {
              // Get fresh content from main window
              const freshContent = getAbilitiesTabContent();
              popoutContent.innerHTML = freshContent;

              // Re-run handlers in the pop-out window context
              if (typeof setupAbilitiesTabHandlers === 'function') {
                setupAbilitiesTabHandlers.call(window, windowRef.document);
              }
              debugLog('ABILITY_LOGS', 'Updated pop-out via direct DOM manipulation');
            } else {
              debugLog('ABILITY_LOGS', 'Pop-out content element not found, trying fallback');

              // Fallback: Try to call the refresh function if it exists
              if (windowRef.refreshPopoutContent && typeof windowRef.refreshPopoutContent === 'function') {
                windowRef.refreshPopoutContent('abilities');
                debugLog('ABILITY_LOGS', 'Updated pop-out via refresh function');
              }
            }
          } catch (e) {
            debugLog('ABILITY_LOGS', 'Error updating separate window:', e.message);

            // Last resort: Force reload (disruptive but ensures fresh data)
            try {
              windowRef.location.reload();
              debugLog('ABILITY_LOGS', 'Forced pop-out refresh via reload');
            } catch (e2) {
              // Window is truly dead, clean up reference
              debugLog('ABILITY_LOGS', 'Window is dead, removing reference');
              UnifiedState.data.popouts.windows.delete(tabName);
            }
          }
        }
      });
    }

    // PERFORMANCE OPTIMIZATION: CSS-based filtering instead of DOM rebuild
    function updateLogVisibility(context = document) {
      const abilityLogs = context.querySelector('#ability-logs');
      if (!abilityLogs) return;

      const filterMode = UnifiedState.data.filterMode || 'categories';
      const logItems = abilityLogs.querySelectorAll('.mga-log-item');

      debugLog('ABILITY_LOGS', 'Updating log visibility via CSS', {
        filterMode,
        totalItems: logItems.length
      });

      logItems.forEach(item => {
        let shouldShow = false;

        if (filterMode === 'categories') {
          const category = item.dataset.category;
          shouldShow = UnifiedState.data.abilityFilters[category] || false;
        } else if (filterMode === 'byPet') {
          const petName = item.dataset.petName;
          shouldShow = UnifiedState.data.petFilters.selectedPets[petName] || false;
        } else if (filterMode === 'custom') {
          const abilityType = item.dataset.abilityType;
          shouldShow = UnifiedState.data.customAbilityFilters[abilityType] || false;
        }

        item.style.display = shouldShow ? '' : 'none';
      });
    }

    // Apply visibility update to all contexts
    function updateAllLogVisibility() {
      debugLog('ABILITY_LOGS', 'Updating log visibility across all contexts');

      updateLogVisibility(document);

      const allOverlays = targetDocument.querySelectorAll('.mga-overlay-content-only, .mga-overlay');
      allOverlays.forEach(overlay => {
        if (overlay.offsetParent === null) return;
        if (overlay.querySelector('#ability-logs')) {
          updateLogVisibility(overlay);
        }
      });
    }

    function addTestAbilities() {
      const testLogs = [
        // üí´ XP Boost
        { petName: 'Goat', abilityType: 'XP Boost I', timestamp: Date.now() - 1000 },
        { petName: 'Peacock', abilityType: 'XP Boost II', timestamp: Date.now() - 2000 },
        { petName: 'Pig', abilityType: 'Hatch XP Boost I', timestamp: Date.now() - 3000 },
        { petName: 'Goat', abilityType: 'Hatch XP Boost II', timestamp: Date.now() - 4000 },

        // üìà Crop Size Boost
        { petName: 'Bee', abilityType: 'Crop Size Boost I', timestamp: Date.now() - 5000 },
        { petName: 'Butterfly', abilityType: 'Crop Size Boost II', timestamp: Date.now() - 6000 },

        // üí∞ Selling
        { petName: 'Bunny', abilityType: 'Sell Boost I', timestamp: Date.now() - 7000 },
        { petName: 'Pig', abilityType: 'Sell Boost II', timestamp: Date.now() - 8000 },
        { petName: 'Squirrel', abilityType: 'Sell Boost III', timestamp: Date.now() - 9000 },
        { petName: 'Peacock', abilityType: 'Sell Boost IV', timestamp: Date.now() - 10000 },
        { petName: 'Capybara', abilityType: 'Crop Refund', timestamp: Date.now() - 11000 },
        { petName: 'Chicken', abilityType: 'Pet Refund I', timestamp: Date.now() - 12000 },

        // üåæ Harvesting
        { petName: 'Capybara', abilityType: 'Double Harvest', timestamp: Date.now() - 13000 },

        // üê¢ Growth Speed
        { petName: 'Cow', abilityType: 'Plant Growth Boost I', timestamp: Date.now() - 14000 },
        { petName: 'Turtle', abilityType: 'Plant Growth Boost II', timestamp: Date.now() - 15000 },
        { petName: 'Chicken', abilityType: 'Egg Growth Boost I', timestamp: Date.now() - 16000 },
        { petName: 'Turtle', abilityType: 'Egg Growth Boost II', timestamp: Date.now() - 17000 },

        // üåà‚ú® Special Mutations
        { petName: 'Test Pet', abilityType: 'Rainbow Granter', timestamp: Date.now() - 18000 },
        { petName: 'Test Pet', abilityType: 'Gold Granter', timestamp: Date.now() - 19000 },

        // üîß Other
        { petName: 'Snail', abilityType: 'Coin Finder I', timestamp: Date.now() - 20000 },
        { petName: 'Bunny', abilityType: 'Coin Finder II', timestamp: Date.now() - 21000 },
        { petName: 'Squirrel', abilityType: 'Coin Finder III', timestamp: Date.now() - 22000 },
        { petName: 'Worm', abilityType: 'Seed Finder I', timestamp: Date.now() - 23000 },
        { petName: 'Cow', abilityType: 'Seed Finder II', timestamp: Date.now() - 24000 },
        { petName: 'Butterfly', abilityType: 'Seed Finder III', timestamp: Date.now() - 25000 },
        { petName: 'Worm', abilityType: 'Crop Eater', timestamp: Date.now() - 26000 },
        { petName: 'Cow', abilityType: 'Hunger Boost I', timestamp: Date.now() - 27000 },
        { petName: 'Turtle', abilityType: 'Hunger Boost II', timestamp: Date.now() - 28000 },
        { petName: 'Pig', abilityType: 'Max Strength Boost I', timestamp: Date.now() - 29000 },
        { petName: 'Goat', abilityType: 'Max Strength Boost II', timestamp: Date.now() - 30000 }
      ];

      testLogs.forEach(log => {
        log.timeString = new Date(log.timestamp).toLocaleTimeString();
        UnifiedState.data.petAbilityLogs.unshift(log);
      });

      // Apply memory management to keep recent logs in memory, archive older ones
      UnifiedState.data.petAbilityLogs = MGA_manageLogMemory(UnifiedState.data.petAbilityLogs);

      // Use debounced save to reduce I/O operations
      // Only save if not in clear session
      const clearSession = localStorage.getItem('MGA_logs_clear_session');
      if (!clearSession || Date.now() - parseInt(clearSession, 10) > 86400000) {
        MGA_debouncedSave('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
      } else {
        logDebug('ABILITY-LOGS', '‚è∏Ô∏è Skipping save - clear session active');
      }
      productionLog('Added comprehensive test abilities covering all 7 categories!');
    }

    // PAL4 Filter System Functions
    function switchFilterMode(mode) {
      UnifiedState.data.filterMode = mode;
      MGA_saveJSON('MGA_filterMode', mode);

      // Update button states
      targetDocument.querySelectorAll('[id^="filter-mode-"]').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`filter-mode-${mode === 'byPet' ? 'bypet' : mode}`)?.classList.add('active');

      // Update description
      const descriptions = {
        categories: 'Filter by ability categories',
        byPet: 'Filter by pet species',
        custom: 'Filter by individual abilities'
      };
      const descEl = document.getElementById('filter-mode-description');
      if (descEl) descEl.textContent = descriptions[mode];

      // Show/hide appropriate filter sections
      document.getElementById('category-filters').style.display = mode === 'categories' ? 'grid' : 'none';
      document.getElementById('pet-filters').style.display = mode === 'byPet' ? 'block' : 'none';
      document.getElementById('custom-filters').style.display = mode === 'custom' ? 'block' : 'none';

      // Populate content for the selected mode
      populateFilterModeContent(mode);
      // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
      updateAllLogVisibility();
    }

    function populateFilterModeContent(mode) {
      if (mode === 'byPet') {
        populatePetSpeciesList();
      } else if (mode === 'custom') {
        populateIndividualAbilities();
      }
    }

    function populatePetSpeciesList() {
      const container = document.getElementById('pet-species-list');
      if (!container) return;

      const pets = getAllUniquePets();
      container.innerHTML = '';

      if (pets.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center;">No pet species found in logs</div>';
        return;
      }

      pets.forEach(pet => {
        const label = targetDocument.createElement('label');
        label.className = 'mga-checkbox-group';
        label.style.display = 'block';
        label.style.marginBottom = '4px';

        const checkbox = targetDocument.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'mga-checkbox';
        checkbox.checked = UnifiedState.data.petFilters.selectedPets[pet] || false;

        checkbox.addEventListener('change', e => {
          UnifiedState.data.petFilters.selectedPets[pet] = e.target.checked;
          MGA_saveJSON('MGA_petFilters', UnifiedState.data.petFilters);
          // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
          updateAllLogVisibility();
        });

        const span = targetDocument.createElement('span');
        span.className = 'mga-label';
        span.textContent = ` ${pet}`;

        label.appendChild(checkbox);
        label.appendChild(span);
        container.appendChild(label);
      });
    }

    function populateIndividualAbilities() {
      const container = document.getElementById('individual-abilities-list');
      if (!container) return;

      const abilities = getAllUniqueAbilities();
      container.innerHTML = '';

      if (abilities.length === 0) {
        container.innerHTML =
          '<div style="color: #888; text-align: center;">No individual abilities found in logs</div>';
        return;
      }

      abilities.forEach(ability => {
        const label = targetDocument.createElement('label');
        label.className = 'mga-checkbox-group';
        label.style.display = 'block';
        label.style.marginBottom = '4px';

        const checkbox = targetDocument.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'mga-checkbox';
        checkbox.checked = UnifiedState.data.customMode.selectedAbilities[ability] || false;

        checkbox.addEventListener('change', e => {
          UnifiedState.data.customMode.selectedAbilities[ability] = e.target.checked;
          MGA_saveJSON('MGA_customMode', UnifiedState.data.customMode);
          // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
          updateAllLogVisibility();
        });

        const span = targetDocument.createElement('span');
        span.className = 'mga-label';
        span.textContent = ` ${normalizeAbilityName(ability)}`;

        label.appendChild(checkbox);
        label.appendChild(span);
        container.appendChild(label);
      });
    }

    function getAllUniquePets() {
      const pets = new Set();
      UnifiedState.data.petAbilityLogs.forEach(log => {
        if (log.petName && log.petName !== 'Test Pet') {
          pets.add(log.petName);
        }
      });
      return Array.from(pets).sort();
    }

    function getAllUniqueAbilities() {
      const abilities = new Set();
      UnifiedState.data.petAbilityLogs.forEach(log => {
        if (log.abilityType) {
          abilities.add(log.abilityType);
        }
      });
      return Array.from(abilities).sort();
    }

    function selectAllFilters(mode) {
      if (mode === 'categories') {
        Object.keys(UnifiedState.data.abilityFilters).forEach(key => {
          UnifiedState.data.abilityFilters[key] = true;
          const checkbox = targetDocument.querySelector(`[data-filter="${key}"]`);
          if (checkbox) checkbox.checked = true;
        });
        MGA_saveJSON('MGA_abilityFilters', UnifiedState.data.abilityFilters);
      } else if (mode === 'byPet') {
        const pets = getAllUniquePets();
        pets.forEach(pet => {
          UnifiedState.data.petFilters.selectedPets[pet] = true;
        });
        MGA_saveJSON('MGA_petFilters', UnifiedState.data.petFilters);
        populatePetSpeciesList();
      } else if (mode === 'custom') {
        const abilities = getAllUniqueAbilities();
        abilities.forEach(ability => {
          UnifiedState.data.customMode.selectedAbilities[ability] = true;
        });
        MGA_saveJSON('MGA_customMode', UnifiedState.data.customMode);
        populateIndividualAbilities();
      }
      // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
      updateAllLogVisibility();
    }

    function selectNoneFilters(mode) {
      if (mode === 'categories') {
        Object.keys(UnifiedState.data.abilityFilters).forEach(key => {
          UnifiedState.data.abilityFilters[key] = false;
          const checkbox = targetDocument.querySelector(`[data-filter="${key}"]`);
          if (checkbox) checkbox.checked = false;
        });
        MGA_saveJSON('MGA_abilityFilters', UnifiedState.data.abilityFilters);
      } else if (mode === 'byPet') {
        UnifiedState.data.petFilters.selectedPets = {};
        MGA_saveJSON('MGA_petFilters', UnifiedState.data.petFilters);
        populatePetSpeciesList();
      } else if (mode === 'custom') {
        UnifiedState.data.customMode.selectedAbilities = {};
        MGA_saveJSON('MGA_customMode', UnifiedState.data.customMode);
        populateIndividualAbilities();
      }
      // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
      updateAllLogVisibility();
    }

    // Enhanced shouldLogAbility function matching PAL4 logic
    function shouldLogAbility(abilityType, petName = null) {
      // Filter out ProduceMutationBoost abilities - user doesn't want these logged
      if (abilityType && (abilityType.includes('ProduceMutationBoost') || abilityType.includes('PetMutationBoost'))) {
        return false;
      }

      const mode = UnifiedState.data.filterMode || 'categories';

      if (mode === 'custom') {
        return UnifiedState.data.customMode.selectedAbilities[abilityType] || false;
      }

      if (mode === 'byPet') {
        if (!petName) return false;
        return UnifiedState.data.petFilters.selectedPets[petName] || false;
      }

      // Categories mode - use existing categorizeAbility logic
      const category = categorizeAbilityToFilterKey(abilityType);
      return UnifiedState.data.abilityFilters[category] || false;
    }

    function categorizeAbilityToFilterKey(abilityType) {
      // PERFORMANCE: Check cache first
      if (MGA_AbilityCache.categories.has(abilityType)) {
        return MGA_AbilityCache.categories.get(abilityType);
      }

      const cleanType = (abilityType || '').toLowerCase();

      let category = 'other';
      if (cleanType.includes('xp') && cleanType.includes('boost')) category = 'xpBoost';
      else if (cleanType.includes('hatch') && cleanType.includes('xp')) category = 'xpBoost';
      else if (cleanType.includes('crop') && (cleanType.includes('size') || cleanType.includes('scale')))
        category = 'cropSizeBoost';
      else if (cleanType.includes('sell') && cleanType.includes('boost')) category = 'selling';
      else if (cleanType.includes('refund')) category = 'selling';
      else if (cleanType.includes('double') && cleanType.includes('harvest')) category = 'harvesting';
      else if (cleanType.includes('growth') && cleanType.includes('boost')) category = 'growthSpeed';
      else if (cleanType.includes('rainbow') || cleanType.includes('gold')) category = 'specialMutations';

      // PERFORMANCE: Cache result
      MGA_AbilityCache.categories.set(abilityType, category);

      return category;
    }

    function setupSeedsTabHandlers(context = document) {
      // Seed ID mapping for initialization
      const seedIdMap = {
        Carrot: 'Carrot',
        Strawberry: 'Strawberry',
        Aloe: 'Aloe',
        Blueberry: 'Blueberry',
        Apple: 'Apple',
        Tulip: 'OrangeTulip',
        Tomato: 'Tomato',
        Daffodil: 'Daffodil',
        Sunflower: 'Sunflower',
        Corn: 'Corn',
        Watermelon: 'Watermelon',
        Pumpkin: 'Pumpkin',
        Delphinium: 'Delphinium',
        Squash: 'Squash',
        Echeveria: 'Echeveria',
        Coconut: 'Coconut',
        Banana: 'Banana',
        Lily: 'Lily',
        BurrosTail: 'BurrosTail',
        Mushroom: 'Mushroom',
        Cactus: 'Cactus',
        Bamboo: 'Bamboo',
        Grape: 'Grape',
        Pepper: 'Pepper',
        Lemon: 'Lemon',
        PassionFruit: 'PassionFruit',
        DragonFruit: 'DragonFruit',
        Lychee: 'Lychee',
        Starweaver: 'Starweaver',
        Moonbinder: 'Moonbinder',
        Dawnbinder: 'Dawnbinder'
      };

      context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
        // Prevent duplicate event listeners
        if (checkbox.hasAttribute('data-handler-setup')) {
          return;
        }
        checkbox.setAttribute('data-handler-setup', 'true');

        // Initialize checkbox state based on saved seedsToDelete
        const seed = checkbox.dataset.seed;
        const internalId = seedIdMap[seed] || seed;
        if (UnifiedState.data.seedsToDelete.includes(internalId)) {
          checkbox.checked = true;
        }

        checkbox.addEventListener('change', e => {
          const seed = e.target.dataset.seed;

          // Prevent adding protected seeds to deletion list
          if (e.target.checked && ['Starweaver', 'Moonbinder', 'Dawnbinder', 'Sunflower'].includes(seed)) {
            e.target.checked = false;
            const seedType = seed === 'Sunflower' ? 'Divine' : 'Celestial';
            productionWarn(`‚ùå ${seed} is a protected ${seedType} seed and cannot be deleted!`);
            return;
          }

          // Map display name to internal ID for storage (using seedIdMap from function scope)
          const internalId = seedIdMap[seed] || seed;

          if (e.target.checked) {
            if (!UnifiedState.data.seedsToDelete.includes(internalId)) {
              UnifiedState.data.seedsToDelete.push(internalId);
            }
          } else {
            UnifiedState.data.seedsToDelete = UnifiedState.data.seedsToDelete.filter(s => s !== internalId);
          }

          // Use safe save for critical seed selection data
          const result = MGA_safeSave('MGA_seedsToDelete', UnifiedState.data.seedsToDelete, {
            description: `seed selection for "${seed}"`,
            criticalData: true,
            showUserAlert: true
          });

          if (result.success) {
            productionLog(`‚úÖ [SEED-SELECTION] Successfully saved seed selection change for "${seed}"`);
          } else {
            console.error(`‚ùå [SEED-SELECTION] Failed to save seed selection for "${seed}":`, result.error);
          }

          debugLog('BUTTON_INTERACTIONS', `Seed checkbox changed: ${seed}`, {
            checked: e.target.checked,
            seedsToDelete: UnifiedState.data.seedsToDelete
          });
        });
      });

      const autoDeleteCheckbox = context.querySelector('#auto-delete-checkbox');
      if (autoDeleteCheckbox && !autoDeleteCheckbox.hasAttribute('data-handler-setup')) {
        autoDeleteCheckbox.setAttribute('data-handler-setup', 'true');
        autoDeleteCheckbox.addEventListener('change', e => {
          if (e.target.checked) {
            // Confirmation dialog for enabling auto-delete
            const selectedSeedsText =
              UnifiedState.data.seedsToDelete.length > 0
                ? UnifiedState.data.seedsToDelete.join(', ')
                : 'No seeds currently selected';
            const confirmMessage = `‚ö†Ô∏è WARNING: Auto-Delete will IRREVERSIBLY delete seeds!\n\nSelected seeds for auto-deletion:\n${selectedSeedsText}\n\nAuto-delete will continuously remove these seed types from your inventory as soon as they appear. This action cannot be undone.\n\nAre you sure you want to enable Auto-Delete?`;

            if (!confirm(confirmMessage)) {
              e.target.checked = false; // Uncheck the box if user cancels
              return;
            }
          }
          UnifiedState.data.autoDeleteEnabled = e.target.checked;
          MGA_saveJSON('MGA_autoDeleteEnabled', e.target.checked);
          if (e.target.checked) {
            startAutoDelete();
          }
          debugLog('BUTTON_INTERACTIONS', `Auto-delete toggled: ${e.target.checked}`);
        });

        // Initialize checkbox state from saved settings
        autoDeleteCheckbox.checked = UnifiedState.data.autoDeleteEnabled;
        if (UnifiedState.data.autoDeleteEnabled) {
          startAutoDelete();
        }
      }

      const deleteSelectedBtn = context.querySelector('#delete-selected-btn');
      if (deleteSelectedBtn && !deleteSelectedBtn.hasAttribute('data-handler-setup')) {
        deleteSelectedBtn.setAttribute('data-handler-setup', 'true');
        deleteSelectedBtn.addEventListener('click', () => {
          deleteSelectedSeeds();
          debugLog('BUTTON_INTERACTIONS', 'Delete selected seeds button clicked', {
            seedsToDelete: UnifiedState.data.seedsToDelete
          });
        });
      }

      // Select All Seeds Button
      const selectAllBtn = context.querySelector('#select-all-seeds');
      if (selectAllBtn && !selectAllBtn.hasAttribute('data-handler-setup')) {
        selectAllBtn.setAttribute('data-handler-setup', 'true');
        selectAllBtn.addEventListener('click', () => {
          context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
            const seed = checkbox.dataset.seed;

            // Skip protected seeds
            if (['Starweaver', 'Moonbinder', 'Dawnbinder', 'Sunflower'].includes(seed)) {
              checkbox.checked = false;
              return;
            }

            checkbox.checked = true;
            // Map to internal ID for storage (using seedIdMap from function scope)
            const internalId = seedIdMap[seed] || seed;
            if (!UnifiedState.data.seedsToDelete.includes(internalId)) {
              UnifiedState.data.seedsToDelete.push(internalId);
            }
          });
          MGA_saveJSON('MGA_seedsToDelete', UnifiedState.data.seedsToDelete);
          debugLog('BUTTON_INTERACTIONS', 'Selected all seeds');
        });
      }

      // Select None Seeds Button
      const selectNoneBtn = context.querySelector('#select-none-seeds');
      if (selectNoneBtn && !selectNoneBtn.hasAttribute('data-handler-setup')) {
        selectNoneBtn.setAttribute('data-handler-setup', 'true');
        selectNoneBtn.addEventListener('click', () => {
          context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
            checkbox.checked = false;
          });
          UnifiedState.data.seedsToDelete = [];
          debugLog('BUTTON_INTERACTIONS', 'Deselected all seeds');
        });
      }

      // Select Common Seeds Button
      const selectCommonBtn = context.querySelector('#select-common');
      if (selectCommonBtn && !selectCommonBtn.hasAttribute('data-handler-setup')) {
        selectCommonBtn.setAttribute('data-handler-setup', 'true');
        selectCommonBtn.addEventListener('click', () => {
          const commonSeeds = ['Carrot', 'Strawberry', 'Aloe'];
          selectSeedsByList(context, commonSeeds);
          debugLog('BUTTON_INTERACTIONS', 'Selected common seeds');
        });
      }

      // Select Uncommon Seeds Button
      const selectUncommonBtn = context.querySelector('#select-uncommon');
      if (selectUncommonBtn && !selectUncommonBtn.hasAttribute('data-handler-setup')) {
        selectUncommonBtn.setAttribute('data-handler-setup', 'true');
        selectUncommonBtn.addEventListener('click', () => {
          const uncommonSeeds = ['Apple', 'Tulip', 'Tomato', 'Blueberry'];
          selectSeedsByList(context, uncommonSeeds);
          debugLog('BUTTON_INTERACTIONS', 'Selected uncommon seeds');
        });
      }

      // Select Rare+ Seeds Button
      const selectRareBtn = context.querySelector('#select-rare');
      if (selectRareBtn && !selectRareBtn.hasAttribute('data-handler-setup')) {
        selectRareBtn.setAttribute('data-handler-setup', 'true');
        selectRareBtn.addEventListener('click', () => {
          const rareSeeds = [
            'Daffodil',
            'Corn',
            'Watermelon',
            'Pumpkin',
            'Delphinium',
            'Squash',
            'Echeveria',
            'Coconut',
            'Banana',
            'Lily',
            'BurrosTail',
            'Mushroom',
            'Cactus',
            'Bamboo',
            'Grape',
            'Pepper',
            'Lemon',
            'PassionFruit',
            'DragonFruit',
            'Lychee'
          ];
          selectSeedsByList(context, rareSeeds);
          debugLog('BUTTON_INTERACTIONS', 'Selected rare+ seeds');
        });
      }

      // Calculate Value Button
      const calculateValueBtn = context.querySelector('#calculate-value-btn');
      if (calculateValueBtn && !calculateValueBtn.hasAttribute('data-handler-setup')) {
        calculateValueBtn.setAttribute('data-handler-setup', 'true');
        calculateValueBtn.addEventListener('click', () => {
          calculateSelectedSeedsValue(context);
          debugLog('BUTTON_INTERACTIONS', 'Calculate seeds value clicked');
        });
      }
    }

    // Helper function to select seeds by list
    function selectSeedsByList(context, seedList) {
      // First, clear all selections
      context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
        checkbox.checked = false;
      });
      UnifiedState.data.seedsToDelete = [];

      // Then select the specified seeds (excluding protected seeds)
      context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
        const seed = checkbox.dataset.seed;

        // Skip protected seeds
        if (['Starweaver', 'Moonbinder', 'Dawnbinder', 'Sunflower'].includes(seed)) {
          checkbox.checked = false;
          return;
        }

        if (seedList.includes(seed)) {
          checkbox.checked = true;
          UnifiedState.data.seedsToDelete.push(seed);
        }
      });
      MGA_saveJSON('MGA_seedsToDelete', UnifiedState.data.seedsToDelete);
    }

    // Helper function to calculate selected seeds value
    function calculateSelectedSeedsValue(context) {
      const seedValues = {
        // Common seeds
        Carrot: 10,
        Strawberry: 12,
        Aloe: 15,
        // Uncommon seeds
        Apple: 25,
        Tulip: 30,
        Tomato: 35,
        Blueberry: 40,
        // Rare seeds
        Daffodil: 75,
        Sunflower: 85,
        Corn: 80,
        Watermelon: 90,
        Pumpkin: 100,
        // Legendary seeds
        Echeveria: 200,
        Coconut: 250,
        Banana: 300,
        Lily: 350,
        BurrosTail: 400,
        // Mythical seeds
        Mushroom: 500,
        Cactus: 600,
        Bamboo: 750,
        Grape: 800,
        // Divine seeds
        Pepper: 1000,
        Lemon: 1200,
        PassionFruit: 1500,
        DragonFruit: 2000,
        Lychee: 2500,
        // Celestial seeds
        Starweaver: 5000,
        Moonbinder: 7500,
        Dawnbinder: 10000
      };

      if (!UnifiedState.atoms.inventory || !UnifiedState.atoms.inventory.items) {
        return;
      }

      let totalValue = 0;
      const inventory = UnifiedState.atoms.inventory.items;

      UnifiedState.data.seedsToDelete.forEach(seedType => {
        const inventoryItem = inventory.find(
          item =>
            item &&
            item.species &&
            (item.species === seedType || item.species === seedType.replace('Tulip', 'OrangeTulip'))
        );

        if (inventoryItem) {
          const quantity = inventoryItem.quantity || 0;
          const unitValue = seedValues[seedType] || 1;
          totalValue += quantity * unitValue;
        }
      });

      // Show the value display
      const valueDisplay = context.querySelector('#seed-value-display');
      const valueSpan = context.querySelector('#selected-seeds-value');

      if (valueDisplay && valueSpan) {
        valueSpan.textContent = totalValue.toLocaleString();
        valueDisplay.style.display = 'block';

        // Hide after 5 seconds
        setTimeout(() => {
          valueDisplay.style.display = 'none';
        }, 5000);
      }

      debugLog('BUTTON_INTERACTIONS', `Calculated seeds value: ${totalValue}`, {
        selectedSeeds: UnifiedState.data.seedsToDelete,
        totalValue
      });
    }

    // Track current hotkey recording state
    let currentlyRecordingHotkey = null;

    function startRecordingHotkey(key, buttonElement) {
      if (currentlyRecordingHotkey) return; // Already recording

      currentlyRecordingHotkey = key;
      const originalText = buttonElement.textContent;
      buttonElement.textContent = 'Press any key...';
      buttonElement.style.background = '#ff9900';

      // Add one-time key listener
      const recordHandler = e => {
        e.preventDefault();
        e.stopPropagation();

        // Skip modifier-only keys
        if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) return;

        // Allow ESC to cancel
        if (e.key === 'Escape') {
          stopRecordingHotkey(buttonElement, originalText);
          document.removeEventListener('keydown', recordHandler, true);
          return;
        }

        // Build key combination string
        let keyCombo = '';
        if (e.ctrlKey) keyCombo += 'ctrl+';
        if (e.altKey) keyCombo += 'alt+';
        if (e.shiftKey) keyCombo += 'shift+';

        // Handle special keys
        const keyName = e.key === ' ' ? 'space' : e.key.toLowerCase();
        keyCombo += keyName;

        // Check for conflicts
        const conflicts = [];
        Object.entries(UnifiedState.data.hotkeys.gameKeys).forEach(([k, config]) => {
          if (k !== key && config.custom && config.custom === keyCombo) {
            conflicts.push(config.name);
          }
        });

        if (conflicts.length > 0) {
          alert(`Key "${keyCombo}" is already assigned to: ${conflicts.join(', ')}`);
          stopRecordingHotkey(buttonElement, originalText);
          document.removeEventListener('keydown', recordHandler, true);
          return;
        }

        // Save the new key
        UnifiedState.data.hotkeys.gameKeys[key].custom = keyCombo;
        MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);

        stopRecordingHotkey(buttonElement, null);
        updateTabContent(); // Refresh display to show new key and reset button
        document.removeEventListener('keydown', recordHandler, true);

        productionLog(
          `üéÆ [HOTKEYS] Remapped ${key}: ${UnifiedState.data.hotkeys.gameKeys[key].original} ‚Üí ${keyCombo}`
        );
      };

      document.addEventListener('keydown', recordHandler, true);
    }

    function stopRecordingHotkey(buttonElement, originalText) {
      if (!currentlyRecordingHotkey) return;

      if (originalText) {
        buttonElement.textContent = originalText;
      }
      buttonElement.style.background = '';
      currentlyRecordingHotkey = null;
    }

    // MGTools hotkey recording (similar to game keys but for mgToolsKeys)
    function startRecordingHotkeyMGTools(key, buttonElement) {
      if (currentlyRecordingHotkey) return; // Already recording

      currentlyRecordingHotkey = key;
      const originalText = buttonElement.textContent;
      buttonElement.textContent = 'Press any key...';
      buttonElement.style.background = '#ff9900';

      // Add one-time key listener
      const recordHandler = e => {
        e.preventDefault();
        e.stopPropagation();

        // Skip modifier-only keys
        if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) return;

        // Allow ESC to cancel
        if (e.key === 'Escape') {
          stopRecordingHotkey(buttonElement, originalText);
          document.removeEventListener('keydown', recordHandler, true);
          return;
        }

        // Build key combination string
        let keyCombo = '';
        if (e.ctrlKey) keyCombo += 'ctrl+';
        if (e.altKey) keyCombo += 'alt+';
        if (e.shiftKey) keyCombo += 'shift+';

        // Handle special keys
        const keyName = e.key === ' ' ? 'space' : e.key.toLowerCase();
        keyCombo += keyName;

        // Check for conflicts in both gameKeys and mgToolsKeys
        const conflicts = [];
        Object.entries(UnifiedState.data.hotkeys.gameKeys).forEach(([k, config]) => {
          if (config.custom && config.custom === keyCombo) {
            conflicts.push(config.name);
          }
        });
        Object.entries(UnifiedState.data.hotkeys.mgToolsKeys).forEach(([k, config]) => {
          if (k !== key && config.custom && config.custom === keyCombo) {
            conflicts.push(config.name);
          }
        });

        if (conflicts.length > 0) {
          alert(`Key "${keyCombo}" is already assigned to: ${conflicts.join(', ')}`);
          stopRecordingHotkey(buttonElement, originalText);
          document.removeEventListener('keydown', recordHandler, true);
          return;
        }

        // Save the new key
        UnifiedState.data.hotkeys.mgToolsKeys[key].custom = keyCombo;
        MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);

        stopRecordingHotkey(buttonElement, null);
        updateTabContent(); // Refresh display to show new key and reset button
        document.removeEventListener('keydown', recordHandler, true);

        productionLog(`üéÆ [HOTKEYS] Set MGTools key ${key}: ${keyCombo}`);
      };

      document.addEventListener('keydown', recordHandler, true);
    }

    // ==================== HOTKEY INTERCEPTION & SIMULATION ====================

    function shouldBlockHotkey(event) {
      const active = document.activeElement;
      if (!active) return false;

      // Basic input elements
      const tagName = active.tagName?.toLowerCase();
      if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {
        return true;
      }

      // SPECIFIC CHECK for game's Chakra UI chat input
      if (active.classList?.contains('chakra-input')) {
        if (UnifiedState.data.settings?.debugMode) {
          console.log('[FIX_HOTKEYS] Blocking - Chakra UI input detected');
        }
        return true;
      }

      // Contenteditable
      if (active.contentEditable === 'true' || active.isContentEditable) {
        return true;
      }

      // ARIA role
      if (active.getAttribute('role') === 'textbox') {
        return true;
      }

      // Shadow DOM traversal
      if (event && event.composedPath) {
        const path = event.composedPath();
        for (const element of path) {
          if (!element.tagName) continue;

          const tag = element.tagName.toLowerCase();
          if (tag === 'input' || tag === 'textarea' || tag === 'select') {
            return true;
          }

          if (element.contentEditable === 'true' || element.getAttribute?.('role') === 'textbox') {
            return true;
          }
        }
      }

      // Discord chat detection
      const discordSelectors = [
        '.chat-input-container',
        '[class*="textArea"]',
        '[class*="slateTextArea"]',
        '.markup-input'
      ];

      for (const selector of discordSelectors) {
        try {
          const chatElement = document.querySelector(selector);
          if (chatElement && chatElement.contains(active)) {
            return true;
          }
        } catch {}
      }

      // In-game chat detection - check for common game chat patterns
      // Look for input fields that might be chat, even if not marked as such
      const activeClasses = active.className || '';
      const activeId = active.id || '';

      // Check if active element has chat-related classes or IDs
      const chatPatterns = ['chat', 'message', 'input', 'text', 'field', 'edit'];
      const hasChatPattern = chatPatterns.some(
        pattern => activeClasses.toLowerCase().includes(pattern) || activeId.toLowerCase().includes(pattern)
      );

      if (hasChatPattern && (tagName === 'div' || tagName === 'span' || active.isContentEditable)) {
        // Likely a chat input
        console.log('[FIX_HOTKEYS] Blocking hotkey - detected chat input:', {
          tag: tagName,
          classes: activeClasses,
          id: activeId,
          contentEditable: active.contentEditable
        });
        return true;
      }

      // Check parent elements for chat containers
      let parent = active.parentElement;
      let depth = 0;
      while (parent && depth < 5) {
        const parentClasses = parent.className || '';
        const parentId = parent.id || '';

        if (
          chatPatterns.some(
            pattern => parentClasses.toLowerCase().includes(pattern) || parentId.toLowerCase().includes(pattern)
          )
        ) {
          console.log('[FIX_HOTKEYS] Blocking hotkey - active element in chat container:', {
            parentTag: parent.tagName,
            parentClasses,
            parentId,
            activeTag: tagName
          });
          return true;
        }

        parent = parent.parentElement;
        depth++;
      }

      return false;
    }

    // Legacy alias for backwards compatibility
    function isTypingInInput() {
      return shouldBlockHotkey(null);
    }

    function parseKeyCombo(combo) {
      const parts = combo.toLowerCase().split('+');
      return {
        ctrl: parts.includes('ctrl'),
        alt: parts.includes('alt'),
        shift: parts.includes('shift'),
        key: parts[parts.length - 1] === 'space' ? ' ' : parts[parts.length - 1]
      };
    }

    function getProperKeyCode(key) {
      // Handle special keys
      const codeMap = {
        ' ': 'Space',
        space: 'Space',
        enter: 'Enter',
        tab: 'Tab',
        escape: 'Escape',
        backspace: 'Backspace',
        delete: 'Delete',
        arrowup: 'ArrowUp',
        arrowdown: 'ArrowDown',
        arrowleft: 'ArrowLeft',
        arrowright: 'ArrowRight',
        home: 'Home',
        end: 'End',
        pageup: 'PageUp',
        pagedown: 'PageDown',
        '-': 'Minus',
        '=': 'Equal',
        '[': 'BracketLeft',
        ']': 'BracketRight',
        ';': 'Semicolon',
        "'": 'Quote',
        ',': 'Comma',
        '.': 'Period',
        '/': 'Slash',
        '\\': 'Backslash',
        '`': 'Backquote'
      };

      const lowerKey = key.toLowerCase();

      // Check special keys map
      if (codeMap[lowerKey]) return codeMap[lowerKey];

      // F-keys
      if (/^f([1-9]|1[0-2])$/.test(lowerKey)) {
        return 'F' + lowerKey.substring(1);
      }

      // Numbers
      if (/^[0-9]$/.test(key)) {
        return 'Digit' + key;
      }

      // Letters
      if (/^[a-z]$/i.test(key)) {
        return 'Key' + key.toUpperCase();
      }

      // Fallback - just capitalize
      return key.charAt(0).toUpperCase() + key.slice(1);
    }

    function matchesKeyCombo(event, combo) {
      const parsed = parseKeyCombo(combo);
      const eventKey = event.key.toLowerCase();

      return (
        event.ctrlKey === parsed.ctrl &&
        event.altKey === parsed.alt &&
        event.shiftKey === parsed.shift &&
        (eventKey === parsed.key || (parsed.key === ' ' && eventKey === ' '))
      );
    }

    // Track which remapped keys are currently held down
    const heldRemappedKeys = new Map(); // customKey ‚Üí originalKey

    function simulateKeyDown(keyCombo) {
      const parsed = parseKeyCombo(keyCombo);

      // Create keydown event
      const downEvent = new KeyboardEvent('keydown', {
        key: parsed.key,
        code: getProperKeyCode(parsed.key),
        ctrlKey: parsed.ctrl,
        altKey: parsed.alt,
        shiftKey: parsed.shift,
        bubbles: true,
        cancelable: true,
        repeat: false // First press
      });

      // Dispatch to document (where game listens)
      document.dispatchEvent(downEvent);
    }

    function simulateKeyUp(keyCombo) {
      const parsed = parseKeyCombo(keyCombo);

      // Create keyup event
      const upEvent = new KeyboardEvent('keyup', {
        key: parsed.key,
        code: getProperKeyCode(parsed.key),
        ctrlKey: parsed.ctrl,
        altKey: parsed.alt,
        shiftKey: parsed.shift,
        bubbles: true,
        cancelable: true
      });

      document.dispatchEvent(upEvent);
    }

    function handleHotkeyPress(e) {
      // ESC key closes sidebar (always active, even if hotkeys disabled)
      if (e.key === 'Escape' && e.type === 'keydown') {
        const sidebar = document.getElementById('mgh-sidebar');
        if (sidebar && sidebar.classList.contains('open')) {
          sidebar.classList.remove('open');
          e.preventDefault();
          e.stopPropagation();
          return;
        }
      }

      // Skip if disabled, typing in input, recording a hotkey, or in room search/add room inputs
      const isRoomSearch = e.target && e.target.id === 'room-search-input';
      const isAddRoomInput = e.target && e.target.id === 'add-room-input';
      const isRoomSearchFocused = document.activeElement && document.activeElement.id === 'room-search-input';
      const isAddRoomFocused = document.activeElement && document.activeElement.id === 'add-room-input';

      // CRITICAL: Skip simulated events to prevent infinite loops
      // Simulated events have isTrusted: false, real user keypresses have isTrusted: true
      if (!e.isTrusted) return;

      // Block hotkeys when typing in inputs (enhanced with shadow DOM support)
      if (shouldBlockHotkey(e)) {
        // CRITICAL: Stop event from reaching game's hotkey handler
        // DO NOT use preventDefault() - that blocks typing in the input!
        // stopImmediatePropagation() prevents OTHER handlers from seeing this event
        // EXCEPTION: Allow Enter key to reach game's chat handler for message submission
        if (e.key !== 'Enter') {
          e.stopImmediatePropagation();
        }

        // Log when hotkey is blocked (helps diagnose chat detection issues)
        if (UnifiedState.data.settings?.debugMode) {
          const active = document.activeElement;
          console.log('[FIX_HOTKEYS] Hotkey blocked - typing detected:', {
            key: e.key,
            tag: active?.tagName,
            id: active?.id,
            classes: active?.className,
            contentEditable: active?.contentEditable
          });
        }
        return;
      }

      if (
        !UnifiedState.data.hotkeys.enabled ||
        currentlyRecordingHotkey ||
        isRoomSearch ||
        isRoomSearchFocused ||
        isAddRoomInput ||
        isAddRoomFocused
      )
        return;

      const isKeyDown = e.type === 'keydown';
      const isKeyUp = e.type === 'keyup';

      // STEP 1: Check each remapped key (custom ‚Üí original)
      for (const [action, config] of Object.entries(UnifiedState.data.hotkeys.gameKeys)) {
        if (config.custom) {
          // Check if pressed key matches custom mapping
          if (matchesKeyCombo(e, config.custom)) {
            e.preventDefault();
            e.stopPropagation();

            // Special handling for script functions (not game keys)
            if (action === 'toggleQuickShop') {
              if (isKeyDown && !e.repeat) {
                toggleShopWindows();
                if (UnifiedState.data.settings.debugMode) {
                  productionLog(`üéÆ [HOTKEYS] Triggered Quick Shop toggle via ${config.custom}`);
                }
              }
              return false;
            }

            if (isKeyDown) {
              // Only simulate keydown once per hold (ignore repeat events)
              if (!e.repeat) {
                simulateKeyDown(config.original);
                heldRemappedKeys.set(config.custom, config.original);
                if (UnifiedState.data.settings.debugMode) {
                  productionLog(`üéÆ [HOTKEYS] Remapped keydown ${config.custom} ‚Üí ${config.original} (${config.name})`);
                }
              }
            } else if (isKeyUp) {
              // Simulate keyup when released
              simulateKeyUp(config.original);
              heldRemappedKeys.delete(config.custom);
              if (UnifiedState.data.settings.debugMode) {
                productionLog(`üéÆ [HOTKEYS] Remapped keyup ${config.custom} ‚Üí ${config.original} (${config.name})`);
              }
            }
            return false;
          }
        }
      }

      // STEP 2: Check for non-remapped script functions using original key
      for (const [action, config] of Object.entries(UnifiedState.data.hotkeys.gameKeys)) {
        if (!config.custom && action === 'toggleQuickShop') {
          if (matchesKeyCombo(e, config.original)) {
            if (isKeyDown && !e.repeat) {
              e.preventDefault();
              e.stopPropagation();
              toggleShopWindows();
              if (UnifiedState.data.settings.debugMode) {
                productionLog(`üéÆ [HOTKEYS] Triggered Quick Shop toggle via ${config.original}`);
              }
              return false;
            }
          }
        }
      }

      // STEP 3: Suppress original keys that have been remapped
      for (const [action, config] of Object.entries(UnifiedState.data.hotkeys.gameKeys)) {
        if (config.custom && matchesKeyCombo(e, config.original)) {
          // Original key has been remapped, suppress it
          e.preventDefault();
          e.stopPropagation();
          if (UnifiedState.data.settings.debugMode && !e.repeat) {
            productionLog(
              `üö´ [HOTKEYS] Suppressed ${config.original} (remapped to ${config.custom} for ${config.name})`
            );
          }
          return false;
        }
      }
    }

    function handleHotkeyRelease(e) {
      // Just call the same handler - it checks e.type
      handleHotkeyPress(e);
    }

    // Install hotkey interceptor at highest priority
    function initializeHotkeySystem() {
      document.addEventListener('keydown', handleHotkeyPress, true);
      document.addEventListener('keyup', handleHotkeyRelease, true);
      productionLog('üéÆ [HOTKEYS] Key interception system installed (keydown + keyup)');
    }

    function setupHotkeysTabHandlers(context = document) {
      // Enable/disable checkbox
      const enableCheckbox = context.querySelector('#hotkeys-enabled');
      if (enableCheckbox) {
        enableCheckbox.addEventListener('change', e => {
          UnifiedState.data.hotkeys.enabled = e.target.checked;
          MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);
          productionLog(`üéÆ [HOTKEYS] ${e.target.checked ? 'Enabled' : 'Disabled'}`);
        });
      }

      // Hotkey buttons
      context.querySelectorAll('.hotkey-button').forEach(button => {
        button.addEventListener('click', function () {
          const key = this.dataset.key;
          startRecordingHotkey(key, this);
        });
      });

      // Reset buttons
      context.querySelectorAll('.hotkey-reset').forEach(button => {
        button.addEventListener('click', function () {
          const key = this.dataset.key;
          UnifiedState.data.hotkeys.gameKeys[key].custom = null;
          MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);
          updateTabContent(); // Refresh display
          productionLog(`üéÆ [HOTKEYS] Reset ${key} to default`);
        });
      });

      // MGTools hotkey buttons
      context.querySelectorAll('.hotkey-button-mgtools').forEach(button => {
        button.addEventListener('click', function () {
          const key = this.dataset.key;
          startRecordingHotkeyMGTools(key, this);
        });
      });

      // MGTools reset buttons
      context.querySelectorAll('.hotkey-reset-mgtools').forEach(button => {
        button.addEventListener('click', function () {
          const key = this.dataset.key;
          UnifiedState.data.hotkeys.mgToolsKeys[key].custom = null;
          MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);
          updateTabContent(); // Refresh display
          productionLog(`üéÆ [HOTKEYS] Reset MGTools key ${key} to default`);
        });
      });

      // Reset all button
      const resetAllBtn = context.querySelector('#hotkeys-reset-all');
      if (resetAllBtn) {
        resetAllBtn.addEventListener('click', () => {
          if (confirm('Reset all hotkeys to defaults?')) {
            Object.keys(UnifiedState.data.hotkeys.gameKeys).forEach(key => {
              UnifiedState.data.hotkeys.gameKeys[key].custom = null;
            });
            Object.keys(UnifiedState.data.hotkeys.mgToolsKeys).forEach(key => {
              UnifiedState.data.hotkeys.mgToolsKeys[key].custom = null;
            });
            MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);
            updateTabContent();
            productionLog('üéÆ [HOTKEYS] Reset all hotkeys to defaults');
          }
        });
      }

      // Export button
      const exportBtn = context.querySelector('#hotkeys-export');
      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          const exportData = {};
          Object.entries(UnifiedState.data.hotkeys.gameKeys).forEach(([key, config]) => {
            if (config.custom) {
              exportData[key] = config.custom;
            }
          });
          const json = JSON.stringify(exportData, null, 2);
          navigator.clipboard.writeText(json);
          alert('Hotkey configuration copied to clipboard!');
        });
      }
    }

    function setupProtectTabHandlers(context = document) {
      // Actual game crop species (from shop)
      const cropSpecies = [
        'Mushroom',
        'Cactus',
        'Bamboo',
        'Grape',
        'Pepper',
        'Lemon',
        'PassionFruit',
        'DragonFruit',
        'Lychee',
        'Sunflower',
        'Starweaver',
        'DawnCelestial',
        'MoonCelestial'
      ];
      const cropMutations = [
        'Rainbow',
        'Frozen',
        'Wet',
        'Chilled',
        'Gold',
        'Dawnlit',
        'Amberlit',
        'Dawnbound',
        'Amberbound',
        'Lock All Mutations',
        'Lock Only Non-Mutated'
      ];

      // Add new setting for frozen exception
      if (!UnifiedState.data.protectionSettings) {
        UnifiedState.data.protectionSettings = {
          allowFrozenPickup: false // Allow pickup of protected crops when frozen
        };
      }

      // Initialize locked crops if not exists
      if (!UnifiedState.data.lockedCrops) {
        UnifiedState.data.lockedCrops = { species: [], mutations: [] };
      }
      if (!UnifiedState.data.sellBlockThreshold) {
        UnifiedState.data.sellBlockThreshold = 1.0;
      }
      // Initialize locked decor if not exists
      if (!UnifiedState.data.lockedDecor) {
        UnifiedState.data.lockedDecor = [];
      }
      // Initialize locked pet abilities if not exists
      if (!UnifiedState.data.lockedPetAbilities) {
        UnifiedState.data.lockedPetAbilities = [];
      }

      const lockedCrops = UnifiedState.data.lockedCrops;

      // Generate species checkboxes
      const speciesList = context.querySelector('#protect-species-list');
      if (speciesList) {
        speciesList.innerHTML = cropSpecies
          .map(
            species => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-species-checkbox" value="${species}"
                          ${lockedCrops.species?.includes(species) ? 'checked' : ''}
                          style="cursor: pointer;">
                      <span style="font-size: 12px;">${species}</span>
                  </label>
              `
          )
          .join('');
      }

      // Generate mutation checkboxes
      const mutationsList = context.querySelector('#protect-mutations-list');
      if (mutationsList) {
        mutationsList.innerHTML = cropMutations
          .map(
            mutation => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-mutation-checkbox" value="${mutation}"
                          ${lockedCrops.mutations?.includes(mutation) ? 'checked' : ''}
                          style="cursor: pointer;">
                      <span style="font-size: 12px;">${mutation}</span>
                  </label>
              `
          )
          .join('');
      }

      // Generate pet ability checkboxes
      const petAbilities = ['Rainbow Granter', 'Gold Granter'];
      const petAbilitiesList = context.querySelector('#protect-pet-abilities-list');
      if (petAbilitiesList) {
        petAbilitiesList.innerHTML = petAbilities
          .map(
            ability => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-pet-ability-checkbox" value="${ability}"
                          ${UnifiedState.data.lockedPetAbilities?.includes(ability) ? 'checked' : ''}
                          style="cursor: pointer;">
                      <span style="font-size: 12px;">${ability}</span>
                  </label>
              `
          )
          .join('');
      }

      // Generate decor checkboxes
      const decorList = context.querySelector('#protect-decor-list');
      if (decorList) {
        decorList.innerHTML = DECOR_ITEMS.map(
          decor => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-decor-checkbox" value="${decor.id}"
                          ${UnifiedState.data.lockedDecor?.includes(decor.id) ? 'checked' : ''}
                          style="cursor: pointer;">
                      <span style="font-size: 11px;">${decor.name}</span>
                  </label>
              `
        ).join('');
      }

      // Diagnostic logging
      const speciesCheckboxes = context.querySelectorAll('.protect-species-checkbox');
      const mutationCheckboxes = context.querySelectorAll('.protect-mutation-checkbox');
      console.log(
        `‚úÖ [Protect] Found ${speciesCheckboxes.length} species checkboxes, ${mutationCheckboxes.length} mutation checkboxes`
      );

      // Handle species checkbox changes
      context.querySelectorAll('.protect-species-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          console.log('[Protect] üîî Species checkbox changed!', e.target.value, 'checked:', e.target.checked);
          const species = e.target.value;
          if (e.target.checked) {
            if (!lockedCrops.species.includes(species)) {
              lockedCrops.species.push(species);
            }
          } else {
            lockedCrops.species = lockedCrops.species.filter(s => s !== species);
          }
          console.log('[Protect] Saving species change:', species, e.target.checked);
          MGA_saveJSON('MGA_data', UnifiedState.data);
          console.log('[Protect] Save completed');
          updateProtectStatus(context);
          applyHarvestRule();
        });
      });

      // Handle mutation checkbox changes
      context.querySelectorAll('.protect-mutation-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          console.log('[Protect] üîî Mutation checkbox changed!', e.target.value, 'checked:', e.target.checked);
          const mutation = e.target.value;

          // Special handling for "Lock All Mutations" - it's a "select all" toggle
          if (mutation === 'Lock All Mutations') {
            const allMutationCheckboxes = context.querySelectorAll('.protect-mutation-checkbox');
            const otherMutations = [
              'Rainbow',
              'Frozen',
              'Wet',
              'Chilled',
              'Gold',
              'Dawnlit',
              'Amberlit',
              'Dawnbound',
              'Amberbound'
            ];

            if (e.target.checked) {
              // Check all other mutation checkboxes
              allMutationCheckboxes.forEach(cb => {
                if (cb.value !== 'Lock All Mutations' && cb.value !== 'Lock Only Non-Mutated') {
                  cb.checked = true;
                  if (!lockedCrops.mutations.includes(cb.value)) {
                    lockedCrops.mutations.push(cb.value);
                  }
                }
              });
            } else {
              // Uncheck all other mutation checkboxes
              allMutationCheckboxes.forEach(cb => {
                if (cb.value !== 'Lock All Mutations' && cb.value !== 'Lock Only Non-Mutated') {
                  cb.checked = false;
                }
              });
              lockedCrops.mutations = lockedCrops.mutations.filter(m => m === 'Lock Only Non-Mutated');
            }
          } else if (mutation === 'Lock Only Non-Mutated') {
            // Special handling for "Lock Only Non-Mutated" - locks crops with 0 mutations
            if (e.target.checked) {
              if (!lockedCrops.mutations.includes(mutation)) {
                lockedCrops.mutations.push(mutation);
              }
            } else {
              lockedCrops.mutations = lockedCrops.mutations.filter(m => m !== mutation);
            }
          } else {
            // Regular mutation checkbox
            if (e.target.checked) {
              if (!lockedCrops.mutations.includes(mutation)) {
                lockedCrops.mutations.push(mutation);
              }
            } else {
              lockedCrops.mutations = lockedCrops.mutations.filter(m => m !== mutation);
              // Uncheck "Lock All Mutations" if any individual mutation is unchecked
              const lockAllCheckbox = context.querySelector('.protect-mutation-checkbox[value="Lock All Mutations"]');
              if (lockAllCheckbox) {
                lockAllCheckbox.checked = false;
              }
            }
          }

          console.log('[Protect] Saving mutation change:', mutation, e.target.checked);
          MGA_saveJSON('MGA_data', UnifiedState.data);
          console.log('[Protect] Save completed');
          updateProtectStatus(context);
          applyHarvestRule();
        });
      });

      // Handle pet ability checkbox changes
      context.querySelectorAll('.protect-pet-ability-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          const ability = e.target.value;
          if (e.target.checked) {
            if (!UnifiedState.data.lockedPetAbilities.includes(ability)) {
              UnifiedState.data.lockedPetAbilities.push(ability);
            }
          } else {
            UnifiedState.data.lockedPetAbilities = UnifiedState.data.lockedPetAbilities.filter(a => a !== ability);
          }
          MGA_saveJSON('MGA_data', UnifiedState.data);
          updateProtectStatus(context);
        });
      });

      // Handle decor checkbox changes
      context.querySelectorAll('.protect-decor-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          const decorId = e.target.value;
          if (e.target.checked) {
            if (!UnifiedState.data.lockedDecor.includes(decorId)) {
              UnifiedState.data.lockedDecor.push(decorId);
            }
          } else {
            UnifiedState.data.lockedDecor = UnifiedState.data.lockedDecor.filter(d => d !== decorId);
          }
          MGA_saveJSON('MGA_data', UnifiedState.data);
          updateProtectStatus(context);
        });
      });

      // Clear all button
      const clearButton = context.querySelector('#protect-clear-all');
      if (clearButton) {
        clearButton.addEventListener('click', () => {
          lockedCrops.species = [];
          lockedCrops.mutations = [];
          UnifiedState.data.lockedDecor = [];
          UnifiedState.data.lockedPetAbilities = [];
          MGA_saveJSON('MGA_data', UnifiedState.data);

          // Uncheck all checkboxes
          context
            .querySelectorAll(
              '.protect-species-checkbox, .protect-mutation-checkbox, .protect-decor-checkbox, .protect-pet-ability-checkbox'
            )
            .forEach(cb => {
              cb.checked = false;
            });

          updateProtectStatus(context);
          applyHarvestRule();
        });
      }

      // Sell threshold slider
      const thresholdSlider = context.querySelector('#protect-sell-threshold');
      const thresholdValue = context.querySelector('#protect-sell-threshold-value');
      if (thresholdSlider) {
        thresholdSlider.addEventListener('input', e => {
          const value = parseFloat(e.target.value);
          UnifiedState.data.sellBlockThreshold = value;
          if (thresholdValue) {
            thresholdValue.textContent = `${value.toFixed(2)}x (${((value - 1) * 100).toFixed(0)}%)`;
          }
          MGA_saveJSON('MGA_data', UnifiedState.data);
          applySellBlockThreshold();
        });
      }

      // Add handler for frozen pickup checkbox
      console.log('[Protect-Debug] üîç Looking for #allow-frozen-pickup checkbox in context:', context);
      const frozenCheckbox = context.querySelector('#allow-frozen-pickup');
      console.log('[Protect-Debug] üìã Frozen checkbox found?', !!frozenCheckbox, frozenCheckbox);

      if (frozenCheckbox) {
        console.log('[Protect-Debug] ‚úÖ Attaching change event handler to frozen checkbox');
        frozenCheckbox.addEventListener('change', e => {
          console.log('[Protect-Debug] üîî FROZEN CHECKBOX CHANGED!', e.target.checked);
          if (!UnifiedState.data.protectionSettings) {
            UnifiedState.data.protectionSettings = {};
          }
          UnifiedState.data.protectionSettings.allowFrozenPickup = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`‚ùÑÔ∏è [PROTECTION] Frozen exception: ${e.target.checked ? 'enabled' : 'disabled'}`);
          applyHarvestRule();
        });
        console.log('[Protect-Debug] ‚úÖ Frozen checkbox handler attached successfully');
      } else {
        console.warn('[Protect-Debug] ‚ö†Ô∏è Frozen checkbox NOT FOUND in context!');
      }

      // Initial status update
      updateProtectStatus(context);
      applyHarvestRule();
      applySellBlockThreshold();
    }

    function updateProtectStatus(context = document) {
      const statusDisplay = context.querySelector('#protect-status-display');
      if (!statusDisplay) return;

      const lockedCrops = UnifiedState.data.lockedCrops || { species: [], mutations: [] };
      const lockedDecor = UnifiedState.data.lockedDecor || [];
      const lockedPetAbilities = UnifiedState.data.lockedPetAbilities || [];
      const hasLocks =
        lockedCrops.species.length > 0 ||
        lockedCrops.mutations.length > 0 ||
        lockedDecor.length > 0 ||
        lockedPetAbilities.length > 0;

      if (!hasLocks) {
        statusDisplay.innerHTML = '<div style="color: #888;">No protections are currently active.</div>';
        return;
      }

      let html = '';
      if (lockedCrops.species.length > 0) {
        html += `<div style="margin-bottom: 8px;"><strong>üîí Locked Crop Species:</strong> ${lockedCrops.species.join(', ')}</div>`;
      }
      if (lockedCrops.mutations.length > 0) {
        html += `<div style="margin-bottom: 8px;"><strong>üîí Locked Mutations:</strong> ${lockedCrops.mutations.join(', ')}</div>`;
      }
      if (lockedPetAbilities.length > 0) {
        html += `<div style="margin-bottom: 8px;"><strong>üêæ Locked Pet Abilities:</strong> ${lockedPetAbilities.join(', ')}</div>`;
      }
      if (lockedDecor.length > 0) {
        const decorNames = lockedDecor
          .map(id => {
            const decor = DECOR_ITEMS.find(d => d.id === id);
            return decor ? decor.name : id;
          })
          .join(', ');
        html += `<div><strong>üèõÔ∏è Locked Decor:</strong> ${decorNames}</div>`;
      }

      statusDisplay.innerHTML = html;
    }

    // ==================== HARVEST & SELL PROTECTION ====================
    function applyHarvestRule() {
      targetWindow.currentHarvestRule = ({ species, mutations } = {}) => {
        // CRITICAL FIX: Read fresh locked crops from UnifiedState each time harvest is attempted
        // This ensures unlocking crops takes effect immediately without requiring page refresh
        const freshLockedCrops = UnifiedState.data.lockedCrops || { species: [], mutations: [] };
        let mutationsLocal = mutations;
        mutationsLocal = Array.isArray(mutationsLocal) ? mutationsLocal : [];

        // Check if crop is frozen
        const isFrozen = mutationsLocal.includes('Frozen');
        const allowFrozenPickup = UnifiedState.data.protectionSettings?.allowFrozenPickup || false;

        // If species is locked, check for frozen exception
        if (freshLockedCrops.species && freshLockedCrops.species.includes(species)) {
          // If frozen exception is enabled and crop is frozen, allow harvest
          if (isFrozen && allowFrozenPickup) {
            return true;
          }
          return false;
        }

        // Check for "Lock Only Non-Mutated" - locks crops with 0 mutations
        if (freshLockedCrops.mutations && freshLockedCrops.mutations.includes('Lock Only Non-Mutated')) {
          if (mutationsLocal.length === 0) {
            return false; // Block harvest if crop has no mutations
          }
        }

        // If any locked mutation is present, check for frozen exception
        if (freshLockedCrops.mutations && freshLockedCrops.mutations.length > 0) {
          const regularMutations = freshLockedCrops.mutations.filter(
            m => m !== 'Lock All Mutations' && m !== 'Lock Only Non-Mutated'
          );
          const hasLockedMutation = regularMutations.some(m => mutationsLocal.includes(m));
          if (hasLockedMutation) {
            // If frozen exception is enabled and crop is frozen, allow harvest
            if (isFrozen && allowFrozenPickup) {
              return true;
            }
            return false;
          }
        }

        return true;
      };
    }

    function applySellBlockThreshold() {
      targetWindow.sellBlockThreshold = UnifiedState.data.sellBlockThreshold || 1.0;
      console.log(`‚úÖ Sell block threshold set to ${targetWindow.sellBlockThreshold}x`);
    }

    // Track RoomConnection retry attempts
    let roomConnectionRetries = 0;
    const MAX_ROOM_CONNECTION_RETRIES = 10;

    function initializeProtectionHooks() {
      // Note: friendBonus and myGarden atoms are already hooked in initializeAtoms()
      // which sets both UnifiedState.atoms and targetWindow values

      // Hook sendMessage to intercept harvest and sell commands
      setTimeout(() => {
        if (!targetWindow.MagicCircle_RoomConnection) {
          if (roomConnectionRetries < MAX_ROOM_CONNECTION_RETRIES) {
            roomConnectionRetries++;
            console.warn(`‚è≥ Waiting for RoomConnection (${roomConnectionRetries}/${MAX_ROOM_CONNECTION_RETRIES})...`);
            setTimeout(initializeProtectionHooks, 1000);
            return;
          } else {
            console.warn('‚ö†Ô∏è RoomConnection not found after max retries - continuing without protection hooks');
            // Continue without it - non-critical feature
            return;
          }
        }

        // Reset counter on success
        roomConnectionRetries = 0;
        console.log('‚úÖ MagicCircle_RoomConnection found - initializing protection hooks');

        const originalSendMessage = targetWindow.MagicCircle_RoomConnection.sendMessage.bind(
          targetWindow.MagicCircle_RoomConnection
        );

        // Wrap sendMessage to intercept messages for protection and tracking
        targetWindow.MagicCircle_RoomConnection.sendMessage = function (message, ...rest) {
          try {
            if (!message || typeof message.type !== 'string') {
              return originalSendMessage(message, ...rest);
            }

            const friendBonus = targetWindow.friendBonus ?? 1.5;
            const msgType = message.type;
            const isSellMessage = msgType === 'SellAllCrops'; // Only check crops - friend bonus doesn't work for pets

            // Detect in-game shop purchases
            if (msgType === 'PurchaseSeed' && message.species) {
              if (typeof trackLocalPurchase === 'function') {
                trackLocalPurchase(message.species, 'seed', 1);
              }
            } else if (msgType === 'PurchaseEgg' && message.eggId) {
              if (typeof trackLocalPurchase === 'function') {
                trackLocalPurchase(message.eggId, 'egg', 1);
              }
            } else if (msgType === 'PurchaseTool' && message.toolId) {
              if (UnifiedState.data.settings?.debugMode) {
                console.log(`üîß [PURCHASE-INTERCEPT] Tool Purchase Detected!`, {
                  toolId: message.toolId,
                  toolIdType: typeof message.toolId,
                  fullMessage: JSON.stringify(message)
                });
              }
              if (typeof trackLocalPurchase === 'function') {
                trackLocalPurchase(message.toolId, 'tool', 1);
                if (UnifiedState.data.settings?.debugMode) {
                  console.log(`üîß [PURCHASE-INTERCEPT] Called trackLocalPurchase with: "${message.toolId}"`);
                }
              } else {
                console.error(`‚ùå [PURCHASE-INTERCEPT] trackLocalPurchase function not available!`);
              }
            }

            // Check sell blocking
            if (isSellMessage && friendBonus < targetWindow.sellBlockThreshold) {
              console.warn(
                `[SellBlock] Blocked ${msgType} (friendBonus=${friendBonus} < ${targetWindow.sellBlockThreshold})`
              );
              return;
            }

            // Check harvest blocking
            if (msgType === 'HarvestCrop') {
              const tile = targetWindow.myGarden?.garden?.tileObjects?.[message.slot];
              const slotData = tile?.slots?.[message.slotsIndex];

              console.log(`[HarvestCheck] Attempting harvest: slot=${message.slot}, index=${message.slotsIndex}`);
              console.log(`[HarvestCheck] Tile data:`, tile);
              console.log(`[HarvestCheck] Slot data:`, slotData);

              if (slotData) {
                const species = slotData.species;
                const slotMutations = slotData.mutations || [];

                console.log(`[HarvestCheck] Species: ${species}, Mutations:`, slotMutations);
                console.log(`[HarvestCheck] currentHarvestRule exists:`, !!targetWindow.currentHarvestRule);

                if (
                  targetWindow.currentHarvestRule &&
                  !targetWindow.currentHarvestRule({ species, mutations: slotMutations })
                ) {
                  console.log(`üîí BLOCKED HarvestCrop: ${species} with mutations [${slotMutations.join(', ')}]`);
                  return;
                }
                console.log(`‚úÖ ALLOWED HarvestCrop: ${species} with mutations [${slotMutations.join(', ')}]`);

                // DIAGNOSTIC: Log when debug mode is enabled
                if (UnifiedState.data.settings?.debugMode) {
                  console.log('[FIX_HARVEST] Harvest handler called for:', species, 'Will attempt sync in 100ms...');
                }

                // Sync slot index after harvest - works for both single and multi-harvest crops
                // For single-harvest: game doesn't advance slot, sync returns null (no change)
                // For multi-harvest: game advances slot, sync updates MGTools to match
                const preHarvestIndex = window._mgtools_currentSlotIndex || 0;

                // Use polyfill from multi-harvest helpers
                // eslint-disable-next-line no-undef
                const qmt = typeof queueMicrotask === 'function' ? queueMicrotask : fn => Promise.resolve().then(fn);

                // Wait for game to update atoms after harvest
                qmt(() => {
                  setTimeout(() => {
                    try {
                      // Use globally exposed sync function
                      if (!window.syncSlotIndexFromGame) {
                        if (UnifiedState.data.settings?.debugMode) {
                          console.error('[FIX_HARVEST] ERROR: syncSlotIndexFromGame not found on window!');
                        }
                        return;
                      }

                      const newIndex = window.syncSlotIndexFromGame();

                      // Log slot sync when debug mode is enabled
                      if (UnifiedState.data.settings?.debugMode) {
                        console.log('[FIX_HARVEST] Post-harvest slot sync:', {
                          species,
                          preHarvest: preHarvestIndex,
                          postHarvest: newIndex !== null ? newIndex : preHarvestIndex,
                          slotAdvanced: newIndex !== null,
                          isMultiHarvest: newIndex !== null,
                          note:
                            newIndex === null
                              ? 'Single-harvest crop (expected - no slot advance)'
                              : 'Multi-harvest detected - slot advanced'
                        });
                      }

                      // Force refresh the value display after slot sync
                      if (typeof insertTurtleEstimate === 'function') {
                        requestAnimationFrame(() => {
                          insertTurtleEstimate();
                          if (UnifiedState.data.settings?.debugMode) {
                            console.log('[FIX_HARVEST] Refreshed value display');
                          }
                        });
                      }
                    } catch (error) {
                      console.error('[FIX_HARVEST] Sync error:', error);
                    }
                  }, 100); // Small delay to let game update atom
                });
              } else {
                console.warn(`[HarvestCheck] No slot data found for slot ${message.slot}, index ${message.slotsIndex}`);
              }
            }

            // Check pet sell blocking by ability (using mutation-based detection)
            if (msgType.toLowerCase().includes('pet') && msgType.toLowerCase().includes('sell')) {
              const lockedAbilities = UnifiedState.data.lockedPetAbilities || [];
              const petId = message.itemId || message.petId;

              if (UnifiedState.data.settings?.debugMode) {
                console.log(`üêæ [PetSellDebug] Message type: ${msgType}`, message);
                console.log(`üêæ [PetSellDebug] Locked abilities:`, lockedAbilities);
              }

              if (lockedAbilities.length > 0 && petId) {
                // Find the pet being sold
                let pet = null;

                // Check active pets
                if (UnifiedState.atoms.activePets) {
                  pet = UnifiedState.atoms.activePets.find(p => p.id === petId);
                }

                // Check inventory if not found in active pets
                if (!pet && UnifiedState.atoms.inventory?.items) {
                  pet = UnifiedState.atoms.inventory.items.find(item => item.id === petId && item.itemType === 'Pet');
                }

                if (UnifiedState.data.settings?.debugMode) {
                  console.log(`üêæ [PetSellDebug] Found pet:`, pet);
                }

                if (pet) {
                  // BETTER APPROACH: Check pet mutations instead of petAbility atom
                  // Gold/Rainbow mutations are ALWAYS present, unlike ability data which may not be populated
                  const petMutations = pet.mutations || [];

                  if (UnifiedState.data.settings?.debugMode) {
                    console.log(`üêæ [PetSellDebug] Pet mutations:`, petMutations);

                    // Check petAbility atom as backup
                    let abilityFromAtom = null;
                    if (UnifiedState.atoms.petAbility && UnifiedState.atoms.petAbility[petId]) {
                      const abilityData = UnifiedState.atoms.petAbility[petId];
                      abilityFromAtom = abilityData.lastAbilityTrigger?.abilityId;
                      console.log(`üêæ [PetSellDebug] Pet ability from atom:`, abilityFromAtom);
                    }
                  }

                  // Check if pet has Gold or Rainbow mutation
                  const hasGoldMutation = petMutations.includes('Gold');
                  const hasRainbowMutation = petMutations.includes('Rainbow');

                  if (UnifiedState.data.settings?.debugMode) {
                    console.log(
                      `üêæ [PetSellDebug] Has Gold mutation: ${hasGoldMutation}, Has Rainbow mutation: ${hasRainbowMutation}`
                    );
                  }

                  // Block if mutation matches locked ability
                  const isGoldGranterLocked = lockedAbilities.includes('Gold Granter');
                  const isRainbowGranterLocked = lockedAbilities.includes('Rainbow Granter');

                  const shouldBlockGold = hasGoldMutation && isGoldGranterLocked;
                  const shouldBlockRainbow = hasRainbowMutation && isRainbowGranterLocked;

                  if (UnifiedState.data.settings?.debugMode) {
                    console.log(
                      `üêæ [PetSellDebug] Should block gold: ${shouldBlockGold}, Should block rainbow: ${shouldBlockRainbow}`
                    );
                  }

                  if (shouldBlockGold || shouldBlockRainbow) {
                    const blockedType = shouldBlockGold ? 'Gold' : 'Rainbow';
                    console.warn(
                      `üêæ [PetLock] ‚ùå BLOCKED selling ${blockedType} pet (${blockedType} Granter is locked)`
                    );
                    return; // Block the sale
                  } else if (UnifiedState.data.settings?.debugMode) {
                    console.log(`üêæ [PetSellDebug] ‚úÖ Pet mutations not locked, allowing sale`);
                  }
                } else if (UnifiedState.data.settings?.debugMode) {
                  console.log(`üêæ [PetSellDebug] ‚ö†Ô∏è Could not find pet with ID ${petId}`);
                }
              }
            }

            // Check decor removal blocking
            // CRITICAL: PickupDecor message doesn't include decorId, only localTileIndex!
            // We need to look up what's at that position in the garden
            if (msgType === 'PickupDecor') {
              console.log(`üèõÔ∏è [DecorCheck] PickupDecor message:`, JSON.stringify(message, null, 2));

              const lockedDecor = UnifiedState.data.lockedDecor || [];

              if (lockedDecor.length > 0) {
                // Extract tile information from message
                const tileType = message.tileType;
                const tileIndex = message.localTileIndex;

                console.log(`üèõÔ∏è [DecorCheck] Looking for decor at ${tileType} tile ${tileIndex}`);

                // Look up what decor is at this tile position
                let decorAtPosition = null;

                if (targetWindow.myGarden?.garden) {
                  const garden = targetWindow.myGarden.garden;

                  // Check the appropriate tile collection based on tileType
                  if (tileType === 'Boardwalk' && garden.boardwalkTileObjects) {
                    const tile = garden.boardwalkTileObjects[tileIndex];
                    if (tile && tile.objectType === 'decor' && tile.decorId) {
                      decorAtPosition = tile.decorId;
                    }
                  } else if (tileType === 'Garden' && garden.tileObjects) {
                    const tile = garden.tileObjects[tileIndex];
                    if (tile && tile.objectType === 'decor' && tile.decorId) {
                      decorAtPosition = tile.decorId;
                    }
                  }
                }

                console.log(`üèõÔ∏è [DecorCheck] Decor at position: "${decorAtPosition}"`);
                console.log(`üèõÔ∏è [DecorCheck] Locked decor list:`, lockedDecor);

                // Block if this decor is locked
                if (decorAtPosition && lockedDecor.includes(decorAtPosition)) {
                  console.warn(`üèõÔ∏è [DecorLock] ‚ùå BLOCKED pickup of "${decorAtPosition}"`);
                  return; // Block the pickup
                } else if (decorAtPosition) {
                  console.log(`üèõÔ∏è [DecorCheck] ‚úÖ Decor "${decorAtPosition}" not locked, allowing pickup`);
                } else {
                  console.log(`üèõÔ∏è [DecorCheck] ‚ö†Ô∏è Could not find decor at tile position`);
                }
              }
            }

            // Backup scopePath capture for Feed buttons
            if (Array.isArray(message?.scopePath)) {
              targetWindow.__mga_lastScopePath = message.scopePath.slice();
            }

            // Debug hook to see ALL FeedPet messages (native and ours)
            if (message?.type === 'FeedPet') {
              console.log('[FEED-DEBUG] üîç FeedPet message being sent:', {
                type: message.type,
                petItemId: message.petItemId,
                cropItemId: message.cropItemId,
                scopePath: message.scopePath,
                fullMsg: JSON.stringify(message)
              });

              // Check if IDs look valid (UUIDs)
              const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
              if (!uuidRegex.test(message.petItemId)) {
                console.error('[FEED-DEBUG] ‚ùå Invalid petItemId format:', message.petItemId);
              }
              if (!uuidRegex.test(message.cropItemId)) {
                console.error('[FEED-DEBUG] ‚ùå Invalid cropItemId format:', message.cropItemId);
              }
            }

            return originalSendMessage(message, ...rest);
          } catch (err) {
            console.error('[SendMessageHook] Error:', err);
            return originalSendMessage(message, ...rest);
          }
        };

        console.log('‚úÖ Harvest and sell protection hooks installed');
      }, 2000);

      // Apply initial rules
      applyHarvestRule();
      applySellBlockThreshold();
    }

    function setupNotificationsTabHandlers(context = document) {
      // Notification enabled checkbox
      const notificationEnabledCheckbox = context.querySelector('#notifications-enabled-checkbox');
      if (notificationEnabledCheckbox && !notificationEnabledCheckbox.hasAttribute('data-handler-setup')) {
        notificationEnabledCheckbox.setAttribute('data-handler-setup', 'true');
        notificationEnabledCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.notifications.enabled = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üîî [NOTIFICATIONS] ${e.target.checked ? 'Enabled' : 'Disabled'} notifications`);
        });
      }

      // Volume slider
      const volumeSlider = context.querySelector('#notification-volume-slider');
      if (volumeSlider && !volumeSlider.hasAttribute('data-handler-setup')) {
        volumeSlider.setAttribute('data-handler-setup', 'true');
        volumeSlider.addEventListener('input', e => {
          const volume = parseInt(e.target.value) / 100;
          UnifiedState.data.settings.notifications.volume = volume;
          // Update label
          const label = volumeSlider.previousElementSibling;
          label.textContent = `Volume: ${Math.round(volume * 100)}%`;
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Enable Continuous Mode checkbox
      const continuousCheckbox = context.querySelector('#notification-continuous-checkbox');
      if (continuousCheckbox && !continuousCheckbox.hasAttribute('data-handler-setup')) {
        continuousCheckbox.setAttribute('data-handler-setup', 'true');

        // On load: if continuous is already enabled, lock acknowledgment checkbox
        if (UnifiedState.data.settings.notifications.continuousEnabled) {
          const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
          if (acknowledgmentCheckbox) {
            acknowledgmentCheckbox.checked = true;
            acknowledgmentCheckbox.disabled = true;
            UnifiedState.data.settings.notifications.requiresAcknowledgment = true;
          }

          // CRITICAL: Also ensure dropdown is set to continuous if checkbox is checked
          const notificationTypeSelect = context.querySelector('#notification-type-select');
          if (notificationTypeSelect) {
            notificationTypeSelect.value = 'continuous';
            UnifiedState.data.settings.notifications.notificationType = 'continuous';
            productionLog('üîä [NOTIFICATIONS] Auto-selected continuous in dropdown (checkbox was checked on load)');
          }
        }

        continuousCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.notifications.continuousEnabled = e.target.checked;

          // When enabling continuous mode, force acknowledgment to be enabled AND disabled (locked)
          const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
          if (acknowledgmentCheckbox) {
            if (e.target.checked) {
              acknowledgmentCheckbox.checked = true;
              acknowledgmentCheckbox.disabled = true; // Lock it on
              UnifiedState.data.settings.notifications.requiresAcknowledgment = true;
              productionLog(
                `üö® [NOTIFICATIONS] Auto-enabled and locked acknowledgment (required for continuous alarms)`
              );
            } else {
              acknowledgmentCheckbox.disabled = false; // Unlock when continuous is off
            }
          }

          // Update dropdown state
          const notificationTypeSelect = context.querySelector('#notification-type-select');
          if (notificationTypeSelect) {
            const continuousOption = notificationTypeSelect.querySelector('option[value="continuous"]');
            if (continuousOption) {
              continuousOption.disabled = !e.target.checked;

              if (e.target.checked) {
                // When checking: Save current selection and auto-select continuous
                if (notificationTypeSelect.value !== 'continuous') {
                  UnifiedState.data.settings.notifications.previousNotificationType = notificationTypeSelect.value;
                  notificationTypeSelect.value = 'continuous';
                  UnifiedState.data.settings.notifications.notificationType = 'continuous';
                  productionLog(
                    `üîä [NOTIFICATIONS] Saved previous type (${UnifiedState.data.settings.notifications.previousNotificationType}), auto-selected continuous`
                  );
                }
              } else {
                // When unchecking: Restore previous selection (or default to epic)
                if (notificationTypeSelect.value === 'continuous') {
                  const previousType = UnifiedState.data.settings.notifications.previousNotificationType || 'epic';
                  notificationTypeSelect.value = previousType;
                  UnifiedState.data.settings.notifications.notificationType = previousType;
                  productionLog(`üîä [NOTIFICATIONS] Continuous mode disabled, reverted to ${previousType}`);
                }
              }
            }
          }

          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`‚ö†Ô∏è [NOTIFICATIONS] Continuous mode enabled: ${e.target.checked}`);
        });
      }

      // Notification type selector
      const notificationTypeSelect = context.querySelector('#notification-type-select');
      if (notificationTypeSelect && !notificationTypeSelect.hasAttribute('data-handler-setup')) {
        notificationTypeSelect.setAttribute('data-handler-setup', 'true');

        // Explicitly restore saved value (defensive - ensures dropdown matches saved state)
        const savedNotificationType = UnifiedState.data.settings.notifications.notificationType || 'epic';
        notificationTypeSelect.value = savedNotificationType;
        productionLog(`üîä [NOTIFICATIONS] Restored notification type to: ${savedNotificationType}`);

        // On load: if continuous type is selected, lock acknowledgment checkbox
        if (UnifiedState.data.settings.notifications.notificationType === 'continuous') {
          const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
          if (acknowledgmentCheckbox) {
            acknowledgmentCheckbox.checked = true;
            acknowledgmentCheckbox.disabled = true;
            UnifiedState.data.settings.notifications.requiresAcknowledgment = true;
          }
        }

        notificationTypeSelect.addEventListener('change', e => {
          // Prevent selecting continuous if not enabled
          if (e.target.value === 'continuous' && !UnifiedState.data.settings.notifications.continuousEnabled) {
            e.target.value = UnifiedState.data.settings.notifications.notificationType || 'epic';
            productionWarn(`‚ö†Ô∏è [NOTIFICATIONS] Cannot select continuous mode - please enable it first`);
            showVisualNotification('‚ö†Ô∏è Please enable Continuous Mode checkbox first', false);
            return;
          }

          UnifiedState.data.settings.notifications.notificationType = e.target.value;

          // When selecting continuous, force acknowledgment to be enabled AND locked
          const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
          if (acknowledgmentCheckbox) {
            if (e.target.value === 'continuous') {
              acknowledgmentCheckbox.checked = true;
              acknowledgmentCheckbox.disabled = true; // Lock it on
              UnifiedState.data.settings.notifications.requiresAcknowledgment = true;
              productionLog(
                `üö® [NOTIFICATIONS] Auto-enabled and locked acknowledgment (required for continuous alarms)`
              );
            } else {
              // When changing away from continuous, unlock the acknowledgment checkbox
              // (unless continuous mode checkbox is still enabled)
              if (!UnifiedState.data.settings.notifications.continuousEnabled) {
                acknowledgmentCheckbox.disabled = false;
              }
            }
          }

          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üîä [NOTIFICATIONS] Sound type changed to: ${e.target.value}`);
        });
      }

      // Acknowledgment required checkbox
      const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
      if (acknowledgmentCheckbox && !acknowledgmentCheckbox.hasAttribute('data-handler-setup')) {
        acknowledgmentCheckbox.setAttribute('data-handler-setup', 'true');

        // Explicitly restore saved value
        acknowledgmentCheckbox.checked = UnifiedState.data.settings.notifications.requiresAcknowledgment || false;
        productionLog(`üö® [NOTIFICATIONS] Restored acknowledgment checkbox to: ${acknowledgmentCheckbox.checked}`);

        acknowledgmentCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.notifications.requiresAcknowledgment = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üö® [NOTIFICATIONS] Require acknowledgment: ${e.target.checked}`);
        });
      }

      // Test notification button
      const testNotificationBtn = context.querySelector('#test-notification-btn');
      if (testNotificationBtn && !testNotificationBtn.hasAttribute('data-handler-setup')) {
        testNotificationBtn.setAttribute('data-handler-setup', 'true');
        testNotificationBtn.addEventListener('click', () => {
          const notifications = UnifiedState.data.settings.notifications;
          playSelectedNotification();
          queueNotification(
            'üîî Test notification - This is how alerts will look!',
            notifications.requiresAcknowledgment
          );
          productionLog(
            `üîî [NOTIFICATIONS] Test notification played - Type: ${notifications.notificationType}, Volume: ${Math.round(notifications.volume * 100)}%, Acknowledgment: ${notifications.requiresAcknowledgment}`
          );
        });
      }

      // Seed watch checkboxes
      const seedWatchMap = {
        'watch-carrot': 'Carrot',
        'watch-strawberry': 'Strawberry',
        'watch-aloe': 'Aloe',
        'watch-blueberry': 'Blueberry',
        'watch-apple': 'Apple',
        'watch-tulip': 'Tulip',
        'watch-tomato': 'Tomato',
        'watch-daffodil': 'Daffodil',
        'watch-corn': 'Corn',
        'watch-watermelon': 'Watermelon',
        'watch-pumpkin': 'Pumpkin',
        'watch-echeveria': 'Echeveria',
        'watch-coconut': 'Coconut',
        'watch-banana': 'Banana',
        'watch-lily': 'Lily',
        'watch-burrostail': 'BurrosTail',
        'watch-mushroom': 'Mushroom',
        'watch-cactus': 'Cactus',
        'watch-bamboo': 'Bamboo',
        'watch-grape': 'Grape',
        'watch-pepper': 'Pepper',
        'watch-lemon': 'Lemon',
        'watch-passionfruit': 'PassionFruit',
        'watch-dragonfruit': 'DragonFruit',
        'watch-lychee': 'Lychee',
        'watch-sunflower': 'Sunflower',
        'watch-starweaver': 'Starweaver',
        'watch-dawnbinder': 'Dawnbinder',
        'watch-moonbinder': 'Moonbinder'
      };

      Object.entries(seedWatchMap).forEach(([checkboxId, seedId]) => {
        const checkbox = context.querySelector(`#${checkboxId}`);
        if (checkbox && !checkbox.hasAttribute('data-handler-setup')) {
          checkbox.setAttribute('data-handler-setup', 'true');
          checkbox.addEventListener('change', e => {
            const notifications = UnifiedState.data.settings.notifications;
            if (e.target.checked) {
              if (!notifications.watchedSeeds.includes(seedId)) {
                notifications.watchedSeeds.push(seedId);
              }
            } else {
              notifications.watchedSeeds = notifications.watchedSeeds.filter(id => id !== seedId);
            }
            MGA_saveJSON('MGA_data', UnifiedState.data);
            productionLog(`üå± [NOTIFICATIONS] ${e.target.checked ? 'Added' : 'Removed'} ${seedId} to/from watch list`);
            updateLastSeenDisplay();
          });
        }
      });

      // Egg watch checkboxes
      const eggWatchMap = {
        'watch-common-egg': 'CommonEgg',
        'watch-uncommon-egg': 'UncommonEgg',
        'watch-rare-egg': 'RareEgg',
        'watch-legendary-egg': 'LegendaryEgg',
        'watch-mythical-egg': 'MythicalEgg'
      };

      Object.entries(eggWatchMap).forEach(([checkboxId, eggId]) => {
        const checkbox = context.querySelector(`#${checkboxId}`);
        if (checkbox && !checkbox.hasAttribute('data-handler-setup')) {
          checkbox.setAttribute('data-handler-setup', 'true');
          checkbox.addEventListener('change', e => {
            const notifications = UnifiedState.data.settings.notifications;
            if (e.target.checked) {
              if (!notifications.watchedEggs.includes(eggId)) {
                notifications.watchedEggs.push(eggId);
              }
            } else {
              notifications.watchedEggs = notifications.watchedEggs.filter(id => id !== eggId);
            }
            MGA_saveJSON('MGA_data', UnifiedState.data);
            productionLog(`ü•ö [NOTIFICATIONS] ${e.target.checked ? 'Added' : 'Removed'} ${eggId} to/from watch list`);
            updateLastSeenDisplay();
          });
        }
      });

      // Decor watch checkboxes
      DECOR_ITEMS.forEach(decor => {
        const checkboxId = `watch-decor-${decor.id.toLowerCase()}`;
        const checkbox = context.querySelector(`#${checkboxId}`);
        if (checkbox && !checkbox.hasAttribute('data-handler-setup')) {
          checkbox.setAttribute('data-handler-setup', 'true');
          checkbox.addEventListener('change', e => {
            const notifications = UnifiedState.data.settings.notifications;
            if (e.target.checked) {
              if (!notifications.watchedDecor.includes(decor.id)) {
                notifications.watchedDecor.push(decor.id);
              }
            } else {
              notifications.watchedDecor = notifications.watchedDecor.filter(id => id !== decor.id);
            }
            MGA_saveJSON('MGA_data', UnifiedState.data);
            productionLog(
              `üé® [NOTIFICATIONS] ${e.target.checked ? 'Added' : 'Removed'} ${decor.id} to/from watch list`
            );
            updateLastSeenDisplay();
          });
        }
      });

      // Update last seen display function
      function updateLastSeenDisplay() {
        const lastSeenDisplay = context.querySelector('#last-seen-display');
        if (!lastSeenDisplay) return;

        const notifications = UnifiedState.data.settings.notifications;
        const allWatched = [...notifications.watchedSeeds, ...notifications.watchedEggs, ...notifications.watchedDecor];

        if (allWatched.length === 0) {
          lastSeenDisplay.innerHTML = 'No items being watched';
          return;
        }

        let html = '';
        allWatched.forEach(itemId => {
          const timeSince = getTimeSinceLastSeen(itemId);
          html += `<div>${itemId}: ${timeSince}</div>`;
        });

        lastSeenDisplay.innerHTML = html;
      }

      // Initial last seen update
      updateLastSeenDisplay();

      // Update last seen display every 30 seconds
      setInterval(updateLastSeenDisplay, 30000);

      // ==================== NEW NOTIFICATION HANDLERS ====================

      // Pet hunger enabled checkbox
      const petHungerCheckbox = context.querySelector('#pet-hunger-enabled');
      if (petHungerCheckbox && !petHungerCheckbox.hasAttribute('data-handler-setup')) {
        petHungerCheckbox.setAttribute('data-handler-setup', 'true');
        petHungerCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.notifications.petHungerEnabled = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üêæ [PET-HUNGER] ${e.target.checked ? 'Enabled' : 'Disabled'} pet hunger notifications`);

          // BUGFIX: Scan for currently hungry pets when enabling alerts
          if (e.target.checked) {
            // Delay slightly to ensure atoms are available
            setTimeout(() => {
              scanAndAlertHungryPets();
            }, 500);
          }
        });
      }

      // Pet hunger threshold slider
      const petHungerThreshold = context.querySelector('#pet-hunger-threshold');
      if (petHungerThreshold && !petHungerThreshold.hasAttribute('data-handler-setup')) {
        petHungerThreshold.setAttribute('data-handler-setup', 'true');
        petHungerThreshold.addEventListener('input', e => {
          const threshold = parseInt(e.target.value);
          UnifiedState.data.settings.notifications.petHungerThreshold = threshold;
          // Update label
          const label = petHungerThreshold.previousElementSibling;
          label.textContent = `Alert when hunger below: ${threshold}%`;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üêæ [PET-HUNGER] Threshold set to ${threshold}%`);
        });
      }

      // Ability notifications enabled checkbox
      const abilityNotificationsCheckbox = context.querySelector('#ability-notifications-enabled');
      if (abilityNotificationsCheckbox && !abilityNotificationsCheckbox.hasAttribute('data-handler-setup')) {
        abilityNotificationsCheckbox.setAttribute('data-handler-setup', 'true');
        abilityNotificationsCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.notifications.abilityNotificationsEnabled = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`‚ú® [ABILITY-NOTIFY] ${e.target.checked ? 'Enabled' : 'Disabled'} ability notifications`);
        });
      }

      // Ability notification sound type selector
      const abilityNotificationSoundSelect = context.querySelector('#ability-notification-sound-select');
      if (abilityNotificationSoundSelect && !abilityNotificationSoundSelect.hasAttribute('data-handler-setup')) {
        abilityNotificationSoundSelect.setAttribute('data-handler-setup', 'true');
        abilityNotificationSoundSelect.addEventListener('change', e => {
          UnifiedState.data.settings.notifications.abilityNotificationSound = e.target.value;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`‚ú® [ABILITY-NOTIFY] Sound type changed to: ${e.target.value}`);
        });
      }

      // Ability notification volume slider
      const abilityVolumeSlider = context.querySelector('#ability-notification-volume-slider');
      if (abilityVolumeSlider && !abilityVolumeSlider.hasAttribute('data-handler-setup')) {
        abilityVolumeSlider.setAttribute('data-handler-setup', 'true');
        abilityVolumeSlider.addEventListener('input', e => {
          const volume = parseInt(e.target.value) / 100;
          UnifiedState.data.settings.notifications.abilityNotificationVolume = volume;
          // Update label
          const label = abilityVolumeSlider.previousElementSibling;
          label.textContent = `Ability Alert Volume: ${Math.round(volume * 100)}%`;
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Individual ability checkboxes
      const individualAbilityCheckboxes = context.querySelectorAll('.individual-ability-checkbox');
      individualAbilityCheckboxes.forEach(checkbox => {
        if (!checkbox.hasAttribute('data-handler-setup')) {
          checkbox.setAttribute('data-handler-setup', 'true');
          checkbox.addEventListener('change', e => {
            const abilityName = e.target.dataset.abilityName;
            if (!UnifiedState.data.settings.notifications.watchedAbilities) {
              UnifiedState.data.settings.notifications.watchedAbilities = [];
            }

            if (e.target.checked) {
              // Add to watched list
              if (!UnifiedState.data.settings.notifications.watchedAbilities.includes(abilityName)) {
                UnifiedState.data.settings.notifications.watchedAbilities.push(abilityName);
              }
            } else {
              // Remove from watched list
              const index = UnifiedState.data.settings.notifications.watchedAbilities.indexOf(abilityName);
              if (index > -1) {
                UnifiedState.data.settings.notifications.watchedAbilities.splice(index, 1);
              }
            }

            MGA_saveJSON('MGA_data', UnifiedState.data);
            productionLog(`‚ú® [ABILITY-NOTIFY] ${abilityName}: ${e.target.checked ? 'Enabled' : 'Disabled'}`);
          });
        }
      });

      // Ability search box
      const abilitySearchBox = context.querySelector('#ability-search-box');
      if (abilitySearchBox && !abilitySearchBox.hasAttribute('data-handler-setup')) {
        abilitySearchBox.setAttribute('data-handler-setup', 'true');
        abilitySearchBox.addEventListener('input', e => {
          const query = e.target.value.toLowerCase();
          const items = context.querySelectorAll('.ability-checkbox-item');
          items.forEach(item => {
            const abilityName = item.dataset.ability.toLowerCase();
            item.style.display = abilityName.includes(query) ? 'flex' : 'none';
          });
        });
      }

      // Select All individual abilities button
      const selectAllIndividualAbilities = context.querySelector('#select-all-individual-abilities');
      if (selectAllIndividualAbilities && !selectAllIndividualAbilities.hasAttribute('data-handler-setup')) {
        selectAllIndividualAbilities.setAttribute('data-handler-setup', 'true');
        selectAllIndividualAbilities.addEventListener('click', () => {
          // Empty array means all abilities enabled (backward compatibility)
          UnifiedState.data.settings.notifications.watchedAbilities = [];

          // Update all checkboxes
          context.querySelectorAll('.individual-ability-checkbox').forEach(checkbox => {
            checkbox.checked = true;
          });

          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog('‚ú® [ABILITY-NOTIFY] Enabled all abilities');
        });
      }

      // Select None individual abilities button
      const selectNoneIndividualAbilities = context.querySelector('#select-none-individual-abilities');
      if (selectNoneIndividualAbilities && !selectNoneIndividualAbilities.hasAttribute('data-handler-setup')) {
        selectNoneIndividualAbilities.setAttribute('data-handler-setup', 'true');
        selectNoneIndividualAbilities.addEventListener('click', () => {
          // Get all ability names
          const allAbilities = [];
          context.querySelectorAll('.individual-ability-checkbox').forEach(checkbox => {
            allAbilities.push(checkbox.dataset.abilityName);
          });

          // Set watchedAbilities to opposite - if we want none, we list all then check against not-in-list
          // Actually, better approach: use a special flag or empty means all, populated means only those
          // For "none", we need a way to indicate "empty set of abilities"
          // Let's use: populated array with abilities = only those; empty array = all; null = none
          UnifiedState.data.settings.notifications.watchedAbilities = ['__NONE__']; // Special marker

          // Update all checkboxes
          context.querySelectorAll('.individual-ability-checkbox').forEach(checkbox => {
            checkbox.checked = false;
          });

          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog('‚ú® [ABILITY-NOTIFY] Disabled all abilities');
        });
      }

      // Weather notifications enabled checkbox
      const weatherNotificationsCheckbox = context.querySelector('#weather-notifications-enabled');
      if (weatherNotificationsCheckbox && !weatherNotificationsCheckbox.hasAttribute('data-handler-setup')) {
        weatherNotificationsCheckbox.setAttribute('data-handler-setup', 'true');
        weatherNotificationsCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.notifications.weatherNotificationsEnabled = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üå§Ô∏è [WEATHER] ${e.target.checked ? 'Enabled' : 'Disabled'} weather notifications`);
        });
      }

      // Weather event checkboxes
      const weatherEventMap = {
        'watch-snow': 'Snow',
        'watch-rain': 'Rain',
        'watch-amber-moon': 'AmberMoon',
        'watch-dawn': 'Dawn'
      };

      Object.entries(weatherEventMap).forEach(([checkboxId, eventName]) => {
        const checkbox = context.querySelector(`#${checkboxId}`);
        if (checkbox && !checkbox.hasAttribute('data-handler-setup')) {
          checkbox.setAttribute('data-handler-setup', 'true');
          checkbox.addEventListener('change', e => {
            const watchedEvents = UnifiedState.data.settings.notifications.watchedWeatherEvents;
            if (e.target.checked) {
              if (!watchedEvents.includes(eventName)) {
                watchedEvents.push(eventName);
              }
            } else {
              const idx = watchedEvents.indexOf(eventName);
              if (idx > -1) watchedEvents.splice(idx, 1);
            }
            MGA_saveJSON('MGA_data', UnifiedState.data);
            productionLog(`üå§Ô∏è [WEATHER] ${e.target.checked ? 'Added' : 'Removed'} ${eventName} to/from watch list`);
          });
        }
      });

      // ========== CUSTOM NOTIFICATION SOUNDS ==========
      const customSoundsContainer = context.querySelector('#custom-sounds-container');
      if (customSoundsContainer && !customSoundsContainer.hasAttribute('data-handler-setup')) {
        customSoundsContainer.setAttribute('data-handler-setup', 'true');

        const soundTypes = [
          { id: 'shop', label: 'üõí Shop Alerts' },
          { id: 'pet', label: 'üêæ Pet Hunger' },
          { id: 'ability', label: '‚ö° Ability Triggers' },
          { id: 'weather', label: 'üå§Ô∏è Weather Events' }
        ];

        soundTypes.forEach(type => {
          const hasCustom = GM_getValue(`mgtools_custom_sound_${type.id}`, null) !== null;

          const controlDiv = document.createElement('div');
          controlDiv.style.cssText =
            'border: 1px solid rgba(255, 255, 255, 0.57); padding: 10px; border-radius: 6px; background: rgba(0, 0, 0, 0.48);';
          controlDiv.innerHTML = `
                      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                          <label class="mga-label" style="margin: 0;">${type.label}</label>
                          <span id="custom-sound-status-${type.id}" style="font-size: 10px; color: ${hasCustom ? '#10b981' : '#666'};">
                              ${hasCustom ? '‚úì Custom' : '‚óã Default'}
                          </span>
                      </div>
                      <div style="display: flex; gap: 6px;">
                          <input type="file" accept="audio/*" id="upload-sound-${type.id}" style="display: none;">
                          <button class="mga-btn mga-btn-sm" id="upload-btn-${type.id}" style="flex: 1; background: #4a9eff; font-size: 11px; padding: 6px;">üìÅ Upload</button>
                          <button class="mga-btn mga-btn-sm" id="test-btn-${type.id}" style="flex: 0.6; background: #10b981; font-size: 11px; padding: 6px;">‚ñ∂Ô∏è Test</button>
                          <button class="mga-btn mga-btn-sm" id="delete-btn-${type.id}" style="flex: 0.6; background: ${hasCustom ? '#ef4444' : '#666'}; font-size: 11px; padding: 6px;" ${!hasCustom ? 'disabled' : ''}>üóëÔ∏è</button>
                      </div>
                  `;
          customSoundsContainer.appendChild(controlDiv);

          const uploadBtn = controlDiv.querySelector(`#upload-btn-${type.id}`);
          const fileInput = controlDiv.querySelector(`#upload-sound-${type.id}`);
          uploadBtn.addEventListener('click', () => fileInput.click());

          fileInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            if (file.size > 2 * 1024 * 1024) {
              alert('‚ùå File too large! Max 2MB');
              return;
            }
            if (!file.type.startsWith('audio/')) {
              alert('‚ùå Please upload an audio file');
              return;
            }

            const reader = new FileReader();
            reader.onload = event => {
              GM_setValue(`mgtools_custom_sound_${type.id}`, event.target.result);
              controlDiv.querySelector(`#custom-sound-status-${type.id}`).textContent = '‚úì Custom';
              controlDiv.querySelector(`#custom-sound-status-${type.id}`).style.color = '#10b981';
              const delBtn = controlDiv.querySelector(`#delete-btn-${type.id}`);
              delBtn.disabled = false;
              delBtn.style.background = '#ef4444';
              productionLog(`üéµ [CUSTOM-SOUND] Uploaded: ${type.id}`);
              alert(`‚úÖ Custom sound uploaded!`);
            };
            reader.readAsDataURL(file);
          });

          controlDiv.querySelector(`#test-btn-${type.id}`).addEventListener('click', () => {
            const customSound = GM_getValue(`mgtools_custom_sound_${type.id}`, null);
            const volume = UnifiedState.data.settings.notifications.volume || 0.3;
            if (customSound) {
              const audio = new Audio(customSound);
              audio.volume = volume;
              audio.play();
            } else {
              playSelectedNotification();
            }
          });

          controlDiv.querySelector(`#delete-btn-${type.id}`).addEventListener('click', () => {
            if (confirm(`Delete custom sound for ${type.label}?`)) {
              GM_deleteValue(`mgtools_custom_sound_${type.id}`);
              controlDiv.querySelector(`#custom-sound-status-${type.id}`).textContent = '‚óã Default';
              controlDiv.querySelector(`#custom-sound-status-${type.id}`).style.color = '#666';
              const delBtn = controlDiv.querySelector(`#delete-btn-${type.id}`);
              delBtn.disabled = true;
              delBtn.style.background = '#666';
              alert(`‚úÖ Reverted to default sound`);
            }
          });
        });
      }
    }

    function setupSettingsTabHandlers(context = document) {
      console.log('üö® [CRITICAL-DEBUG] setupSettingsTabHandlers ENTERED');
      productionLog('‚öôÔ∏è [SETTINGS] setupSettingsTabHandlers called', {
        context: context === document ? 'document' : 'custom'
      });
      console.log('üö® [CRITICAL-DEBUG] Context type:', context === document ? 'DOCUMENT' : 'ELEMENT', context);

      // Compatibility Mode toggle button
      const compatToggleBtn = context.querySelector('#compat-toggle-btn');
      if (compatToggleBtn && typeof CompatibilityMode !== 'undefined') {
        compatToggleBtn.addEventListener('click', () => {
          if (CompatibilityMode.flags.enabled) {
            // Disable compatibility mode
            CompatibilityMode.disableCompat();
            logInfo('COMPAT', 'User disabled compatibility mode - reload required');
            alert('Compatibility Mode disabled. Please refresh the page for changes to take effect.');
          } else {
            // Enable compatibility mode
            try {
              localStorage.setItem('mgtools_compat_forced', 'true');
              localStorage.removeItem('mgtools_compat_disabled');
              logInfo('COMPAT', 'User enabled compatibility mode - reload required');
              alert('Compatibility Mode enabled. Please refresh the page for changes to take effect.');
            } catch (e) {
              alert('Unable to save compatibility mode setting. Your browser may have storage restrictions.');
            }
          }

          // Offer to reload
          if (confirm('Would you like to reload the page now?')) {
            window.location.reload();
          }
        });
      }

      // Opacity slider
      const opacitySlider = context.querySelector('#opacity-slider');
      if (opacitySlider) {
        opacitySlider.addEventListener('input', e => {
          const opacity = parseInt(e.target.value);
          UnifiedState.data.settings.opacity = opacity;
          applyTheme();
          // Update label
          const label = opacitySlider.previousElementSibling;
          label.textContent = `Main HUD Opacity: ${opacity}%`;
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Pop-out opacity slider
      const popoutOpacitySlider = context.querySelector('#popout-opacity-slider');
      if (popoutOpacitySlider) {
        popoutOpacitySlider.addEventListener('input', e => {
          const popoutOpacity = parseInt(e.target.value);
          UnifiedState.data.settings.popoutOpacity = popoutOpacity;
          syncThemeToAllWindows(); // Apply theme to pop-out windows only
          // Update label
          const label = popoutOpacitySlider.previousElementSibling;
          label.textContent = `Pop-out Opacity: ${popoutOpacity}%`;
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Gradient select
      const gradientSelect = context.querySelector('#gradient-select');
      if (gradientSelect) {
        gradientSelect.addEventListener('change', e => {
          UnifiedState.data.settings.gradientStyle = e.target.value;
          applyTheme();
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Effect select
      const effectSelect = context.querySelector('#effect-select');
      if (effectSelect) {
        effectSelect.addEventListener('change', e => {
          UnifiedState.data.settings.effectStyle = e.target.value;
          applyTheme();
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Theme preset buttons
      const themePresetButtons = context.querySelectorAll('[data-preset]');
      themePresetButtons.forEach(btn => {
        if (!btn.hasAttribute('data-handler-setup')) {
          btn.setAttribute('data-handler-setup', 'true');
          btn.addEventListener('click', e => {
            const presetName = e.target.dataset.preset;

            // Apply the preset
            applyPreset(presetName);

            // Apply theme immediately
            applyTheme();

            // Save the settings
            MGA_saveJSON('MGA_data', UnifiedState.data);

            // Update UI elements to reflect new values
            // Update opacity slider
            const opacitySlider = context.querySelector('#opacity-slider');
            if (opacitySlider) {
              opacitySlider.value = UnifiedState.data.settings.opacity;
              const label = opacitySlider.previousElementSibling;
              if (label) {
                label.textContent = `Main HUD Opacity: ${UnifiedState.data.settings.opacity}%`;
              }
            }

            // Update gradient select
            const gradientSelect = context.querySelector('#gradient-select');
            if (gradientSelect) {
              gradientSelect.value = UnifiedState.data.settings.gradientStyle;
            }

            // Update effect select
            const effectSelect = context.querySelector('#effect-select');
            if (effectSelect) {
              effectSelect.value = UnifiedState.data.settings.effectStyle;
            }

            productionLog(`üé® Applied theme preset: ${presetName}`);
          });
        }
      });

      // Texture select
      const textureSelect = context.querySelector('#texture-select');
      if (textureSelect) {
        textureSelect.addEventListener('change', e => {
          UnifiedState.data.settings.textureStyle = e.target.value;
          applyTheme();
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Texture intensity slider
      const intensitySlider = context.querySelector('#texture-intensity-slider');
      const intensityValue = context.querySelector('#texture-intensity-value');
      if (intensitySlider && intensityValue) {
        intensitySlider.addEventListener('input', e => {
          const value = e.target.value;
          intensityValue.textContent = value + '%';
          UnifiedState.data.settings.textureIntensity = parseInt(value);
          applyTheme();
        });
        intensitySlider.addEventListener('change', e => {
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Texture scale buttons
      const scaleButtons = context.querySelectorAll('.texture-scale-btn');
      if (scaleButtons.length > 0) {
        scaleButtons.forEach(btn => {
          btn.addEventListener('click', e => {
            const scale = e.target.dataset.scale;
            UnifiedState.data.settings.textureScale = scale;

            // Update button styles
            scaleButtons.forEach(b => {
              b.style.background = '';
              b.style.color = '';
            });
            e.target.style.background = '#4a9eff';
            e.target.style.color = 'white';

            applyTheme();
            MGA_saveJSON('MGA_data', UnifiedState.data);
          });
        });
      }

      // Texture blend mode selector
      const blendModeSelect = context.querySelector('#texture-blend-mode');
      if (blendModeSelect) {
        blendModeSelect.addEventListener('change', e => {
          UnifiedState.data.settings.textureBlendMode = e.target.value;
          applyTheme();
          MGA_saveJSON('MGA_data', UnifiedState.data);
        });
      }

      // Ultra-compact mode checkbox
      const ultraCompactCheckbox = context.querySelector('#ultra-compact-checkbox');
      if (ultraCompactCheckbox) {
        // Remove any existing listeners by cloning
        const newCheckbox = ultraCompactCheckbox.cloneNode(true);
        ultraCompactCheckbox.parentNode.replaceChild(newCheckbox, ultraCompactCheckbox);

        newCheckbox.addEventListener('change', e => {
          e.stopPropagation();
          UnifiedState.data.settings.ultraCompactMode = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          applyUltraCompactMode(e.target.checked);
          productionLog(`üì± Ultra-compact mode ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }

      // FIX ISSUE B: Hide feed buttons checkbox
      const hideFeedButtonsCheckbox = context.querySelector('#hide-feed-buttons-checkbox');
      if (hideFeedButtonsCheckbox) {
        hideFeedButtonsCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.hideFeedButtons = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);

          // Toggle visibility immediately
          const allFeedButtons = targetDocument.querySelectorAll('.mgtools-instant-feed-btn');
          allFeedButtons.forEach(btn => {
            btn.style.setProperty('display', e.target.checked ? 'none' : 'block', 'important');
          });

          console.log(`[MGTOOLS-FIX-B] Feed buttons ${e.target.checked ? 'hidden' : 'shown'}`);
          productionLog(`üçÉ Instant feed buttons ${e.target.checked ? 'hidden' : 'shown'}`);
        });
      }

      // Overlay mode checkbox
      const overlayCheckbox = context.querySelector('#use-overlays-checkbox');
      if (overlayCheckbox) {
        overlayCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.useInGameOverlays = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üéÆ Overlay mode ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }

      // Debug mode checkbox
      const debugModeCheckbox = context.querySelector('#debug-mode-checkbox');
      if (debugModeCheckbox) {
        debugModeCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.debugMode = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üêõ Debug mode ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }

      // Room debug mode checkbox
      const roomDebugModeCheckbox = context.querySelector('#room-debug-mode-checkbox');
      if (roomDebugModeCheckbox) {
        roomDebugModeCheckbox.addEventListener('change', e => {
          UnifiedState.data.settings.roomDebugMode = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          console.log(`[MGTools] Room debug mode ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
      }

      // Preset buttons
      context.querySelectorAll('[data-preset]').forEach(btn => {
        btn.addEventListener('click', e => {
          const preset = e.target.dataset.preset;
          applyPreset(preset);
        });
      });

      // Export/Import
      const exportBtn = context.querySelector('#export-settings-btn');
      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          const data = JSON.stringify(UnifiedState.data, null, 2);
          const blob = new Blob([data], { type: 'application/json' });
          const link = targetDocument.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'MGA_Settings.json';
          link.click();
        });
      }

      // Import settings handler
      const importBtn = context.querySelector('#import-settings-btn');
      if (importBtn) {
        importBtn.addEventListener('click', () => {
          const fileInput = targetDocument.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = '.json';
          fileInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = event => {
              try {
                const importedData = JSON.parse(event.target.result);

                // Validate it's a data object
                if (typeof importedData !== 'object' || importedData === null) {
                  throw new Error('Invalid data format');
                }

                // Merge imported data with current data (preserve any new data not in import)
                UnifiedState.data = { ...UnifiedState.data, ...importedData };

                // Save to storage
                MGA_saveJSON('MGA_data', UnifiedState.data);

                // Apply theme immediately
                applyTheme();

                // Apply other settings
                if (UnifiedState.data.settings.ultraCompactMode) {
                  applyUltraCompactMode(true);
                }

                productionLog('‚úÖ Settings imported successfully!');
                showNotificationToast('‚úÖ Settings imported and applied!', 'success');

                // Refresh UI to show updated settings
                if (UnifiedState.activeTab === 'settings') {
                  updateTabContent();
                }
              } catch (error) {
                console.error('Failed to import settings:', error);
                showNotificationToast('‚ùå Failed to import settings. Invalid file format.', 'error');
              }
            };
            reader.readAsText(file);
          });
          fileInput.click();
        });
      }

      // Reset pet loadouts handler
      const resetLoadoutsBtn = context.querySelector('#reset-loadouts-btn');
      if (resetLoadoutsBtn) {
        resetLoadoutsBtn.addEventListener('click', () => {
          if (confirm('Are you sure you want to reset all pet loadouts? This cannot be undone.')) {
            UnifiedState.data.petPresets = {};
            UnifiedState.data.petPresetHotkeys = {};
            UnifiedState.data.petPresetsOrder = [];
            MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
            MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
            MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);
            productionLog('[SETTINGS] Pet loadouts and hotkeys have been reset');
            // Update the UI if we're in the pets tab
            if (UnifiedState.activeTab === 'pets') {
              updateTabContent();
            }
            productionLog('[SETTINGS] Pet loadouts have been reset successfully');
          }
        });
      }

      // Clear all pet hotkeys handler
      const clearHotkeysBtn = context.querySelector('#clear-hotkeys-btn');
      if (clearHotkeysBtn) {
        clearHotkeysBtn.addEventListener('click', () => {
          if (
            confirm('Clear all pet preset hotkeys? This will not delete your presets, only the hotkey assignments.')
          ) {
            UnifiedState.data.petPresetHotkeys = {};
            MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
            productionLog('[SETTINGS] All pet preset hotkeys cleared');
            // Update the UI if we're in the pets tab
            if (UnifiedState.activeTab === 'pets') {
              updateTabContent();
            }
            alert('All pet preset hotkeys have been cleared. You can now assign new hotkeys without conflicts.');
          }
        });
      }

      // Weather effects checkbox
      const weatherCheckbox = context.querySelector('#hide-weather-checkbox');
      if (weatherCheckbox && !weatherCheckbox.hasAttribute('data-handler-setup')) {
        weatherCheckbox.setAttribute('data-handler-setup', 'true');
        try {
          weatherCheckbox.checked = !!(
            UnifiedState &&
            UnifiedState.data &&
            UnifiedState.data.settings &&
            UnifiedState.data.settings.hideWeather
          );
        } catch (_) {}
        const cloned = weatherCheckbox.cloneNode(true);
        weatherCheckbox.parentNode.replaceChild(cloned, weatherCheckbox);
        cloned.addEventListener('change', e => {
          if (!UnifiedState || !UnifiedState.data || !UnifiedState.data.settings) return;
          UnifiedState.data.settings.hideWeather = !!e.target.checked;
          try {
            MGA_saveJSON('MGA_data', UnifiedState.data);
          } catch (err) {
            console.error('Weather save failed:', err);
          }
          try {
            applyWeatherSetting();
          } catch (err) {
            console.error('applyWeatherSetting failed:', err);
          }
          productionLog(`üåßÔ∏è [WEATHER] Toggle set to ${e.target.checked ? 'HIDE' : 'SHOW'}`);
        });
      }
    }

    // ==================== CROP HIGHLIGHTING SYSTEM ====================
    let applyCropHighlighting = function () {
      try {
        // Get values from UI
        const highlightSpecies = targetDocument.querySelector('#highlight-species-select')?.value || null;
        const slotIndex = parseInt(targetDocument.querySelector('#highlight-slot-input')?.value || '0');
        const hiddenSpecies = targetDocument.querySelector('#hidden-species-select')?.value || null;
        const hiddenScale = parseFloat(targetDocument.querySelector('#hidden-scale-input')?.value || '0.1');

        // Validate inputs
        if (!highlightSpecies) {
          productionWarn('üå± No species selected for highlighting');
          return;
        }

        // Always clear previous highlights first
        if (typeof window.removeAllTileOverrides === 'function') {
          window.removeAllTileOverrides();
          debugLog('CROP_HIGHLIGHTING', 'Cleared previous tile overrides');
        } else {
          debugLog('CROP_HIGHLIGHTING', 'removeAllTileOverrides function not available');
        }

        // Apply new highlighting
        const config = {
          highlightSpecies: highlightSpecies,
          highlightMutations: [null], // Default to no mutation filter
          slotIndex: slotIndex,
          highlightScale: null, // Let the system decide
          hiddenSpecies: hiddenSpecies || null,
          hiddenScale: hiddenScale
        };

        if (typeof window.highlightTilesByMutation === 'function') {
          window.highlightTilesByMutation(config);
          productionLog(`üå± Applied crop highlighting for ${highlightSpecies} (slot ${slotIndex})`);
          debugLog('CROP_HIGHLIGHTING', 'Applied highlighting configuration', config);
        } else {
          productionWarn('üå± highlightTilesByMutation function not available');
          debugLog('CROP_HIGHLIGHTING', 'highlightTilesByMutation function not found in window object');
        }
      } catch (error) {
        debugError('CROP_HIGHLIGHTING', 'Failed to apply crop highlighting', error);
      }
    };

    function setupToolsTabHandlers(context = document) {
      // Calculator mapping
      const calculatorUrls = {
        'sell-price': 'https://daserix.github.io/magic-garden-calculator/#/sell-price-calculator',
        'weight-probability': 'https://daserix.github.io/magic-garden-calculator/#/weight-probability-calculator',
        'pet-appearance-probability':
          'https://daserix.github.io/magic-garden-calculator/#/pet-appearance-probability-calculator',
        'ability-trigger-time': 'https://daserix.github.io/magic-garden-calculator/#/ability-trigger-time-calculator',
        'import-garden': 'https://daserix.github.io/magic-garden-calculator/#/garden'
      };

      // Wiki mapping
      const wikiUrls = {
        crops: 'https://magicgarden.fandom.com/wiki/Crops',
        pets: 'https://magicgarden.fandom.com/wiki/Pets',
        abilities: 'https://magicgarden.fandom.com/wiki/Abilities',
        weather: 'https://magicgarden.fandom.com/wiki/Weather_Events',
        multipliers: 'https://magicgarden.fandom.com/wiki/Multipliers',
        shops: 'https://magicgarden.fandom.com/wiki/Shops'
      };

      // Add click handlers to all calculator cards
      const toolCards = context.querySelectorAll('.mga-tool-card');
      toolCards.forEach(card => {
        card.addEventListener('click', () => {
          const calculatorType = card.dataset.calculator;
          const url = calculatorUrls[calculatorType];
          if (url) {
            openCalculatorPopup(url, calculatorType);
          } else {
            productionWarn(`Calculator URL not found for: ${calculatorType}`);
          }
        });

        // Add hover effect class if not already present
        if (!card.classList.contains('mga-tool-interactive')) {
          card.classList.add('mga-tool-interactive');
        }
      });

      // Add click handlers to all wiki cards
      const wikiCards = context.querySelectorAll('.mga-wiki-card');
      wikiCards.forEach(card => {
        card.addEventListener('click', () => {
          const wikiType = card.dataset.wiki;
          const url = wikiUrls[wikiType];
          if (url) {
            openWikiPopup(url, wikiType);
          } else {
            productionWarn(`Wiki URL not found for: ${wikiType}`);
          }
        });

        // Add hover effect class if not already present
        if (!card.classList.contains('mga-wiki-interactive')) {
          card.classList.add('mga-wiki-interactive');
        }
      });

      // Hide Weather checkbox
      const hideWeatherCheckbox = context.querySelector('#hide-weather-checkbox');
      productionLog('üåßÔ∏è [WEATHER-DEBUG] Setting up weather checkbox handler', {
        found: !!hideWeatherCheckbox,
        hasHandler: hideWeatherCheckbox?.hasAttribute('data-handler-setup')
      });

      if (hideWeatherCheckbox && !hideWeatherCheckbox.hasAttribute('data-handler-setup')) {
        hideWeatherCheckbox.setAttribute('data-handler-setup', 'true');
        hideWeatherCheckbox.addEventListener('change', e => {
          productionLog(`üåßÔ∏è [WEATHER] Checkbox changed to: ${e.target.checked}`);
          UnifiedState.data.settings.hideWeather = e.target.checked;
          MGA_saveJSON('MGA_data', UnifiedState.data);
          applyWeatherSetting();
          productionLog(`üåßÔ∏è [WEATHER] Weather effects ${e.target.checked ? 'hidden' : 'shown'}`);
        });
        productionLog('üåßÔ∏è [WEATHER-DEBUG] Event listener attached successfully');
      } else if (hideWeatherCheckbox) {
        productionLog('üåßÔ∏è [WEATHER-DEBUG] Checkbox already has handler, skipping');
      } else {
        productionLog('üåßÔ∏è [WEATHER-DEBUG] Checkbox element not found!');
      }

      // Crop highlighting handlers
      const applyHighlightingBtn = context.querySelector('#apply-highlighting-btn');
      if (applyHighlightingBtn) {
        applyHighlightingBtn.addEventListener('click', () => {
          applyCropHighlighting();
        });
      }

      const clearHighlightingBtn = context.querySelector('#clear-highlighting-btn');
      if (clearHighlightingBtn) {
        clearHighlightingBtn.addEventListener('click', () => {
          clearCropHighlighting();
        });
      }

      if (UnifiedState.data.settings.debugMode) {
        productionLog(
          `üßÆ Set up handlers for ${toolCards.length} calculator tools and ${wikiCards.length} wiki resources`
        );
      }
    }

    function openCalculatorPopup(url, calculatorType) {
      // Calculate window dimensions and position
      const width = 1200;
      const height = 800;
      const left = (window.screen.width - width) / 2;
      const top = (window.screen.height - height) / 2;

      // Window features
      const features = `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes,status=yes`;

      // Open the popup window
      const popupWindow = window.open(url, `mga_calculator_${calculatorType}`, features);

      // Check if popup was blocked
      if (!popupWindow || popupWindow.closed || typeof popupWindow.closed === 'undefined') {
        // Popup was blocked, show alternative message
        const message = `
                  <div style="padding: 20px; background: rgba(255, 50, 50, 0.30); border: 1px solid rgba(255,100,100,0.3); border-radius: 5px; margin: 20px;">
                      <h3 style="color: #ff6b6b; margin-bottom: 10px;">‚ö†Ô∏è Popup Blocked</h3>
                      <p style="margin-bottom: 15px;">The calculator popup was blocked by your browser. Please allow popups for this site or open the calculator manually:</p>
                      <div style="background: rgba(0, 0, 0, 0.48); padding: 10px; border-radius: 3px; word-break: break-all;">
                          <a href="${url}" target="_blank" style="color: #4fc3f7;">${url}</a>
                      </div>
                      <p style="margin-top: 10px; font-size: 0.9em; color: rgba(255,255,255,0.6);">
                          Click the link above to open the calculator in a new tab.
                      </p>
                  </div>
              `;

        // Show message in the Tools tab content area
        const contentEl = document.getElementById('mga-tab-content');
        if (contentEl && UnifiedState.activeTab === 'tools') {
          const existingContent = contentEl.innerHTML;
          contentEl.innerHTML = message + existingContent;

          // Remove the message after 10 seconds
          setTimeout(() => {
            if (contentEl.innerHTML.includes(message)) {
              contentEl.innerHTML = existingContent;
            }
          }, 10000);
        }

        productionWarn(`Popup blocked for calculator: ${calculatorType}. URL: ${url}`);
      } else {
        // Popup opened successfully
        popupWindow.focus();
        productionLog(`‚úÖ Opened calculator popup: ${calculatorType}`);
      }
    }

    function openWikiPopup(url, wikiType) {
      // Calculate window dimensions and position
      const width = 1000;
      const height = 900;
      const left = (window.screen.width - width) / 2;
      const top = (window.screen.height - height) / 2;

      // Window features
      const features = `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes,status=yes`;

      // Open the popup window
      const popupWindow = window.open(url, `mga_wiki_${wikiType}`, features);

      // Check if popup was blocked
      if (!popupWindow || popupWindow.closed || typeof popupWindow.closed === 'undefined') {
        // Popup was blocked, show alternative message
        const message = `
                  <div style="padding: 20px; background: rgba(255, 50, 50, 0.30); border: 1px solid rgba(255,100,100,0.3); border-radius: 5px; margin: 20px;">
                      <h3 style="color: #ff6b6b; margin-bottom: 10px;">‚ö†Ô∏è Popup Blocked</h3>
                      <p style="margin-bottom: 15px;">The wiki popup was blocked by your browser. Please allow popups for this site or open the wiki manually:</p>
                      <div style="background: rgba(0, 0, 0, 0.48); padding: 10px; border-radius: 3px; word-break: break-all;">
                          <a href="${url}" target="_blank" style="color: #4fc3f7;">${url}</a>
                      </div>
                      <p style="margin-top: 10px; font-size: 0.9em; color: rgba(255,255,255,0.6);">
                          Click the link above to open the wiki page in a new tab.
                      </p>
                  </div>
              `;

        // Show message in the Tools tab content area
        const contentEl = document.getElementById('mga-tab-content');
        if (contentEl && UnifiedState.activeTab === 'tools') {
          const existingContent = contentEl.innerHTML;
          contentEl.innerHTML = message + existingContent;

          // Remove the message after 10 seconds
          setTimeout(() => {
            if (contentEl.innerHTML.includes(message)) {
              contentEl.innerHTML = existingContent;
            }
          }, 10000);
        }

        productionWarn(`Popup blocked for wiki: ${wikiType}. URL: ${url}`);
      } else {
        // Popup opened successfully
        popupWindow.focus();
        productionLog(`‚úÖ Opened wiki popup: ${wikiType}`);
      }
    }

    // ==================== CROP HIGHLIGHTING UTILITIES ====================
    // Initialize tile override storage
    window.__tileOverrides = window.__tileOverrides || {};
    window.__slotTargetOverrides = window.__slotTargetOverrides || {};

    // Tile-modifying hookAtom function (different from monitoring hookAtom)
    function hookAtomForTileOverrides(atomPath, windowKey) {
      const atom = targetWindow.jotaiAtomCache?.get(atomPath);
      if (!atom?.read) {
        productionWarn(`üîç Could not find atom at path: ${atomPath}`);
        return;
      }

      if (!atom.__originalRead) {
        atom.__originalRead = atom.read;
        productionLog(`üîó Hooked atom for tile overrides: ${atomPath}`);

        atom.read = t => {
          const value = atom.__originalRead(t);

          try {
            const tileObjects = value?.data?.garden?.tileObjects || value?.garden?.tileObjects;

            if (tileObjects != null) {
              let overridesApplied = 0;
              const applyOverrideToTile = (tileIndex, tileObj) => {
                if (!tileObj || typeof tileObj !== 'object') return;

                let wasModified = false;

                // Species override
                if (window.__tileOverrides[tileIndex] !== undefined) {
                  const oldSpecies = tileObj.species;
                  tileObj.species = window.__tileOverrides[tileIndex];
                  wasModified = true;
                  if (UnifiedState.data.settings.debugMode) {
                    productionLog(`üîÑ Tile ${tileIndex}: ${oldSpecies} ‚Üí ${tileObj.species}`);
                  }
                }

                // Slot targetScale override
                if (window.__slotTargetOverrides[tileIndex] !== undefined) {
                  const slots = tileObj.slots;
                  const slotOverrides = window.__slotTargetOverrides[tileIndex];
                  if (slots) {
                    for (const [slotIdx, scale] of Object.entries(slotOverrides)) {
                      if (slots[slotIdx] && typeof slots[slotIdx] === 'object') {
                        const oldScale = slots[slotIdx].targetScale;
                        slots[slotIdx].targetScale = scale;
                        wasModified = true;
                        if (UnifiedState.data.settings.debugMode) {
                          productionLog(`üîÑ Tile ${tileIndex} slot ${slotIdx}: scale ${oldScale} ‚Üí ${scale}`);
                        }
                      }
                    }
                  }
                }

                if (wasModified) overridesApplied++;
              };

              // Apply overrides to all tiles
              if (Array.isArray(tileObjects)) {
                tileObjects.forEach((tile, idx) => applyOverrideToTile(idx, tile));
              } else if (tileObjects instanceof Map) {
                tileObjects.forEach((tile, key) => applyOverrideToTile(key, tile));
              } else if (typeof tileObjects === 'object') {
                Object.keys(tileObjects).forEach(key => {
                  const idx = isFinite(key) ? Number(key) : key;
                  applyOverrideToTile(idx, tileObjects[key]);
                });
              }

              if (overridesApplied > 0) {
                productionLog(`üå± Applied ${overridesApplied} tile overrides in atom read`);
              }
            }
          } catch (err) {
            console.error('hookAtomForTileOverrides: error applying tile overrides', err);
          }

          // Expose full value for console inspection (extract .data if present for myUserSlotAtom)
          try {
            window[windowKey] = value?.data || value;
          } catch (e) {}

          return value;
        };
      } else {
        productionLog(`‚ö†Ô∏è Atom already hooked: ${atomPath}`);
      }
    }

    // Tile override utility functions (MGA namespaced to prevent conflicts)
    window.MGA_Internal.setTileSpecies = function (index, species) {
      if (species == null) {
        delete window.__tileOverrides[index];
      } else {
        window.__tileOverrides[index] = species;
      }
    };

    window.MGA_Internal.setTileSlotTargetScale = function (tileIndex, slotIndex, targetScale) {
      if (!window.__slotTargetOverrides[tileIndex]) {
        window.__slotTargetOverrides[tileIndex] = {};
      }
      if (targetScale == null) {
        delete window.__slotTargetOverrides[tileIndex][slotIndex];
      } else {
        window.__slotTargetOverrides[tileIndex][slotIndex] = targetScale;
      }
    };

    window.MGA_Internal.removeTileOverrides = function (tileIndex) {
      delete window.__tileOverrides[tileIndex];
      delete window.__slotTargetOverrides[tileIndex];
    };

    window.MGA_Internal.removeAllTileOverrides = function () {
      window.__tileOverrides = {};
      window.__slotTargetOverrides = {};
    };

    // Advanced tile filtering functions
    window.applyToAllTilesExcept = function (
      skipSpecies = 'Starweaver',
      slotIndex = 0,
      targetScale = 0.1,
      newSpecies = null
    ) {
      const tileObjects = window.gardenInfo?.garden?.tileObjects;
      if (!tileObjects) return;

      const entries = Array.isArray(tileObjects)
        ? tileObjects.map((t, i) => ({ tile: t, index: i }))
        : tileObjects instanceof Map
          ? Array.from(tileObjects.entries()).map(([k, v]) => ({ tile: v, index: k }))
          : Object.keys(tileObjects).map(k => ({ tile: tileObjects[k], index: isFinite(k) ? Number(k) : k }));

      entries.forEach(({ tile, index }) => {
        if (!tile || tile.species === skipSpecies) return;
        if (newSpecies != null) window.setTileSpecies(index, newSpecies);
        if (targetScale != null) window.setTileSlotTargetScale(index, slotIndex, targetScale);
      });
    };

    window.applyToAllTilesFiltered = function ({
      skipSpecies = 'Starweaver',
      slotIndex = 0,
      targetScale = 0.1,
      newSpecies = null,
      mutationFilter = null // function(slotMutations) => true/false
    } = {}) {
      const tileObjects = window.gardenInfo?.garden?.tileObjects;
      if (!tileObjects) return;

      const entries = Array.isArray(tileObjects)
        ? tileObjects.map((t, i) => ({ tile: t, index: i }))
        : tileObjects instanceof Map
          ? Array.from(tileObjects.entries()).map(([k, v]) => ({ tile: v, index: k }))
          : Object.keys(tileObjects).map(k => ({ tile: tileObjects[k], index: isFinite(k) ? Number(k) : k }));

      entries.forEach(({ tile, index }) => {
        if (!tile || tile.species === skipSpecies) return;

        const slot = tile.slots?.[slotIndex];
        if (!slot) return;

        // Skip if mutationFilter is defined and returns false
        if (mutationFilter && !mutationFilter(slot.mutations)) return;

        if (newSpecies != null) window.setTileSpecies(index, newSpecies);
        if (targetScale != null) window.setTileSlotTargetScale(index, slotIndex, targetScale);
      });
    };

    // Main crop highlighting function
    window.highlightTilesByMutation = function ({
      highlightSpecies = null, // string or array of species
      highlightMutations = [], // array of mutations to match
      slotIndex = 0,
      highlightScale = null, // null = keep original
      hiddenSpecies = 'Carrot',
      hiddenScale = 0.1
    } = {}) {
      const tileObjects = window.gardenInfo?.garden?.tileObjects;
      if (!tileObjects) return;

      const entries = Array.isArray(tileObjects)
        ? tileObjects.map((t, i) => ({ tile: t, index: i }))
        : tileObjects instanceof Map
          ? Array.from(tileObjects.entries()).map(([k, v]) => ({ tile: v, index: k }))
          : Object.keys(tileObjects).map(k => ({ tile: tileObjects[k], index: isFinite(k) ? Number(k) : k }));

      // Normalize species array
      const speciesArr = Array.isArray(highlightSpecies)
        ? highlightSpecies
        : highlightSpecies
          ? [highlightSpecies]
          : [];

      entries.forEach(({ tile, index }) => {
        if (!tile) return;

        const slot = tile.slots?.[slotIndex];
        if (!slot) return;

        const mutations = slot.mutations || [];

        // Highlight if species is in the array
        const matchesSpecies = speciesArr.length === 0 || speciesArr.includes(tile.species);
        const matchesMutations =
          !highlightMutations ||
          highlightMutations.length === 0 ||
          highlightMutations.includes(null) ||
          highlightMutations.some(m => mutations.includes(m)) ||
          highlightMutations.every(m => mutations.includes(m));

        if (matchesSpecies && matchesMutations) {
          if (highlightScale != null) window.setTileSlotTargetScale(index, slotIndex, highlightScale);
          if (highlightSpecies) window.setTileSpecies(index, tile.species); // keep species unchanged
        } else {
          if (hiddenScale != null) window.setTileSlotTargetScale(index, slotIndex, hiddenScale);
          window.setTileSpecies(index, hiddenSpecies);
        }
      });
    };

    // Initialize crop highlighting atoms hooks when utilities are loaded
    function initializeCropHighlightingAtoms() {
      if (!targetWindow.jotaiAtomCache) {
        // Wait for jotaiAtomCache to be available
        setTimeout(initializeCropHighlightingAtoms, 1000);
        return;
      }

      try {
        hookAtomForTileOverrides(
          '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/baseAtoms.ts/myUserSlotAtom',
          'gardenInfo'
        );
        hookAtomForTileOverrides(
          '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom',
          'currentCrop'
        );
        debugLog('CROP_HIGHLIGHT', 'Crop highlighting atom hooks initialized');
      } catch (error) {
        debugError('CROP_HIGHLIGHT', 'Failed to initialize crop highlighting atoms', error);
      }
    }

    // Track the last highlighted species for toggle functionality
    window.__lastHighlightedSpecies = null;

    // Initialize the crop highlighting atom hooks
    initializeCropHighlightingAtoms();

    // ==================== CROP HIGHLIGHTING SYSTEM ====================
    function clearCropHighlighting() {
      try {
        if (typeof window.removeAllTileOverrides === 'function') {
          window.removeAllTileOverrides();
          productionLog('üå± Cleared all crop highlighting');
          queueNotification('üßπ Cleared all crop highlighting', false);
          debugLog('CROP_HIGHLIGHTING', 'Cleared all tile overrides');
          return true;
        } else {
          productionWarn('üå± removeAllTileOverrides function not available');
          queueNotification('‚ö†Ô∏è Cannot clear highlighting - game not fully loaded', false);
          debugLog('CROP_HIGHLIGHTING', 'removeAllTileOverrides function not found in window object');
          return false;
        }
      } catch (error) {
        debugError('CROP_HIGHLIGHTING', 'Failed to clear crop highlighting', error);
      }
    }

    // Debug function to check garden data availability
    function debugCropHighlighting() {
      productionLog('üîç CROP HIGHLIGHTING DEBUG:');
      productionLog('  window.gardenInfo:', !!window.gardenInfo);
      productionLog('  window.currentCrop:', !!window.currentCrop);
      productionLog('  targetWindow.jotaiAtomCache:', !!targetWindow.jotaiAtomCache);

      if (window.gardenInfo?.garden?.tileObjects) {
        const tileObjects = window.gardenInfo.garden.tileObjects;
        const tileCount = Array.isArray(tileObjects)
          ? tileObjects.length
          : tileObjects instanceof Map
            ? tileObjects.size
            : Object.keys(tileObjects).length;
        productionLog('  Garden tiles available:', tileCount);

        // Show first few tiles for debugging
        if (Array.isArray(tileObjects) && tileObjects.length > 0) {
          productionLog('  Sample tile:', tileObjects[0]);
        }
      } else {
        productionLog('  ‚ùå No garden tile data available');
      }

      if (window.currentCrop && Array.isArray(window.currentCrop) && window.currentCrop.length > 0) {
        productionLog('  Current crop species:', window.currentCrop[0]?.species);
      } else {
        productionLog('  ‚ùå No current crop data available');
      }

      productionLog('  Available functions:');
      productionLog('    removeAllTileOverrides:', typeof window.removeAllTileOverrides);
      productionLog('    highlightTilesByMutation:', typeof window.highlightTilesByMutation);
      productionLog('    setTileSpecies:', typeof window.setTileSpecies);
    }

    // Improved manual highlighting with better debugging and error handling
    function applyCropHighlightingWithDebug() {
      productionLog('üå± Starting crop highlighting...');
      debugCropHighlighting();

      try {
        // Get values from UI
        const highlightSpecies = targetDocument.querySelector('#highlight-species-select')?.value || null;
        const slotIndex = parseInt(targetDocument.querySelector('#highlight-slot-input')?.value || '0');
        const hiddenSpecies = targetDocument.querySelector('#hidden-species-select')?.value || 'Carrot';
        const hiddenScale = parseFloat(targetDocument.querySelector('#hidden-scale-input')?.value || '0.1');

        productionLog('üå± Settings:', { highlightSpecies, slotIndex, hiddenSpecies, hiddenScale });

        // Validate inputs
        if (!highlightSpecies) {
          productionWarn('üå± No species selected for highlighting');
          queueNotification('‚ö†Ô∏è Please select a species to highlight first', false);
          return false;
        }

        // Check if required game functions are available
        const hasRemoveOverrides = typeof window.removeAllTileOverrides === 'function';
        const hasHighlightFunction = typeof window.highlightTilesByMutation === 'function';

        productionLog('üå± Function availability:', {
          removeAllTileOverrides: hasRemoveOverrides,
          highlightTilesByMutation: hasHighlightFunction
        });

        if (!hasHighlightFunction) {
          productionWarn('üå± Crop highlighting function not available - game may not be loaded yet');
          queueNotification('‚ö†Ô∏è Crop highlighting not available - try again when fully loaded', false);
          return false;
        }

        // Always clear previous highlights first
        if (hasRemoveOverrides) {
          window.removeAllTileOverrides();
          productionLog('üå± Cleared previous highlights');
        }

        // Apply new highlighting with array format
        const config = {
          highlightSpecies: [highlightSpecies], // Convert to array like working reference
          highlightMutations: [null], // Default to no mutation filter
          slotIndex: slotIndex,
          highlightScale: null, // Let the system decide
          hiddenSpecies: hiddenSpecies,
          hiddenScale: hiddenScale
        };

        productionLog('üå± Applying config:', config);

        try {
          window.highlightTilesByMutation(config);
          productionLog(`‚úÖ Applied crop highlighting for ${highlightSpecies} (slot ${slotIndex})`);
          queueNotification(`üå± Highlighted all ${highlightSpecies} crops (slot ${slotIndex})`, false);

          // Force a re-render by triggering a small change
          setTimeout(() => {
            productionLog('üîÑ Forcing render update...');
            try {
              globalThis.dispatchEvent?.(new Event('visibilitychange'));
            } catch (e) {
              productionLog('Could not dispatch visibility change:', e);
            }
          }, 100);

          return true;
        } catch (highlightError) {
          productionError('üå± Error during highlighting:', highlightError);
          queueNotification(`‚ùå Crop highlighting failed: ${highlightError.message}`, false);
          return false;
        }
      } catch (error) {
        productionError('‚ùå Failed to apply crop highlighting:', error);
        queueNotification(`‚ùå Crop highlighting system error: ${error.message}`, false);
        return false;
      }
    }

    // Automatic highlighting with Ctrl+C (from working reference)
    function setupAutomaticCropHighlighting() {
      window.addEventListener('keydown', function (e) {
        // Ignore when typing in input fields
        const active = document.activeElement;
        if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;

        // Ctrl (or Cmd) + C for automatic highlighting
        if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'C')) {
          try {
            const cc = window.currentCrop;

            window.removeAllTileOverrides(); // always clear first
            productionLog('üå± Ctrl+C: Cleared previous highlights');

            if (cc && Array.isArray(cc) && cc.length > 0 && cc[0] && cc[0].species) {
              const species = cc[0].species;

              if (window.__lastHighlightedSpecies === species) {
                // Same species pressed twice ‚Üí just clear
                productionLog(`üå± Ctrl+C: Removed highlights (${species} was already highlighted)`);
                window.__lastHighlightedSpecies = null;
              } else {
                // New species ‚Üí highlight it after delay
                setTimeout(() => {
                  window.highlightTilesByMutation({
                    highlightSpecies: [species],
                    highlightMutations: [null],
                    slotIndex: 0,
                    highlightScale: null,
                    hiddenSpecies: 'Carrot',
                    hiddenScale: 0.1
                  });
                  productionLog(`‚úÖ Ctrl+C: Highlighted current crop: ${species}`);
                  window.__lastHighlightedSpecies = species;
                }, 350);
              }
            } else {
              // currentCrop is null or invalid ‚Üí just clear
              productionLog('üå± Ctrl+C: No current crop - highlights cleared');
              window.__lastHighlightedSpecies = null;
            }

            e.preventDefault(); // block normal copy
          } catch (err) {
            console.error('‚ùå Error handling Ctrl+C highlight action', err);
          }
        }
      });

      productionLog('üå± Automatic crop highlighting installed (Ctrl+C)');
    }

    // Replace the original applyCropHighlighting with the debug version
    applyCropHighlighting = applyCropHighlightingWithDebug;

    // Install automatic highlighting
    setupAutomaticCropHighlighting();

    // ==================== GLOBAL DEBUGGING FUNCTIONS ====================
    // Make debugging functions globally accessible
    window.debugCropHighlighting = debugCropHighlighting;
    window.applyCropHighlightingWithDebug = applyCropHighlightingWithDebug;

    // BUGFIX: Add ability log verification command
    window.MGA_AbilityLogDebug = {
      checkLogs: function () {
        const allLogs = MGA_getAllLogs();
        const oldLogs = allLogs.filter(log => log.abilityType && /produce\s*scale\s*boost/i.test(log.abilityType));
        const newLogs = allLogs.filter(log => log.abilityType && /crop\s*size\s*boost/i.test(log.abilityType));

        console.log('=== ABILITY LOG VERIFICATION ===');
        console.log('Old "Produce Scale Boost" logs:', oldLogs.length);
        if (oldLogs.length > 0) {
          console.warn('‚ö†Ô∏è Found unmigrated logs - migration may need to run again');
          console.log('Sample old logs:', oldLogs.slice(0, 3));
        }
        console.log('New "Crop Size Boost" logs:', newLogs.length);
        console.log('Total logs:', allLogs.length);
        console.log('============================');

        return { oldCount: oldLogs.length, newCount: newLogs.length, total: allLogs.length };
      },
      listAllAbilities: function () {
        const allLogs = MGA_getAllLogs();
        const abilityTypes = [...new Set(allLogs.map(log => log.abilityType))].sort();
        console.log('=== ALL UNIQUE ABILITIES IN LOGS ===');
        abilityTypes.forEach((ability, i) => {
          const count = allLogs.filter(log => log.abilityType === ability).length;
          console.log(`${i + 1}. ${ability} (${count} logs)`);
        });
        console.log('===================================');
        return abilityTypes;
      }
    };

    window.MGA_CropDebug = {
      debug: debugCropHighlighting,
      apply: applyCropHighlightingWithDebug,
      clear: clearCropHighlighting,
      testHighlight: function (species = 'Aloe') {
        productionLog(`üß™ Testing highlight for ${species}...`);
        if (typeof window.removeAllTileOverrides === 'function') {
          window.removeAllTileOverrides();
        }
        setTimeout(() => {
          if (typeof window.highlightTilesByMutation === 'function') {
            window.highlightTilesByMutation({
              highlightSpecies: [species],
              highlightMutations: [null],
              slotIndex: 0,
              highlightScale: null,
              hiddenSpecies: 'Carrot',
              hiddenScale: 0.1
            });
            productionLog(`‚úÖ Test highlight applied for ${species}`);
          } else {
            console.error('‚ùå highlightTilesByMutation not available');
          }
        }, 100);
      },
      listAvailableSpecies: function () {
        if (window.gardenInfo?.garden?.tileObjects) {
          const tileObjects = window.gardenInfo.garden.tileObjects;
          const species = new Set();

          const entries = Array.isArray(tileObjects)
            ? tileObjects
            : tileObjects instanceof Map
              ? Array.from(tileObjects.values())
              : Object.values(tileObjects);

          entries.forEach(tile => {
            if (tile?.species) species.add(tile.species);
          });

          productionLog('üå± Available species in your garden:', Array.from(species));
          return Array.from(species);
        } else {
          productionLog('‚ùå No garden data available');
          return [];
        }
      },
      checkFunctions: function () {
        productionLog('üîç Crop highlighting function status:');
        productionLog('  removeAllTileOverrides:', typeof window.removeAllTileOverrides);
        productionLog('  highlightTilesByMutation:', typeof window.highlightTilesByMutation);
        productionLog('  setTileSpecies:', typeof window.setTileSpecies);
        productionLog('  setTileSlotTargetScale:', typeof window.setTileSlotTargetScale);
        productionLog('  gardenInfo available:', !!window.gardenInfo);
        productionLog('  currentCrop available:', !!window.currentCrop);
      },
      forceRefresh: function () {
        productionLog('üîÑ Forcing multiple refresh attempts...');

        // Method 1: Visibility change
        try {
          globalThis.dispatchEvent?.(new Event('visibilitychange'));
          productionLog('‚úÖ Triggered visibilitychange event');
        } catch (e) {
          productionLog('‚ùå Could not trigger visibilitychange');
        }

        // Method 2: Focus events
        try {
          window.dispatchEvent(new Event('focus'));
          window.dispatchEvent(new Event('blur'));
          window.dispatchEvent(new Event('focus'));
          productionLog('‚úÖ Triggered focus/blur events');
        } catch (e) {
          productionLog('‚ùå Could not trigger focus events');
        }

        // Method 3: Resize event
        try {
          window.dispatchEvent(new Event('resize'));
          productionLog('‚úÖ Triggered resize event');
        } catch (e) {
          productionLog('‚ùå Could not trigger resize');
        }

        // Method 4: Force re-hook atoms
        setTimeout(() => {
          productionLog('üîÑ Re-hooking atoms...');
          if (targetWindow.jotaiAtomCache) {
            hookAtomForTileOverrides(
              '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/baseAtoms.ts/myUserSlotAtom',
              'gardenInfo'
            );
            hookAtomForTileOverrides(
              '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom',
              'currentCrop'
            );
          }
        }, 100);

        // Method 5: Mouse movement simulation
        try {
          const mouseEvent = new MouseEvent('mousemove', {
            view: window,
            bubbles: true,
            cancelable: true,
            clientX: window.innerWidth / 2,
            clientY: window.innerHeight / 2
          });
          document.dispatchEvent(mouseEvent);
          productionLog('‚úÖ Triggered mouse movement');
        } catch (e) {
          productionLog('‚ùå Could not trigger mouse movement');
        }
      },
      inspectOverrides: function () {
        productionLog('üîç Current tile overrides:');
        productionLog('  Species overrides:', window.__tileOverrides);
        productionLog('  Scale overrides:', window.__slotTargetOverrides);

        const speciesCount = Object.keys(window.__tileOverrides || {}).length;
        const scaleCount = Object.keys(window.__slotTargetOverrides || {}).length;
        productionLog(`  Total overrides: ${speciesCount} species, ${scaleCount} scales`);

        if (speciesCount > 0) {
          productionLog('üìã Sample species overrides:');
          Object.entries(window.__tileOverrides)
            .slice(0, 5)
            .forEach(([index, species]) => {
              productionLog(`    Tile ${index} ‚Üí ${species}`);
            });
        }
      },
      enableDebugMode: function () {
        UnifiedState.data.settings.debugMode = true;
        productionLog('üêõ Debug mode enabled - you will see detailed tile modification logs');
      },
      disableDebugMode: function () {
        UnifiedState.data.settings.debugMode = false;
        productionLog('üîá Debug mode disabled');
      },
      strongRefresh: function () {
        productionLog('üí™ Attempting strong refresh with multiple methods...');
        this.forceRefresh();

        // Wait and try again
        setTimeout(() => {
          productionLog('üîÑ Second refresh wave...');
          this.forceRefresh();

          // Try direct garden access
          setTimeout(() => {
            if (window.gardenInfo?.garden?.tileObjects) {
              productionLog('üéØ Triggering direct garden re-read...');
              const tileObjects = window.gardenInfo.garden.tileObjects;
              const count = Array.isArray(tileObjects)
                ? tileObjects.length
                : tileObjects instanceof Map
                  ? tileObjects.size
                  : Object.keys(tileObjects).length;
              productionLog(`üìä Garden has ${count} tiles - forcing re-process...`);

              // Force a property access that might trigger re-rendering
              try {
                if (Array.isArray(tileObjects)) {
                  tileObjects.forEach((tile, idx) => {
                    if (tile) {
                      const _ = tile.species; // Force property access
                      const __ = tile.slots; // Force slots access
                    }
                  });
                }
                productionLog('‚úÖ Forced tile property access complete');
              } catch (e) {
                productionLog('‚ùå Could not force tile access:', e);
              }
            }
          }, 200);
        }, 500);
      }
    };

    // Backward compatibility aliases to prevent conflicts with other scripts
    // These key functions are exposed with MGA_ prefix to coexist with other mods
    window.MGA_removeAllTileOverrides = window.MGA_Internal.removeAllTileOverrides;
    window.MGA_highlightTilesByMutation = window.highlightTilesByMutation;
    window.MGA_setTileSpecies = window.MGA_Internal.setTileSpecies;
    window.MGA_setTileSlotTargetScale = window.MGA_Internal.setTileSlotTargetScale;

    // For scripts that might still depend on the global names, check if they exist
    // If not (meaning no conflict), provide them. If they do exist, skip to avoid conflicts.
    if (typeof window.removeAllTileOverrides !== 'function') {
      window.removeAllTileOverrides = window.MGA_Internal.removeAllTileOverrides;
    }
    if (typeof window.setTileSpecies !== 'function') {
      window.setTileSpecies = window.MGA_Internal.setTileSpecies;
    }
    if (typeof window.setTileSlotTargetScale !== 'function') {
      window.setTileSlotTargetScale = window.MGA_Internal.setTileSlotTargetScale;
    }

    productionLog('üå± Crop highlighting debugging tools installed:');
    productionLog('  ‚Ä¢ debugCropHighlighting() - Full diagnostic');
    productionLog('  ‚Ä¢ MGA_CropDebug.debug() - Same as above');
    productionLog('  ‚Ä¢ MGA_CropDebug.testHighlight("Aloe") - Test highlighting');
    productionLog('  ‚Ä¢ MGA_CropDebug.listAvailableSpecies() - See what you have');
    productionLog('  ‚Ä¢ MGA_CropDebug.checkFunctions() - Verify functions exist');
    productionLog('  ‚Ä¢ MGA_CropDebug.clear() - Clear all highlights');
    productionLog('  üîß Advanced debugging:');
    productionLog('  ‚Ä¢ MGA_CropDebug.inspectOverrides() - See current overrides');
    productionLog('  ‚Ä¢ MGA_CropDebug.enableDebugMode() - Detailed tile logs');
    productionLog('  ‚Ä¢ MGA_CropDebug.forceRefresh() - Force game refresh');
    productionLog('  ‚Ä¢ MGA_CropDebug.strongRefresh() - Aggressive refresh');

    function applyPreset(preset) {
      const settings = UnifiedState.data.settings;

      switch (preset) {
        case 'gaming':
          settings.opacity = 85;
          settings.gradientStyle = 'red-orange';
          settings.effectStyle = 'neon';
          break;
        case 'minimal':
          settings.opacity = 70;
          settings.gradientStyle = 'blue-purple';
          settings.effectStyle = 'glass';
          break;
        case 'vibrant':
          settings.opacity = 95;
          settings.gradientStyle = 'purple-pink';
          settings.effectStyle = 'neon';
          break;
        case 'dark':
          settings.opacity = 90;
          settings.gradientStyle = 'blue-purple';
          settings.effectStyle = 'metallic';
          break;
        case 'luxury':
          settings.opacity = 88;
          settings.gradientStyle = 'gold-yellow';
          settings.effectStyle = 'metallic';
          break;
        case 'steel':
          settings.opacity = 92;
          settings.gradientStyle = 'steel-blue';
          settings.effectStyle = 'steel';
          break;
        case 'chrome':
          settings.opacity = 85;
          settings.gradientStyle = 'chrome-silver';
          settings.effectStyle = 'chrome';
          break;
        case 'titanium':
          settings.opacity = 90;
          settings.gradientStyle = 'titanium-gray';
          settings.effectStyle = 'titanium';
          break;
        case 'reset':
          settings.opacity = 95;
          settings.gradientStyle = 'blue-purple';
          settings.effectStyle = 'none';
          break;
      }

      applyTheme();
      updateTabContent(); // Refresh the settings tab
      MGA_saveJSON('MGA_data', UnifiedState.data);
    }

    // Universal theme generation function with dual opacity support
    function generateThemeStyles(settings = UnifiedState.data.settings, isPopout = false) {
      // Use different opacity based on window type
      const opacity = isPopout ? settings.popoutOpacity / 100 : settings.opacity / 100;

      // Use actual opacity value (0.0 to 1.0)
      const effectiveOpacity = opacity;

      // Define gradient styles - ALL themes now use effectiveOpacity for true 100% support
      const gradients = {
        // ‚ö´ BLACK ACCENT THEMES (Solid backgrounds with vibrant accent colors)
        'black-crimson':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(26, 0, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-emerald':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 26, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-royal':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(13, 0, 21, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-gold':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(26, 20, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-ice':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 13, 26, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-flame':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(26, 13, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-toxic':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(10, 26, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-pink':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(26, 0, 20, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-matrix':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 17, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-sunset':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(26, 10, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-blood':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(40, 0, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-neon':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 20, 30, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-storm':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(10, 0, 30, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-sapphire':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 10, 40, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-aqua':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 25, 25, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-phantom':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(20, 20, 20, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-void':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(10, 10, 10, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-violet':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(20, 0, 30, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-amber':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(30, 22, 0, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-jade':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 20, 15, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-coral':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(30, 15, 10, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-steel':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(10, 20, 25, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-lavender':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(20, 15, 25, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-mint':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(5, 20, 15, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-ruby':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(30, 0, 10, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-cobalt':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 10, 25, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-bronze':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(25, 15, 8, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-teal':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(0, 18, 18, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-magenta':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(25, 0, 25, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-lime':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(8, 25, 8, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',
        'black-indigo':
          'linear-gradient(135deg, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 0%, rgba(10, 0, 20, ' +
          effectiveOpacity +
          ') 50%, rgba(0, 0, 0, ' +
          effectiveOpacity +
          ') 100%)',

        // üåà ORIGINAL THEMES
        'blue-purple':
          'linear-gradient(135deg, rgba(20, 20, 35, ' +
          effectiveOpacity +
          ') 0%, rgba(30, 30, 50, ' +
          effectiveOpacity +
          ') 100%)',
        'green-blue':
          'linear-gradient(135deg, rgba(20, 35, 20, ' +
          effectiveOpacity +
          ') 0%, rgba(30, 40, 60, ' +
          effectiveOpacity +
          ') 100%)',
        'red-orange':
          'linear-gradient(135deg, rgba(35, 20, 20, ' +
          effectiveOpacity +
          ') 0%, rgba(50, 35, 30, ' +
          effectiveOpacity +
          ') 100%)',
        'purple-pink':
          'linear-gradient(135deg, rgba(35, 20, 35, ' +
          effectiveOpacity +
          ') 0%, rgba(50, 30, 45, ' +
          effectiveOpacity +
          ') 100%)',
        'gold-yellow':
          'linear-gradient(135deg, rgba(35, 30, 20, ' +
          effectiveOpacity +
          ') 0%, rgba(45, 40, 25, ' +
          effectiveOpacity +
          ') 100%)',
        // New vibrant gradients - using effectiveOpacity for better high-level opacity
        'electric-neon':
          'linear-gradient(135deg, rgba(0, 100, 255, ' +
          effectiveOpacity * 0.3 +
          ') 0%, rgba(147, 51, 234, ' +
          effectiveOpacity * 0.4 +
          ') 100%)',
        'sunset-fire':
          'linear-gradient(135deg, rgba(255, 94, 77, ' +
          effectiveOpacity * 0.3 +
          ') 0%, rgba(255, 154, 0, ' +
          effectiveOpacity * 0.4 +
          ') 100%)',
        'emerald-cyan':
          'linear-gradient(135deg, rgba(16, 185, 129, ' +
          effectiveOpacity * 0.3 +
          ') 0%, rgba(6, 182, 212, ' +
          effectiveOpacity * 0.4 +
          ') 100%)',
        'royal-gold':
          'linear-gradient(135deg, rgba(139, 69, 19, ' +
          effectiveOpacity * 0.4 +
          ') 0%, rgba(255, 215, 0, ' +
          effectiveOpacity * 0.3 +
          ') 100%)',
        'crimson-blaze':
          'linear-gradient(135deg, rgba(220, 38, 127, ' +
          effectiveOpacity * 0.3 +
          ') 0%, rgba(249, 115, 22, ' +
          effectiveOpacity * 0.4 +
          ') 100%)',
        'ocean-deep':
          'linear-gradient(135deg, rgba(15, 23, 42, ' +
          effectiveOpacity * 0.8 +
          ') 0%, rgba(30, 64, 175, ' +
          effectiveOpacity * 0.6 +
          ') 100%)',
        'forest-mystique':
          'linear-gradient(135deg, rgba(20, 83, 45, ' +
          effectiveOpacity * 0.6 +
          ') 0%, rgba(34, 197, 94, ' +
          effectiveOpacity * 0.4 +
          ') 100%)',
        'cosmic-purple':
          'linear-gradient(135deg, rgba(88, 28, 135, ' +
          effectiveOpacity * 0.6 +
          ') 0%, rgba(168, 85, 247, ' +
          effectiveOpacity * 0.4 +
          ') 100%)',
        'rainbow-burst':
          'linear-gradient(135deg, rgba(239, 68, 68, ' +
          effectiveOpacity * 0.25 +
          ') 0%, rgba(245, 158, 11, ' +
          effectiveOpacity * 0.25 +
          ') 25%, rgba(34, 197, 94, ' +
          effectiveOpacity * 0.25 +
          ') 50%, rgba(59, 130, 246, ' +
          effectiveOpacity * 0.25 +
          ') 75%, rgba(147, 51, 234, ' +
          effectiveOpacity * 0.25 +
          ') 100%)',
        // Premium metallic themes - FIXED for visibility with darker, richer tones
        'steel-blue':
          'linear-gradient(135deg, rgba(30, 41, 59, ' +
          effectiveOpacity * 0.95 +
          ') 0%, rgba(51, 65, 85, ' +
          effectiveOpacity * 0.9 +
          ') 25%, rgba(71, 85, 105, ' +
          effectiveOpacity * 0.85 +
          ') 50%, rgba(30, 58, 138, ' +
          effectiveOpacity * 0.8 +
          ') 100%)',
        'chrome-silver':
          'linear-gradient(135deg, rgba(55, 65, 81, ' +
          effectiveOpacity * 0.9 +
          ') 0%, rgba(75, 85, 99, ' +
          effectiveOpacity * 0.85 +
          ') 25%, rgba(100, 116, 139, ' +
          effectiveOpacity * 0.8 +
          ') 50%, rgba(71, 85, 105, ' +
          effectiveOpacity * 0.9 +
          ') 100%)',
        'titanium-gray':
          'linear-gradient(135deg, rgba(31, 41, 55, ' +
          effectiveOpacity * 0.95 +
          ') 0%, rgba(55, 65, 81, ' +
          effectiveOpacity * 0.9 +
          ') 25%, rgba(75, 85, 99, ' +
          effectiveOpacity * 0.85 +
          ') 50%, rgba(107, 114, 128, ' +
          effectiveOpacity * 0.8 +
          ') 100%)',
        'platinum-white':
          'linear-gradient(135deg, rgba(75, 85, 99, ' +
          effectiveOpacity * 0.85 +
          ') 0%, rgba(100, 116, 139, ' +
          effectiveOpacity * 0.8 +
          ') 25%, rgba(148, 163, 184, ' +
          effectiveOpacity * 0.75 +
          ') 50%, rgba(156, 163, 175, ' +
          effectiveOpacity * 0.7 +
          ') 100%)'
      };

      const background = gradients[settings.gradientStyle] || gradients['blue-purple'];

      // Generate effect styles for the current theme
      let boxShadow = '0 10px 40px rgba(0, 0, 0, 0.5)';
      let borderShadow = '';

      switch (settings.effectStyle) {
        case 'metallic':
          boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      inset 0 1px 0 rgba(255, 255, 255, 0.57),
                      inset 0 -1px 0 rgba(0, 0, 0, 0.48)
                  `;
          break;
        case 'neon':
          borderShadow = `0 0 20px rgba(74, 158, 255, ${effectiveOpacity * 0.6})`;
          boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      ${borderShadow}
                  `;
          break;
        case 'plasma':
          borderShadow = `0 0 30px rgba(147, 51, 234, ${effectiveOpacity * 0.5})`;
          boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      ${borderShadow}
                  `;
          break;
        case 'holographic':
          boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      0 0 40px rgba(255, 255, 255, ${effectiveOpacity * 0.1}),
                      inset 0 1px 0 rgba(255, 255, 255, 0.73)
                  `;
          break;
        case 'crystal':
          boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      0 0 20px rgba(255, 255, 255, ${effectiveOpacity * 0.1}),
                      inset 0 1px 0 rgba(255, 255, 255, 0.3),
                      inset 0 -1px 0 rgba(0, 0, 0, 0.30)
                  `;
          break;
      }

      // Accent colors for black themes
      const accentColors = {
        'black-void': { color: '#1a1a1a', glow: 'rgba(26, 26, 26, 0.3)', text: '#2a2a2a' },
        'black-crimson': { color: '#DC143C', glow: 'rgba(220, 20, 60, 0.5)', text: '#FF6B6B' },
        'black-emerald': { color: '#50C878', glow: 'rgba(80, 200, 120, 0.5)', text: '#90EE90' },
        'black-royal': { color: '#9D4EDD', glow: 'rgba(157, 78, 221, 0.5)', text: '#DDA0DD' },
        'black-gold': { color: '#FFD700', glow: 'rgba(255, 215, 0, 0.5)', text: '#FFD700' },
        'black-ice': { color: '#00FFFF', glow: 'rgba(0, 255, 255, 0.5)', text: '#B0E0E6' },
        'black-flame': { color: '#FF4500', glow: 'rgba(255, 69, 0, 0.5)', text: '#FF7F50' },
        'black-toxic': { color: '#7FFF00', glow: 'rgba(127, 255, 0, 0.5)', text: '#9ACD32' },
        'black-pink': { color: '#FF1493', glow: 'rgba(255, 20, 147, 0.5)', text: '#FFB6C1' },
        'black-matrix': { color: '#00FF00', glow: 'rgba(0, 255, 0, 0.8)', text: '#00FF00' },
        'black-sunset': { color: '#FF6B35', glow: 'rgba(255, 107, 53, 0.6)', text: '#FFA500' },
        'black-blood': { color: '#8B0000', glow: 'rgba(139, 0, 0, 0.7)', text: '#CD5C5C' },
        'black-neon': { color: '#00CED1', glow: 'rgba(0, 206, 209, 0.8)', text: '#AFEEEE' },
        'black-storm': { color: '#483D8B', glow: 'rgba(72, 61, 139, 0.6)', text: '#9370DB' },
        'black-sapphire': { color: '#0F52BA', glow: 'rgba(15, 82, 186, 0.7)', text: '#4169E1' },
        'black-aqua': { color: '#008B8B', glow: 'rgba(0, 139, 139, 0.6)', text: '#48D1CC' },
        'black-phantom': { color: '#C0C0C0', glow: 'rgba(192, 192, 192, 0.4)', text: '#DCDCDC' },
        'black-violet': { color: '#8A2BE2', glow: 'rgba(138, 43, 226, 0.6)', text: '#9370DB' },
        'black-amber': { color: '#FFBF00', glow: 'rgba(255, 191, 0, 0.5)', text: '#FFC125' },
        'black-jade': { color: '#00A86B', glow: 'rgba(0, 168, 107, 0.6)', text: '#5FD3A6' },
        'black-coral': { color: '#FF7F50', glow: 'rgba(255, 127, 80, 0.5)', text: '#FFA07A' },
        'black-steel': { color: '#4682B4', glow: 'rgba(70, 130, 180, 0.5)', text: '#87CEEB' },
        'black-lavender': { color: '#B57EDC', glow: 'rgba(181, 126, 220, 0.5)', text: '#DDA0DD' },
        'black-mint': { color: '#3EB489', glow: 'rgba(62, 180, 137, 0.6)', text: '#98FB98' },
        'black-ruby': { color: '#E0115F', glow: 'rgba(224, 17, 95, 0.6)', text: '#FF1493' },
        'black-cobalt': { color: '#0047AB', glow: 'rgba(0, 71, 171, 0.7)', text: '#4169E1' },
        'black-bronze': { color: '#CD7F32', glow: 'rgba(205, 127, 50, 0.6)', text: '#D2691E' },
        'black-teal': { color: '#008080', glow: 'rgba(0, 128, 128, 0.6)', text: '#20B2AA' },
        'black-magenta': { color: '#FF00FF', glow: 'rgba(255, 0, 255, 0.6)', text: '#FF69B4' },
        'black-lime': { color: '#32CD32', glow: 'rgba(50, 205, 50, 0.6)', text: '#7FFF00' },
        'black-indigo': { color: '#4B0082', glow: 'rgba(75, 0, 130, 0.6)', text: '#8B00FF' }
      };

      const accent = accentColors[settings.gradientStyle] || null;

      // Texture patterns (CSS background-image overlays)
      // ========== PROFESSIONAL TEXTURE SYSTEM 2.0 ==========
      // 25 premium patterns with proper visibility (0.12-0.25 opacity)
      const textures = {
        none: '',

        // ===== MODERN GLASS (Apple iOS Glassmorphism) =====
        'frosted-glass': `
                  radial-gradient(circle at 35% 35%, rgba(74, 158, 255, 0.25), transparent 60%),
                  radial-gradient(circle at 65% 65%, rgba(0, 217, 255, 0.20), transparent 55%),
                  radial-gradient(circle at 20% 80%, rgba(147, 197, 253, 0.18), transparent 45%),
                  url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E"),
                  linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(200, 230, 255, 0.08))
              `,
        'crystal-prism': `
                  linear-gradient(45deg, rgba(74, 158, 255, 0.35) 0%, transparent 50%, rgba(147, 51, 234, 0.28) 100%),
                  linear-gradient(-45deg, transparent 0%, rgba(0, 217, 255, 0.30) 50%, transparent 100%),
                  radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25), transparent 60%),
                  radial-gradient(circle at 30% 70%, rgba(139, 92, 246, 0.18), transparent 50%)
              `,
        'ice-frost': `
                  radial-gradient(circle at 20% 30%, rgba(147, 197, 253, 0.40) 0%, transparent 4%),
                  radial-gradient(circle at 60% 70%, rgba(191, 219, 254, 0.35) 0%, transparent 5%),
                  radial-gradient(circle at 80% 20%, rgba(224, 242, 254, 0.38) 0%, transparent 3%),
                  radial-gradient(circle at 40% 50%, rgba(59, 130, 246, 0.22) 0%, transparent 8%),
                  linear-gradient(to bottom, rgba(219, 234, 254, 0.15), rgba(147, 197, 253, 0.08))
              `,
        'smoke-flow': `
                  radial-gradient(ellipse at 0% 0%, rgba(96, 165, 250, 0.35), transparent 55%),
                  radial-gradient(ellipse at 100% 100%, rgba(147, 197, 253, 0.28), transparent 60%),
                  radial-gradient(ellipse at 50% 50%, rgba(191, 219, 254, 0.25), transparent 45%),
                  radial-gradient(ellipse at 30% 70%, rgba(59, 130, 246, 0.18), transparent 50%)
              `,
        'water-ripple': `
                  radial-gradient(circle, rgba(6, 182, 212, 0.30) 3px, transparent 3px),
                  radial-gradient(circle, rgba(34, 211, 238, 0.25) 2px, transparent 2px),
                  radial-gradient(circle, rgba(103, 232, 249, 0.18) 1.5px, transparent 1.5px),
                  linear-gradient(to bottom, rgba(165, 243, 252, 0.12), rgba(6, 182, 212, 0.08))
              `,

        // ===== PREMIUM MATERIALS (Photorealistic Luxury) =====
        'carbon-fiber-pro': `
                  repeating-linear-gradient(0deg,
                      rgba(59, 130, 246, 0.15) 0px,
                      rgba(147, 51, 234, 0.35) 1px,
                      rgba(99, 102, 241, 0.28) 2px,
                      rgba(139, 92, 246, 0.12) 3px,
                      transparent 4px),
                  repeating-linear-gradient(90deg,
                      rgba(30, 58, 138, 0.18) 0px,
                      rgba(67, 56, 202, 0.32) 1px,
                      rgba(79, 70, 229, 0.25) 2px,
                      rgba(99, 102, 241, 0.15) 3px,
                      transparent 4px),
                  linear-gradient(135deg, rgba(30, 27, 75, 0.20), rgba(67, 56, 202, 0.10))
              `,
        'brushed-aluminum': `
                  repeating-linear-gradient(90deg,
                      rgba(226, 232, 240, 0.35) 0px,
                      rgba(203, 213, 225, 0.45) 0.5px,
                      rgba(226, 232, 240, 0.38) 1px,
                      rgba(241, 245, 249, 0.28) 1.5px,
                      rgba(203, 213, 225, 0.32) 2px),
                  linear-gradient(180deg, rgba(248, 250, 252, 0.18), rgba(226, 232, 240, 0.25)),
                  radial-gradient(circle at 50% 0%, rgba(255, 255, 255, 0.15), transparent 60%)
              `,
        'brushed-titanium': `
                  repeating-linear-gradient(45deg,
                      rgba(251, 191, 36, 0.30) 0px,
                      rgba(217, 119, 6, 0.40) 1px,
                      rgba(245, 158, 11, 0.35) 2px,
                      rgba(251, 191, 36, 0.25) 3px),
                  linear-gradient(135deg, rgba(217, 119, 6, 0.18), rgba(251, 191, 36, 0.12)),
                  radial-gradient(circle at 40% 40%, rgba(252, 211, 77, 0.20), transparent 55%)
              `,
        'leather-grain': `
                  url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='turbulence'%3E%3CfeTurbulence type='turbulence' baseFrequency='2.2' numOctaves='3'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23turbulence)' opacity='0.28'/%3E%3C/svg%3E"),
                  radial-gradient(circle at 60% 40%, rgba(127, 29, 29, 0.35), transparent 65%),
                  radial-gradient(circle at 30% 70%, rgba(153, 27, 27, 0.28), transparent 60%),
                  linear-gradient(135deg, rgba(185, 28, 28, 0.22), rgba(127, 29, 29, 0.18))
              `,
        'fabric-weave': `
                  repeating-linear-gradient(0deg, rgba(148, 163, 184, 0.35) 0px, transparent 1px, transparent 3px),
                  repeating-linear-gradient(90deg, rgba(148, 163, 184, 0.35) 0px, transparent 1px, transparent 3px),
                  linear-gradient(45deg, rgba(203, 213, 225, 0.15) 25%, transparent 25%, transparent 75%, rgba(203, 213, 225, 0.15) 75%),
                  linear-gradient(45deg, rgba(226, 232, 240, 0.12), rgba(203, 213, 225, 0.08))
              `,
        'wood-grain': `
                  linear-gradient(90deg,
                      rgba(217, 119, 6, 0.28) 0%,
                      rgba(251, 146, 60, 0.35) 8%,
                      rgba(217, 119, 6, 0.25) 16%,
                      rgba(234, 88, 12, 0.32) 24%,
                      rgba(251, 146, 60, 0.28) 32%,
                      rgba(217, 119, 6, 0.30) 40%),
                  repeating-linear-gradient(90deg, transparent 0px, rgba(180, 83, 9, 0.18) 1px, transparent 2px),
                  linear-gradient(180deg, rgba(251, 191, 36, 0.15), rgba(217, 119, 6, 0.10))
              `,

        // ===== TECH/FUTURISTIC (Cyberpunk Neon) =====
        'circuit-board': `
                  linear-gradient(rgba(34, 197, 94, 0.32) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(34, 197, 94, 0.32) 1px, transparent 1px),
                  linear-gradient(rgba(16, 185, 129, 0.25) 2px, transparent 2px),
                  linear-gradient(90deg, rgba(16, 185, 129, 0.25) 2px, transparent 2px),
                  radial-gradient(circle at 25% 25%, rgba(52, 211, 153, 0.20), transparent 15%),
                  radial-gradient(circle at 75% 75%, rgba(16, 185, 129, 0.18), transparent 15%),
                  linear-gradient(135deg, rgba(6, 78, 59, 0.15), rgba(20, 83, 45, 0.10))
              `,
        'hexagon-grid-pro': `
                  repeating-linear-gradient(0deg, transparent, transparent 22px, rgba(6, 182, 212, 0.38) 22px, rgba(14, 165, 233, 0.38) 23px),
                  repeating-linear-gradient(60deg, transparent, transparent 22px, rgba(34, 211, 238, 0.32) 22px, rgba(6, 182, 212, 0.32) 23px),
                  repeating-linear-gradient(120deg, transparent, transparent 22px, rgba(56, 189, 248, 0.32) 22px, rgba(14, 165, 233, 0.32) 23px),
                  radial-gradient(circle at 50% 50%, rgba(125, 211, 252, 0.18), transparent 50%)
              `,
        'hologram-scan': `
                  repeating-linear-gradient(0deg,
                      transparent 0px,
                      rgba(6, 182, 212, 0.22) 1px,
                      rgba(236, 72, 153, 0.32) 2px,
                      rgba(6, 182, 212, 0.22) 3px,
                      transparent 4px),
                  linear-gradient(90deg, rgba(236, 72, 153, 0.15), rgba(6, 182, 212, 0.15), rgba(236, 72, 153, 0.15)),
                  radial-gradient(circle at 50% 50%, rgba(236, 72, 153, 0.18), transparent 60%)
              `,
        'matrix-rain': `
                  linear-gradient(rgba(34, 197, 94, 0.35) 2px, transparent 2px),
                  linear-gradient(90deg, rgba(16, 185, 129, 0.28) 1px, transparent 1px),
                  radial-gradient(circle at 30% 40%, rgba(52, 211, 153, 0.20), transparent 50%),
                  linear-gradient(180deg, rgba(34, 197, 94, 0.12), rgba(6, 78, 59, 0.08))
              `,
        'energy-waves': `
                  radial-gradient(ellipse at 50% 0%, rgba(59, 130, 246, 0.40), transparent 45%),
                  radial-gradient(ellipse at 50% 100%, rgba(96, 165, 250, 0.38), transparent 45%),
                  radial-gradient(ellipse at 50% 50%, rgba(147, 197, 253, 0.28), transparent 35%),
                  radial-gradient(ellipse at 0% 50%, rgba(29, 78, 216, 0.22), transparent 40%),
                  radial-gradient(ellipse at 100% 50%, rgba(37, 99, 235, 0.22), transparent 40%)
              `,
        'cyberpunk-grid': `
                  linear-gradient(rgba(236, 72, 153, 0.35) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(6, 182, 212, 0.35) 1px, transparent 1px),
                  radial-gradient(circle at 50% 50%, rgba(168, 85, 247, 0.25), transparent 65%),
                  linear-gradient(135deg, rgba(236, 72, 153, 0.12), rgba(6, 182, 212, 0.12))
              `,

        // ===== GEOMETRIC CLEAN (Swiss Design) =====
        'dots-pro': `
                  radial-gradient(circle, rgba(100, 116, 139, 0.40) 2px, transparent 2px),
                  radial-gradient(circle, rgba(148, 163, 184, 0.20) 1px, transparent 1px),
                  linear-gradient(to bottom right, rgba(203, 213, 225, 0.10), rgba(148, 163, 184, 0.08))
              `,
        'grid-pro': `
                  linear-gradient(rgba(100, 116, 139, 0.35) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(100, 116, 139, 0.35) 1px, transparent 1px),
                  linear-gradient(rgba(148, 163, 184, 0.15) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(148, 163, 184, 0.15) 1px, transparent 1px)
              `,
        'diagonal-pro': `
                  repeating-linear-gradient(45deg,
                      transparent,
                      transparent 18px,
                      rgba(100, 116, 139, 0.32) 18px,
                      rgba(148, 163, 184, 0.28) 19px,
                      transparent 20px),
                  linear-gradient(135deg, rgba(203, 213, 225, 0.10), rgba(148, 163, 184, 0.05))
              `,
        waves: `
                  repeating-radial-gradient(circle at 50% 50%,
                      transparent 0px,
                      rgba(100, 116, 139, 0.30) 12px,
                      transparent 24px),
                  radial-gradient(circle at 50% 50%, rgba(148, 163, 184, 0.18), transparent 60%)
              `,
        triangles: `
                  linear-gradient(45deg, rgba(100, 116, 139, 0.35) 25%, transparent 25%),
                  linear-gradient(-45deg, rgba(100, 116, 139, 0.35) 25%, transparent 25%),
                  linear-gradient(45deg, transparent 75%, rgba(148, 163, 184, 0.28) 75%),
                  linear-gradient(-45deg, transparent 75%, rgba(148, 163, 184, 0.28) 75%)
              `,
        crosshatch: `
                  repeating-linear-gradient(0deg, transparent, transparent 4px, rgba(100, 116, 139, 0.32) 4px, rgba(100, 116, 139, 0.32) 5px),
                  repeating-linear-gradient(90deg, transparent, transparent 4px, rgba(148, 163, 184, 0.28) 4px, rgba(148, 163, 184, 0.28) 5px)
              `,

        // ===== SPECIAL EFFECTS (Atmospheric) =====
        'perlin-noise': `
                  url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='perlin'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='5' stitchTiles='stitch'/%3E%3CfeColorMatrix values='0.3 0 0 0 0.4, 0 0.4 0 0 0.5, 0 0 0.5 0 0.6, 0 0 0 0.35 0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23perlin)'/%3E%3C/svg%3E"),
                  radial-gradient(circle at 50% 50%, rgba(147, 51, 234, 0.15), transparent 70%)
              `,
        'gradient-mesh': `
                  radial-gradient(circle at 25% 25%, rgba(139, 92, 246, 0.35), transparent 55%),
                  radial-gradient(circle at 75% 25%, rgba(59, 130, 246, 0.32), transparent 55%),
                  radial-gradient(circle at 25% 75%, rgba(236, 72, 153, 0.30), transparent 55%),
                  radial-gradient(circle at 75% 75%, rgba(6, 182, 212, 0.28), transparent 55%),
                  linear-gradient(135deg, rgba(167, 139, 250, 0.12), rgba(96, 165, 250, 0.12))
              `
      };

      const textureBackgroundSize = {
        'frosted-glass': '100% 100%, 100% 100%, 100% 100%, cover, 100% 100%',
        'crystal-prism': '100% 100%, 100% 100%, 100% 100%, 100% 100%',
        'ice-frost': '100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%',
        'smoke-flow': '100% 100%, 100% 100%, 100% 100%, 100% 100%',
        'water-ripple': '30px 30px, 50px 50px, 40px 40px, 100% 100%',
        'carbon-fiber-pro': '6px 6px, 6px 6px, 100% 100%',
        'brushed-aluminum': '2px 100%, 100% 100%, 100% 100%',
        'brushed-titanium': '3px 3px, 100% 100%, 100% 100%',
        'leather-grain': 'cover, 100% 100%, 100% 100%, 100% 100%',
        'fabric-weave': '4px 4px, 4px 4px, 30px 30px, 100% 100%',
        'wood-grain': '100% 40px, 100% 2px, 100% 100%',
        'circuit-board': '40px 40px, 40px 40px, 120px 120px, 120px 120px, 100% 100%, 100% 100%, 100% 100%',
        'hexagon-grid-pro': '100% 100%, 100% 100%, 100% 100%, 100% 100%',
        'hologram-scan': '100% 5px, 100% 100%, 100% 100%',
        'matrix-rain': '2px 20px, 10px 10px, 100% 100%, 100% 100%',
        'energy-waves': '100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%',
        'cyberpunk-grid': '50px 50px, 50px 50px, 100% 100%, 100% 100%',
        'dots-pro': '25px 25px, 20px 20px, 100% 100%',
        'grid-pro': '30px 30px, 30px 30px, 60px 60px, 60px 60px',
        'diagonal-pro': '100% 100%, 100% 100%',
        waves: '100% 100%, 100% 100%',
        triangles: '30px 30px, 30px 30px, 30px 30px, 30px 30px',
        crosshatch: '100% 100%, 100% 100%',
        'perlin-noise': 'cover, 100% 100%',
        'gradient-mesh': '100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%'
      };

      const textureStyle = settings.textureStyle || 'none';
      let texturePattern = textures[textureStyle] || '';
      let textureBgSize = textureBackgroundSize[textureStyle] || 'auto';

      // Apply intensity multiplier to texture opacity
      const textureIntensity = settings.textureIntensity !== undefined ? settings.textureIntensity : 75;
      const intensityMultiplier = textureIntensity / 100; // 0-100% direct mapping

      if (texturePattern && intensityMultiplier !== 1.0) {
        // Multiply all rgba() opacity values by intensity multiplier
        texturePattern = texturePattern.replace(
          /rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/g,
          (match, r, g, b, a) => {
            const newAlpha = Math.min(1, parseFloat(a) * intensityMultiplier);
            return `rgba(${r}, ${g}, ${b}, ${newAlpha.toFixed(3)})`;
          }
        );

        // Also handle SVG opacity attributes
        texturePattern = texturePattern.replace(/opacity='([0-9.]+)'/g, (match, a) => {
          const newAlpha = Math.min(1, parseFloat(a) * intensityMultiplier);
          return `opacity='${newAlpha.toFixed(2)}'`;
        });
      }

      // Apply scale multiplier to texture background-size
      const textureScale = settings.textureScale || 'medium';
      const scaleMultipliers = { small: 0.5, medium: 1.0, large: 2.0 };
      const scaleMultiplier = scaleMultipliers[textureScale];

      if (textureBgSize !== 'cover' && textureBgSize !== 'auto' && scaleMultiplier !== 1.0) {
        // Scale pixel/percentage values
        textureBgSize = textureBgSize.replace(/(\d+)(px|%)/g, (match, value, unit) => {
          const scaled = Math.round(parseFloat(value) * scaleMultiplier);
          return scaled + unit;
        });
      }

      // Get blend mode
      const textureBlendMode = settings.textureBlendMode || 'overlay';

      // Get animation setting
      const textureAnimated = settings.textureAnimated || false;

      return {
        background,
        boxShadow,
        opacity: isPopout ? settings.popoutOpacity : settings.opacity,
        effectiveOpacity: effectiveOpacity,
        gradientStyle: settings.gradientStyle,
        effectStyle: settings.effectStyle,
        textureStyle: textureStyle,
        texturePattern: texturePattern,
        textureBackgroundSize: textureBgSize,
        textureBlendMode: textureBlendMode,
        textureAnimated: textureAnimated,
        isPopout: isPopout,
        accentColor: accent ? accent.color : '#4a9eff',
        accentGlow: accent ? accent.glow : 'rgba(74, 158, 255, 0.5)',
        accentText: accent ? accent.text : '#FFFFFF'
      };
    }

    function applyThemeToElement(element, themeStyles) {
      if (!element || !themeStyles) return;

      const opacity = themeStyles.opacity / 100;

      // Handle true 0% opacity - completely transparent
      if (opacity === 0) {
        element.style.background = 'transparent';
        element.style.boxShadow = 'none';
        element.style.backdropFilter = 'none';
        element.style.border = 'none';
        productionLog('üîç Applied true 0% opacity - completely transparent');
        return;
      }

      // Handle all opacity levels (1-100%) with same logic
      // Layer texture over gradient if texture is enabled
      if (themeStyles.texturePattern) {
        element.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
        element.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
        element.style.backgroundBlendMode = `${themeStyles.textureBlendMode}, normal`;

        // Add animation class if enabled for supported textures
        const animatedTextures = ['smoke-flow', 'hologram-scan', 'energy-waves', 'water-ripple'];
        if (themeStyles.textureAnimated && animatedTextures.includes(themeStyles.textureStyle)) {
          element.classList.add('mga-texture-animated');
        } else {
          element.classList.remove('mga-texture-animated');
        }
      } else {
        element.style.background = themeStyles.background;
        element.style.backgroundBlendMode = '';
        element.classList.remove('mga-texture-animated');
      }

      // Apply box shadow and borders
      const isBlackTheme = themeStyles.gradientStyle && themeStyles.gradientStyle.startsWith('black-');
      if (isBlackTheme && themeStyles.accentColor) {
        element.style.boxShadow = `0 10px 40px rgba(0, 0, 0, 0.8), 0 0 30px ${themeStyles.accentGlow}`;
        element.style.border = `1px solid ${themeStyles.accentColor}`;
      } else {
        element.style.boxShadow = themeStyles.boxShadow;
        element.style.border = `1px solid rgba(255, 255, 255, ${Math.max(0.05, opacity * 0.15)})`;
      }

      // Backdrop filter: disable at 100% for solid appearance, scale with opacity otherwise
      if (opacity >= 1.0) {
        element.style.backdropFilter = 'none';
      } else if (opacity > 0.05) {
        const blurIntensity = Math.max(2, Math.min(12, 12 * opacity));
        element.style.backdropFilter = `blur(${blurIntensity}px)`;
      } else {
        element.style.backdropFilter = 'none';
      }

      // Set theme-aware CSS custom properties for dynamic elements
      const effectiveOpacity = themeStyles.effectiveOpacity || opacity;
      const accentColor = getAccentColorForTheme(themeStyles.gradientStyle, effectiveOpacity);

      element.style.setProperty('--theme-accent-bg', accentColor.background);
      element.style.setProperty('--theme-accent-border', accentColor.border);

      // Apply dynamic scaling if this is an overlay
      if (element.classList.contains('mga-overlay') || (element.id && element.id.includes('overlay'))) {
        const width = element.offsetWidth || 400;
        const scale = calculateScale(width);
        element.style.setProperty('--panel-scale', scale);
      }
    }

    function calculateScale(width) {
      // Same scaling logic as the main panel
      let scale = 1;
      if (width < 350) {
        scale = 0.8;
      } else if (width < 450) {
        scale = 0.85;
      } else if (width < 550) {
        scale = 0.9;
      } else if (width < 650) {
        scale = 0.95;
      } else if (width >= 800) {
        scale = 1.05;
      }
      return scale;
    }

    function getAccentColorForTheme(gradientStyle, opacity) {
      // Define accent colors based on the current theme
      const accentColors = {
        'blue-purple': {
          background: `linear-gradient(135deg, rgba(74, 158, 255, ${opacity * 0.1}) 0%, rgba(147, 51, 234, ${opacity * 0.1}) 100%)`,
          border: `rgba(74, 158, 255, ${opacity * 0.3})`
        },
        'green-blue': {
          background: `linear-gradient(135deg, rgba(34, 197, 94, ${opacity * 0.1}) 0%, rgba(59, 130, 246, ${opacity * 0.1}) 100%)`,
          border: `rgba(34, 197, 94, ${opacity * 0.3})`
        },
        'red-orange': {
          background: `linear-gradient(135deg, rgba(239, 68, 68, ${opacity * 0.1}) 0%, rgba(249, 115, 22, ${opacity * 0.1}) 100%)`,
          border: `rgba(239, 68, 68, ${opacity * 0.3})`
        },
        'purple-pink': {
          background: `linear-gradient(135deg, rgba(168, 85, 247, ${opacity * 0.1}) 0%, rgba(236, 72, 153, ${opacity * 0.1}) 100%)`,
          border: `rgba(168, 85, 247, ${opacity * 0.3})`
        },
        'gold-yellow': {
          background: `linear-gradient(135deg, rgba(255, 215, 0, ${opacity * 0.1}) 0%, rgba(245, 158, 11, ${opacity * 0.1}) 100%)`,
          border: `rgba(255, 215, 0, ${opacity * 0.3})`
        },
        'steel-blue': {
          background: `linear-gradient(135deg, rgba(30, 58, 138, ${opacity * 0.1}) 0%, rgba(51, 65, 85, ${opacity * 0.1}) 100%)`,
          border: `rgba(30, 58, 138, ${opacity * 0.3})`
        },
        'chrome-silver': {
          background: `linear-gradient(135deg, rgba(203, 213, 225, ${opacity * 0.1}) 0%, rgba(148, 163, 184, ${opacity * 0.1}) 100%)`,
          border: `rgba(203, 213, 225, ${opacity * 0.3})`
        },
        'titanium-gray': {
          background: `linear-gradient(135deg, rgba(107, 114, 128, ${opacity * 0.1}) 0%, rgba(156, 163, 175, ${opacity * 0.1}) 100%)`,
          border: `rgba(107, 114, 128, ${opacity * 0.3})`
        },
        'electric-neon': {
          background: `linear-gradient(135deg, rgba(0, 100, 255, ${opacity * 0.1}) 0%, rgba(147, 51, 234, ${opacity * 0.1}) 100%)`,
          border: `rgba(0, 100, 255, ${opacity * 0.3})`
        },
        'rainbow-burst': {
          background: `linear-gradient(135deg, rgba(239, 68, 68, ${opacity * 0.08}) 0%, rgba(245, 158, 11, ${opacity * 0.08}) 25%, rgba(34, 197, 94, ${opacity * 0.08}) 50%, rgba(59, 130, 246, ${opacity * 0.08}) 75%, rgba(147, 51, 234, ${opacity * 0.08}) 100%)`,
          border: `rgba(147, 51, 234, ${opacity * 0.3})`
        }
      };

      return accentColors[gradientStyle] || accentColors['blue-purple'];
    }

    function syncThemeToAllWindows() {
      // Generate theme styles specifically for pop-out windows
      const popoutThemeStyles = generateThemeStyles(UnifiedState.data.settings, true);
      if (!popoutThemeStyles) return;

      // Update all in-game overlays with pop-out opacity
      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
        if (overlay && document.contains(overlay)) {
          applyThemeToElement(overlay, popoutThemeStyles);
        }
      });

      // Update all shift+click popout widgets
      UnifiedState.data.popouts.widgets.forEach((widget, tabName) => {
        if (widget && document.contains(widget)) {
          applyThemeToPopoutWidget(widget, popoutThemeStyles);
        }
      });

      // For pop-out windows, we'll implement a refresh system since we can't directly
      // communicate with them across window contexts. This is a limitation of
      // separate windows, but the themes will be applied when they're opened.

      // Store theme update timestamp for future reference
      UnifiedState.data.lastThemeUpdate = Date.now();
    }

    // Enhanced function to ensure themes are always current
    function ensureThemeConsistency() {
      // Apply theme to main panel if it exists but doesn't have the current theme
      const panel = UnifiedState.panels.main;
      if (panel) {
        const currentTheme = UnifiedState.currentTheme || generateThemeStyles();
        if (!UnifiedState.currentTheme) {
          UnifiedState.currentTheme = currentTheme;
        }
        applyThemeToElement(panel, currentTheme);
      }

      // Update all overlays
      syncThemeToAllWindows();
    }

    // Enhanced modal spam prevention with debouncing and queue system
    function setupModalSpamPrevention() {
      // Add modal spam protection to settings
      if (!UnifiedState.data.settings.modalSpamProtection) {
        UnifiedState.data.settings.modalSpamProtection = {
          enabled: true,
          cooldownMs: 500,
          queueLimit: 3,
          lastModalTime: 0,
          modalQueue: []
        };
      }

      const modalSettings = UnifiedState.data.settings.modalSpamProtection;

      // Note: Console.log filtering removed - cannot intercept logs from other userscripts (MGC)
      // MGC spam is from separate userscript and must be filtered at browser console level if needed

      // Enhanced modal prevention with debouncing
      const originalAlert = window.alert;
      const originalConfirm = window.confirm;

      window.alert = function (message) {
        if (!modalSettings.enabled) return originalAlert.call(window, message);

        const now = Date.now();
        if (now - modalSettings.lastModalTime < modalSettings.cooldownMs) {
          debugLog('MODAL_SPAM', 'Alert blocked due to cooldown', { message: message.substring(0, 50) });
          return;
        }

        modalSettings.lastModalTime = now;
        return originalAlert.call(window, message);
      };

      window.confirm = function (message) {
        if (!modalSettings.enabled) return originalConfirm.call(window, message);

        const now = Date.now();
        if (now - modalSettings.lastModalTime < modalSettings.cooldownMs) {
          debugLog('MODAL_SPAM', 'Confirm blocked due to cooldown', { message: message.substring(0, 50) });
          return false; // Default to false for safety
        }

        modalSettings.lastModalTime = now;
        return originalConfirm.call(window, message);
      };

      // Prevent multiple overlapping modal dialogs
      let activeModalCount = 0;
      const originalCreateElement = targetDocument.createElement;
      targetDocument.createElement = function (tagName) {
        const element = originalCreateElement.call(document, tagName);

        if (tagName.toLowerCase() === 'dialog' || (element.className && element.className.includes('modal'))) {
          if (activeModalCount >= modalSettings.queueLimit) {
            debugLog('MODAL_SPAM', 'Modal blocked due to queue limit');
            return element; // Return but don't increment count
          }

          activeModalCount++;

          // Auto-cleanup modal count after 5 seconds
          setTimeout(() => {
            if (activeModalCount > 0) activeModalCount--;
          }, 5000);
        }

        return element;
      };

      debugLog('MODAL_SPAM', 'Enhanced modal spam prevention initialized', {
        cooldownMs: modalSettings.cooldownMs,
        queueLimit: modalSettings.queueLimit
      });
    }

    function applyTheme() {
      const themeStyles = generateThemeStyles();

      // Store current theme for cross-window synchronization
      UnifiedState.currentTheme = themeStyles;

      // Apply to main panel if it exists (Alt+key overlay windows)
      const panel = UnifiedState.panels.main;
      if (panel) {
        applyThemeToElement(panel, themeStyles);
      }

      // Apply theme colors to dock and sidebar for all themes
      const isBlackTheme = themeStyles.gradientStyle && themeStyles.gradientStyle.startsWith('black-');
      if (isBlackTheme && themeStyles.accentColor) {
        // Black themes get special accent styling
        applyAccentToDock(themeStyles);
        applyAccentToSidebar(themeStyles);
      } else {
        // Non-black themes get their gradient applied
        applyThemeToDock(themeStyles);
        applyThemeToSidebar(themeStyles);
      }

      // Update all existing overlays and pop-out windows
      syncThemeToAllWindows();
    }

    function applyThemeToDock(themeStyles) {
      const dock = document.querySelector('#mgh-dock');
      if (!dock) return;

      // Apply theme background, border, and effects to dock
      dock.style.background = themeStyles.background;
      dock.style.border = `1px solid rgba(255, 255, 255, ${(themeStyles.opacity / 100) * 0.15})`;
      dock.style.boxShadow = themeStyles.boxShadow;
      dock.style.backdropFilter = 'blur(20px)';
    }

    function applyAccentToDock(themeStyles) {
      const dock = document.querySelector('#mgh-dock');
      if (!dock) return;

      // Use actual user opacity setting
      const opacity = themeStyles.opacity / 100;

      // Apply black background with user-controlled opacity
      dock.style.background = `rgba(0, 0, 0, ${opacity})`;
      dock.style.border = `1px solid ${themeStyles.accentColor}`;

      // Combine base shadow with accent glow - enhanced by effect style
      let accentShadow = `0 8px 24px rgba(0, 0, 0, 0.8), 0 0 20px ${themeStyles.accentGlow}`;

      // Add effect-specific enhancements to the accent glow
      if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
        accentShadow += `, 0 0 40px ${themeStyles.accentGlow}`;
      } else if (themeStyles.effectStyle === 'metallic' || themeStyles.effectStyle === 'steel') {
        accentShadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
      } else if (themeStyles.effectStyle === 'crystal' || themeStyles.effectStyle === 'glass') {
        accentShadow += `, 0 0 30px ${themeStyles.accentGlow}, inset 0 1px 0 rgba(255, 255, 255, 0.73)`;
      }

      dock.style.boxShadow = accentShadow;

      // Scale backdrop blur with opacity, but disable at 100% for solid appearance
      if (opacity >= 1.0) {
        dock.style.backdropFilter = 'none';
      } else if (opacity > 0.05) {
        const blurIntensity = Math.max(2, Math.min(20, 20 * opacity));
        dock.style.backdropFilter = `blur(${blurIntensity}px)`;
      } else {
        dock.style.backdropFilter = 'none';
      }

      // Use CSS variables for hover effects (better performance)
      dock.style.setProperty('--accent-color', themeStyles.accentColor);
      dock.style.setProperty('--accent-glow', themeStyles.accentGlow);
    }

    function applyThemeToSidebar(themeStyles) {
      const sidebar = document.querySelector('#mgh-sidebar');
      if (!sidebar) return;

      // Apply theme background with textures, border, and effects to sidebar
      if (themeStyles.texturePattern) {
        sidebar.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
        sidebar.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
      } else {
        sidebar.style.background = themeStyles.background;
      }
      sidebar.style.borderRight = `1px solid rgba(255, 255, 255, ${(themeStyles.opacity / 100) * 0.15})`;
      sidebar.style.boxShadow = `4px 0 24px rgba(0, 0, 0, 0.6), ${themeStyles.boxShadow}`;
      sidebar.style.backdropFilter = 'blur(20px)';

      // Style sidebar header with textures
      const header = sidebar.querySelector('.mgh-sidebar-header');
      if (header) {
        if (themeStyles.texturePattern) {
          header.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
          header.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
        } else {
          header.style.background = themeStyles.background;
        }
        header.style.borderBottom = `1px solid rgba(255, 255, 255, ${(themeStyles.opacity / 100) * 0.2})`;
      }

      // Remove accent-specific CSS if it exists
      const existingStyle = document.getElementById('accent-theme-styles');
      if (existingStyle) existingStyle.remove();
    }

    function applyAccentToSidebar(themeStyles) {
      const sidebar = document.querySelector('#mgh-sidebar');
      if (!sidebar) return;

      // Use actual user opacity setting
      const opacity = themeStyles.opacity / 100;

      // Apply solid black background with user-controlled opacity (no gradient tricks)
      if (themeStyles.texturePattern) {
        sidebar.style.background = `${themeStyles.texturePattern}, rgba(0, 0, 0, ${opacity})`;
        sidebar.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
      } else {
        sidebar.style.background = `rgba(0, 0, 0, ${opacity})`;
      }
      sidebar.style.borderRight = `2px solid ${themeStyles.accentColor}`;

      // Scale backdrop blur with opacity, but disable at 100% for solid appearance
      if (opacity >= 1.0) {
        sidebar.style.backdropFilter = 'none';
      } else if (opacity > 0.05) {
        const blurIntensity = Math.max(2, Math.min(20, 20 * opacity));
        sidebar.style.backdropFilter = `blur(${blurIntensity}px)`;
      } else {
        sidebar.style.backdropFilter = 'none';
      }

      // Enhanced shadow with effect-specific styling
      let sidebarShadow = `4px 0 24px rgba(0, 0, 0, 0.6), 0 0 20px ${themeStyles.accentGlow}`;

      // Add effect-specific enhancements
      if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
        sidebarShadow += `, 0 0 40px ${themeStyles.accentGlow}`;
      } else if (themeStyles.effectStyle === 'crystal' || themeStyles.effectStyle === 'glass') {
        sidebarShadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
      }

      sidebar.style.boxShadow = sidebarShadow;

      // Style sidebar header with accent gradient and opacity
      const header = sidebar.querySelector('.mgh-sidebar-header');
      if (header) {
        header.style.background = `linear-gradient(90deg, rgba(0, 0, 0, ${opacity}) 0%, ${themeStyles.accentColor} 100%)`;
        header.style.borderBottom = `2px solid ${themeStyles.accentColor}`;

        // Enhanced header glow based on effect
        let headerGlow = `0 2px 20px ${themeStyles.accentGlow}`;
        if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
          headerGlow += `, 0 0 30px ${themeStyles.accentGlow}`;
        }
        header.style.boxShadow = headerGlow;
      }

      // Use CSS variables for dynamic styling (better performance than event listeners)
      sidebar.style.setProperty('--accent-color', themeStyles.accentColor);
      sidebar.style.setProperty('--accent-glow', themeStyles.accentGlow);

      // Inject dynamic CSS for hover effects and other elements
      const style = document.createElement('style');
      style.id = 'accent-theme-styles';
      const existingStyle = document.getElementById('accent-theme-styles');
      if (existingStyle) existingStyle.remove();

      style.textContent = `
              /* Sidebar sections - ONLY MGTools elements */
              #mgh-sidebar .mga-section {
                  background: ${themeStyles.accentColor}05;
                  border: 1px solid ${themeStyles.accentColor}33;
              }

              /* Buttons - ONLY in sidebar */
              #mgh-sidebar button.mga-button,
              #mgh-sidebar button.mga-btn {
                  background: linear-gradient(135deg, ${themeStyles.accentColor}AA, ${themeStyles.accentColor});
                  border: 1px solid ${themeStyles.accentColor};
              }
              #mgh-sidebar button.mga-button:hover,
              #mgh-sidebar button.mga-btn:hover {
                  background: linear-gradient(135deg, ${themeStyles.accentColor}, ${themeStyles.accentColor}FF);
                  box-shadow: 0 0 15px ${themeStyles.accentGlow};
              }

              /* Inputs - ONLY mga-prefixed classes */
              #mgh-sidebar input.mga-slider,
              #mgh-sidebar select.mga-select,
              #mgh-sidebar textarea.mga-textarea {
                  border-color: ${themeStyles.accentColor}66;
              }
              #mgh-sidebar input.mga-slider:focus,
              #mgh-sidebar select.mga-select:focus,
              #mgh-sidebar textarea.mga-textarea:focus {
                  border-color: ${themeStyles.accentColor};
                  box-shadow: 0 0 10px ${themeStyles.accentGlow};
              }

              /* Scrollbar - ONLY sidebar scrollbar */
              #mgh-sidebar .mgh-sidebar-body::-webkit-scrollbar-thumb {
                  background: linear-gradient(180deg, ${themeStyles.accentColor}, ${themeStyles.accentColor}AA);
              }
              #mgh-sidebar .mgh-sidebar-body::-webkit-scrollbar-thumb:hover {
                  background: ${themeStyles.accentColor};
              }
          `;
      document.head.appendChild(style);
    }

    function applyThemeToPopoutWidget(popout, themeStyles) {
      if (!popout || !themeStyles) return;

      const isBlackTheme = themeStyles.gradientStyle && themeStyles.gradientStyle.startsWith('black-');

      // Use popout opacity setting (note: themeStyles is generated with isPopout flag)
      const opacity = themeStyles.opacity / 100;

      if (isBlackTheme && themeStyles.accentColor) {
        // Black themes: black background with user opacity and vibrant accents
        if (themeStyles.texturePattern) {
          popout.style.background = `${themeStyles.texturePattern}, rgba(0, 0, 0, ${opacity})`;
          popout.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
        } else {
          popout.style.background = `rgba(0, 0, 0, ${opacity})`;
        }
        popout.style.border = `1px solid ${themeStyles.accentColor}`;

        // Enhanced shadow with effect-specific styling
        let shadow = `0 8px 32px rgba(0, 0, 0, 0.6), 0 0 20px ${themeStyles.accentGlow}`;

        // Add effect-specific enhancements
        if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
          shadow += `, 0 0 40px ${themeStyles.accentGlow}`;
        } else if (themeStyles.effectStyle === 'metallic' || themeStyles.effectStyle === 'steel') {
          shadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
        } else if (themeStyles.effectStyle === 'crystal' || themeStyles.effectStyle === 'glass') {
          shadow += `, 0 0 30px ${themeStyles.accentGlow}, inset 0 1px 0 rgba(255, 255, 255, 0.73)`;
        }

        popout.style.boxShadow = shadow;

        // Style header with accent gradient and opacity
        const header = popout.querySelector('.mgh-popout-header');
        if (header) {
          header.style.background = `linear-gradient(90deg, rgba(0, 0, 0, ${opacity}) 0%, ${themeStyles.accentColor} 100%)`;
          header.style.borderBottom = `1px solid ${themeStyles.accentColor}`;

          // Enhanced header glow based on effect
          let headerGlow = `0 2px 20px ${themeStyles.accentGlow}`;
          if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
            headerGlow += `, 0 0 30px ${themeStyles.accentGlow}`;
          }
          header.style.boxShadow = headerGlow;
        }

        // Body background with opacity for black themes
        const body = popout.querySelector('.mgh-popout-body');
        if (body) {
          if (themeStyles.texturePattern) {
            body.style.background = `${themeStyles.texturePattern}, rgba(0, 0, 0, ${opacity})`;
            body.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
          } else {
            body.style.background = `rgba(0, 0, 0, ${opacity})`;
          }
        }
      } else {
        // Regular themes: use gradient background with textures
        if (themeStyles.texturePattern) {
          popout.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
          popout.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
        } else {
          popout.style.background = themeStyles.background;
        }
        popout.style.border = `1px solid rgba(255, 255, 255, ${(themeStyles.opacity / 100) * 0.15})`;
        popout.style.boxShadow = themeStyles.boxShadow;

        // Style header
        const header = popout.querySelector('.mgh-popout-header');
        if (header) {
          if (themeStyles.texturePattern) {
            header.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
            header.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
          } else {
            header.style.background = themeStyles.background;
          }
          header.style.borderBottom = `1px solid rgba(255, 255, 255, ${(themeStyles.opacity / 100) * 0.2})`;
        }

        // Keep body background solid for content readability
        const body = popout.querySelector('.mgh-popout-body');
        if (body) {
          if (themeStyles.texturePattern) {
            body.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
            body.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
          } else {
            body.style.background = themeStyles.background; // Match theme gradient
          }
        }
      }

      popout.style.backdropFilter = 'blur(20px)';
    }

    function applyUltraCompactMode(enabled) {
      const panel = UnifiedState.panels.main;
      if (!panel) return;

      if (enabled) {
        // Apply ultra-compact styles
        panel.style.cssText += `
                  --mga-font-size: 11px;
                  --mga-section-padding: 6px;
                  --mga-header-padding: 8px 12px;
                  --mga-button-padding: 4px 8px;
                  --mga-input-padding: 4px 6px;
                  --mga-tab-height: 32px;
                  --mga-spacing: 4px;
                  min-width: 250px;
                  font-size: 11px;
              `;

        // Add ultra-compact class for specific styling
        panel.classList.add('mga-ultra-compact');

        // Reduce overall panel size
        const currentWidth = parseInt(panel.style.width) || 800;
        const currentHeight = parseInt(panel.style.height) || 600;
        panel.style.width = Math.max(250, currentWidth * 0.7) + 'px';
        panel.style.height = Math.max(300, currentHeight * 0.8) + 'px';
      } else {
        // Remove ultra-compact styles
        panel.classList.remove('mga-ultra-compact');

        // Restore normal CSS variables
        panel.style.cssText = panel.style.cssText.replace(/--mga-[^;]+;/g, '');

        // Restore normal size - remove restrictions
        panel.style.minWidth = '250px';
        panel.style.maxWidth = '';
        panel.style.fontSize = '13px';
      }

      // Force re-render of current tab to apply new styles
      if (UnifiedState.activeTab) {
        updateTabContent();
      }

      productionLog(`üì± Ultra-compact mode ${enabled ? 'applied' : 'removed'}`);
    }

    // Cache for scale calculations
    const scaleCache = new Map();

    function applyDynamicScaling(element, width) {
      // Don't override ultra-compact mode
      if (element.classList.contains('mga-ultra-compact')) {
        return;
      }

      // Use cached scale if available for this width range
      const widthRange = Math.floor(width / 50) * 50; // Round to nearest 50px
      let scale = scaleCache.get(widthRange);

      if (scale === undefined) {
        // Calculate scale only once per range
        scale = 1;
        if (width < 350) {
          scale = 0.8;
        } else if (width < 450) {
          scale = 0.85;
        } else if (width < 550) {
          scale = 0.9;
        } else if (width < 650) {
          scale = 0.95;
        } else if (width >= 800) {
          scale = 1.05;
        }
        scaleCache.set(widthRange, scale);
      }

      // Only update if scale changed (avoid string conversion cost)
      const elementId = element.id || 'default';
      const lastScale = element._lastScale;
      if (lastScale !== scale) {
        element._lastScale = scale;
        element.style.setProperty('--panel-scale', scale);
      }
    }

    function updateTabResponsiveness(element) {
      // This function was causing tabs to lose their popout buttons and text to truncate
      // Now we use horizontal scrolling with navigation arrows instead
      // Just handle scrolling the active tab into view if needed
      const tabs = element.querySelectorAll('.mga-tab');
      const tabsContainer = element.querySelector('.mga-tabs');

      if (!tabsContainer || tabs.length === 0) return;

      // Ensure active tab is visible by scrolling if necessary
      const activeTab = element.querySelector('.mga-tab.active');
      if (activeTab && tabsContainer.scrollWidth > tabsContainer.clientWidth) {
        const tabRect = activeTab.getBoundingClientRect();
        const containerRect = tabsContainer.getBoundingClientRect();

        if (tabRect.right > containerRect.right) {
          tabsContainer.scrollLeft += tabRect.right - containerRect.right + 10;
        } else if (tabRect.left < containerRect.left) {
          tabsContainer.scrollLeft -= containerRect.left - tabRect.left + 10;
        }
      }
    }

    // ==================== ABILITY MONITORING ====================
    // OPTIMIZED: Batch DOM updates and only update when necessary
    let pendingAbilityUpdates = false;

    // Helper function to get crop info from garden (only if unambiguous)
    function getGardenCropIfUnique() {
      const tileObjects = window.gardenInfo?.garden?.tileObjects;
      if (!tileObjects) return null;

      // Count unique species (only plants, not empty tiles)
      const speciesSet = new Set();
      const tiles = Object.values(tileObjects);

      tiles.forEach(tile => {
        if (tile?.species && tile.objectType === 'plant') {
          speciesSet.add(tile.species);
        }
      });

      // Only return if there's exactly ONE unique species (unambiguous)
      // If multiple crops, we can't know which one was affected
      if (speciesSet.size === 1) {
        return Array.from(speciesSet)[0];
      }

      return null; // Multiple crops or no crops - can't determine accurately
    }

    function monitorPetAbilities() {
      if (!UnifiedState.atoms.petAbility || !UnifiedState.atoms.activePets) return;

      let hasNewAbility = false;

      UnifiedState.atoms.activePets.forEach((pet, index) => {
        if (!pet || !pet.id) return;

        const abilityData = UnifiedState.atoms.petAbility[pet.id];
        if (!abilityData || !abilityData.lastAbilityTrigger) return;

        const trigger = abilityData.lastAbilityTrigger;
        const currentTimestamp = trigger.performedAt;

        // BUGFIX v1.11.4: Skip logging if pet is unfed (hunger = 0)
        // Game shows "feed your pet" notification but creates empty trigger
        if (!currentTimestamp || pet.hunger === 0) {
          productionLog(`üö´ [ABILITY-SKIP] Pet ${pet.petSpecies} unfed (hunger: ${pet.hunger}) - skipping ability log`);
          return;
        }

        // BUGFIX v1.11.4: Additional validation - skip if trigger has no valid ability ID
        // This prevents fake ability logs from unfed pet notifications
        if (!trigger.abilityId || trigger.abilityId === 'Unknown' || trigger.abilityId === '') {
          productionLog(`üö´ [ABILITY-SKIP] Invalid ability ID for ${pet.petSpecies} - likely unfed pet notification`);
          return;
        }

        // Check if this is a new trigger - use UnifiedState instead of window variables
        if (!UnifiedState.data.lastAbilityTimestamps) {
          UnifiedState.data.lastAbilityTimestamps = {};
        }

        const lastKnown = UnifiedState.data.lastAbilityTimestamps[pet.id];

        // Exact match - definitely already logged
        if (lastKnown === currentTimestamp) {
          return;
        }

        // Additional validation: If timestamp is very recent (within 3 seconds), skip
        // BUGFIX v3.7.8: Reduced from 10s to 3s to allow rapid abilities (Gold Granter ‚Üí Rainbow Granter)
        // This prevents false triggers on page refresh when same ability state reloads
        if (lastKnown && Math.abs(currentTimestamp - lastKnown) < 3000) {
          if (UnifiedState.data.settings?.debugMode) {
            productionLog(
              `üö´ [ABILITY-SKIP] ${pet.petSpecies} - Timestamp too close to last (${Math.abs(currentTimestamp - lastKnown)}ms)`
            );
          }
          return;
        }

        // Check if this exact log already exists in recent entries (prevents race condition duplicates)
        const isDuplicate = UnifiedState.data.petAbilityLogs
          .slice(0, 10)
          .some(log => log.timestamp === currentTimestamp && log.petName && log.petName.includes(pet.petSpecies));

        if (isDuplicate) {
          if (UnifiedState.data.settings?.debugMode) {
            productionLog(`üö´ [ABILITY-SKIP] ${pet.petSpecies} - Already in recent logs (duplicate prevention)`);
          }
          return;
        }

        UnifiedState.data.lastAbilityTimestamps[pet.id] = currentTimestamp;
        hasNewAbility = true;

        // Save ability timestamps to prevent duplicate logging after refresh
        MGA_debouncedSave('MGA_lastAbilityTimestamps', UnifiedState.data.lastAbilityTimestamps);

        // BUGFIX: Enrich ability data with crop info if missing (only when unambiguous)
        const enrichedData = trigger.data ? { ...trigger.data } : {};

        // For granter abilities (Gold/Rainbow), try to add crop name if missing
        const abilityId = trigger.abilityId || '';
        if (abilityId.includes('Granter') && !enrichedData.cropName) {
          // Strategy 1: Check currentCrop (works for single-crop users)
          const currentCrop = window.currentCrop || UnifiedState.atoms.currentCrop;
          if (currentCrop && currentCrop[0]?.species) {
            enrichedData.cropName = currentCrop[0].species;
          } else {
            // Strategy 2: Check garden tiles (only if exactly ONE crop type exists)
            // This prevents showing wrong crop when multiple crop types are growing
            const uniqueCrop = getGardenCropIfUnique();
            if (uniqueCrop) {
              enrichedData.cropName = uniqueCrop;
            }
            // Otherwise: No crop name added (honest about uncertainty)
          }
        }

        // Create display name with custom name if available
        let displayName = pet.petSpecies || `Pet ${index + 1}`;
        if (pet.name && pet.name !== pet.petSpecies) {
          // Show as "CustomName (Species)"
          displayName = `${pet.name} (${pet.petSpecies || 'Pet'})`;
        }

        // Normalize ability name to fix potential typos (e.g., "Seed FinderII" ‚Üí "Seed Finder II")
        const rawAbilityType = trigger.abilityId || 'Unknown Ability';
        const normalizedAbilityType = normalizeAbilityName(rawAbilityType);

        const abilityLog = {
          petName: displayName,
          abilityType: normalizedAbilityType,
          timestamp: currentTimestamp,
          timeString: formatTimestamp(currentTimestamp),
          data: Object.keys(enrichedData).length > 0 ? enrichedData : null
        };

        logDebug('ABILITY-LOGS', 'Adding NEW ability log:', {
          ability: abilityLog.abilityType,
          pet: abilityLog.petName,
          time: abilityLog.timeString,
          currentLogCount: UnifiedState.data.petAbilityLogs.length
        });

        UnifiedState.data.petAbilityLogs.unshift(abilityLog);

        // Apply memory management to keep recent logs in memory, archive older ones
        UnifiedState.data.petAbilityLogs = MGA_manageLogMemory(UnifiedState.data.petAbilityLogs);

        // Use debounced save to reduce I/O operations during frequent ability triggers
        // Only save if not in clear session
        const clearSession = localStorage.getItem('MGA_logs_clear_session');
        if (!clearSession || Date.now() - parseInt(clearSession, 10) > 86400000) {
          MGA_debouncedSave('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
        } else {
          logDebug('ABILITY-LOGS', '‚è∏Ô∏è Skipping save - clear session active');
        }

        // Check if we should notify for this ability
        if (UnifiedState.data.settings.notifications.abilityNotificationsEnabled) {
          const abilityType = trigger.abilityId || '';

          // Filter out ProduceMutationBoost/PetMutationBoost - these are passive and shouldn't trigger notifications
          if (
            abilityType &&
            (abilityType.includes('ProduceMutationBoost') || abilityType.includes('PetMutationBoost'))
          ) {
            return; // Skip notification for mutation boosts
          }

          // Check individual abilities list
          const watchedAbilities = UnifiedState.data.settings.notifications.watchedAbilities || [];

          // Logic:
          // - Empty array = all abilities enabled (default/backward compatible)
          // - ['__NONE__'] = no abilities enabled (user clicked "Select None")
          // - [...abilities] = only those specific abilities enabled
          let shouldNotify = false;

          if (watchedAbilities.length === 0) {
            // Empty array means all abilities
            shouldNotify = true;
          } else if (watchedAbilities.includes('__NONE__')) {
            // Special marker means none
            shouldNotify = false;
          } else {
            // Check if this specific ability is in the list
            shouldNotify = watchedAbilities.includes(abilityType);
          }

          if (shouldNotify) {
            const displayAbilityName = normalizeAbilityName(abilityType);
            productionLog(`üéØ [ABILITY-NOTIFY] ${abilityLog.petName} triggered ${displayAbilityName}`);

            // Play ability notification sound based on settings
            const abilityVolume = UnifiedState.data.settings.notifications.abilityNotificationVolume || 0.2;
            playAbilityNotificationSound(abilityVolume);

            // Show toast
            showNotificationToast(`‚ú® ${abilityLog.petName}: ${displayAbilityName}`, 'success');
          }
        }
      });

      // PERFORMANCE OPTIMIZATION: Debounce ability log updates to prevent spam
      // Max 1 update per 500ms even if multiple abilities trigger rapidly
      if (hasNewAbility && document.visibilityState === 'visible') {
        if (!pendingAbilityUpdates) {
          pendingAbilityUpdates = true;

          // Debounce: Wait 500ms before updating to batch rapid ability triggers
          setTimeout(() => {
            requestAnimationFrame(() => {
              updateAllAbilityLogDisplays();

              if (UnifiedState.activeTab === 'abilities') {
                updateTabContent();
              }

              // BUGFIX: Removed duplicate overlay update loop
              // updateAllAbilityLogDisplays() already handles all overlays at line 13548
              // Duplicate updates were causing race conditions when both tab and pop-up were open

              pendingAbilityUpdates = false;
            });
          }, 500); // OPTIMIZED: 500ms debounce window
        }
      }
    }

    function exportAbilityLogs() {
      const allLogs = MGA_getAllLogs();
      if (!allLogs.length) {
        productionWarn('‚ö†Ô∏è No logs to export!');
        return;
      }

      const headers = 'Date,Time,Pet Name,Ability Type,Details\r\n';
      const csvContent = allLogs
        .map(log => {
          const date = new Date(log.timestamp);
          return [
            date.toLocaleDateString(),
            date.toLocaleTimeString(),
            log.petName,
            normalizeAbilityName(log.abilityType),
            JSON.stringify(log.data || '')
          ]
            .map(field => `"${String(field).replace(/"/g, '""')}"`)
            .join(',');
        })
        .join('\r\n');

      const blob = new Blob([headers + csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = targetDocument.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `MagicGarden_AbilityLogs_${new Date().toISOString().split('T')[0]}.csv`;
      link.click();
    }

    // ==================== VALUE CALCULATIONS ====================
    const speciesValues = {
      Sunflower: 750000,
      Starweaver: 10000000,
      DawnCelestial: 11000000,
      MoonCelestial: 11000000,
      Lychee: 50000,
      DragonFruit: 24500,
      PassionFruit: 24500,
      Lemon: 10000,
      Pepper: 7220,
      Grape: 7085,
      Bamboo: 500000,
      Cactus: 287000,
      Mushroom: 160000,
      BurrosTail: 6000,
      Lily: 20123,
      Banana: 1750,
      Coconut: 302,
      Echeveria: 5520,
      Pumpkin: 3700,
      Watermelon: 2708,
      Corn: 36,
      Daffodil: 1090,
      Tomato: 27,
      OrangeTulip: 767,
      Apple: 73,
      Blueberry: 23,
      Aloe: 310,
      Strawberry: 14,
      Carrot: 20
    };

    // Mutation calculation matching FriendsScript logic
    const COLOR_MULT = {
      Gold: 25,
      Rainbow: 50
    };

    const WEATHER_MULT = {
      Wet: 2,
      Chilled: 2,
      Frozen: 10
    };

    const TIME_MULT = {
      Dawnlit: 2,
      Dawnbound: 3,
      Dawncharged: 3, // Same as Dawnbound
      Amberlit: 5,
      Ambershine: 5, // Internal game name for Amberlit
      Amberbound: 6,
      Ambercharged: 6 // Same as Amberbound
    };

    const WEATHER_TIME_COMBO = {
      'Wet+Dawnlit': 3,
      'Chilled+Dawnlit': 3,
      'Wet+Amberlit': 6,
      'Chilled+Amberlit': 6,
      'Wet+Ambershine': 6, // Internal game name for Amberlit
      'Chilled+Ambershine': 6, // Internal game name for Amberlit
      'Frozen+Dawnlit': 11,
      'Frozen+Dawnbound': 12,
      'Frozen+Dawncharged': 12, // Same as Dawnbound
      'Frozen+Amberlit': 14,
      'Frozen+Ambershine': 14, // Internal game name for Amberlit
      'Frozen+Amberbound': 15,
      'Frozen+Ambercharged': 15 // Same as Amberbound
    };

    function calculateMutationMultiplier(mutations) {
      if (!mutations || !Array.isArray(mutations)) return 1;

      // Pick best color multiplier
      let color = 1;
      for (const m of mutations) {
        if (m === 'Rainbow' && COLOR_MULT.Rainbow > color) color = COLOR_MULT.Rainbow;
        if (m === 'Gold' && COLOR_MULT.Gold > color) color = COLOR_MULT.Gold;
      }

      // Pick best weather
      let weather = null;
      for (const m of mutations) {
        if (WEATHER_MULT[m]) {
          if (!weather || WEATHER_MULT[m] > WEATHER_MULT[weather]) {
            weather = m;
          }
        }
      }

      // Pick best time
      let time = null;
      for (const m of mutations) {
        if (TIME_MULT[m]) {
          if (!time || TIME_MULT[m] > TIME_MULT[time]) {
            time = m;
          }
        }
      }

      // Calculate weather+time multiplier
      let wt = 1;
      if (!weather && !time) wt = 1;
      else if (weather && !time) wt = WEATHER_MULT[weather];
      else if (!weather && time) wt = TIME_MULT[time];
      else {
        const combo = `${weather}+${time}`;
        wt = WEATHER_TIME_COMBO[combo] || Math.max(WEATHER_MULT[weather], TIME_MULT[time]);
      }

      return Math.round(color * wt);
    }

    // ==================== ENHANCED VALUE MANAGER ====================
    class ValueManager {
      constructor() {
        this.cache = {
          inventoryValue: { value: 0, lastUpdate: 0 },
          tileValue: { value: 0, lastUpdate: 0 },
          gardenValue: { value: 0, lastUpdate: 0 }
        };
        this.throttleMs = 100; // 100ms throttle for value calculations
        this.retryAttempts = 3;
        this.observer = null;

        this.initializeObserver();
        debugLog('VALUE_MANAGER', 'ValueManager initialized', { throttleMs: this.throttleMs });
      }

      initializeObserver() {
        // Create MutationObserver to detect game state changes
        if (typeof MutationObserver !== 'undefined') {
          this.observer = new MutationObserver(mutations => {
            let shouldUpdate = false;
            mutations.forEach(mutation => {
              // Check if changes are related to inventory or game state
              if (
                mutation.target.className &&
                (mutation.target.className.includes('inventory') ||
                  mutation.target.className.includes('garden') ||
                  mutation.target.className.includes('crop'))
              ) {
                shouldUpdate = true;
              }
            });

            if (shouldUpdate) {
              this.invalidateCache();
              debugLog('VALUE_MANAGER', 'Game state change detected, invalidating cache');
            }
          });

          // Observe body for any game-related changes
          this.observer.observe(targetDocument.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['class', 'data-value']
          });
        }
      }

      getTileValue(forceRefresh = false) {
        return this.getCachedValue('tileValue', forceRefresh, () => this.calculateTileValue());
      }

      getInventoryValue(forceRefresh = false) {
        return this.getCachedValue('inventoryValue', forceRefresh, () => this.calculateInventoryValue());
      }

      getGardenValue(forceRefresh = false) {
        return this.getCachedValue('gardenValue', forceRefresh, () => this.calculateGardenValue());
      }

      getCachedValue(type, forceRefresh, calculator) {
        const cached = this.cache[type];
        const now = Date.now();

        if (!forceRefresh && cached && now - cached.lastUpdate < this.throttleMs) {
          return cached.value;
        }

        // Calculate new value with retry mechanism
        let attempts = 0;
        let value = 0;

        while (attempts < this.retryAttempts) {
          try {
            value = calculator();
            break;
          } catch (error) {
            attempts++;
            debugError('VALUE_MANAGER', `Calculation failed for ${type}, attempt ${attempts}`, error);

            if (attempts >= this.retryAttempts) {
              // Use cached value if all retries fail
              value = cached ? cached.value : 0;
              debugLog('VALUE_MANAGER', `Using cached value for ${type} after ${attempts} failures`);
            } else {
              // Brief delay before retry
              setTimeout(() => {}, 10 * attempts);
            }
          }
        }

        // Update cache
        this.cache[type] = {
          value,
          lastUpdate: now
        };

        return value;
      }

      calculateTileValue() {
        const currentCrop = UnifiedState.atoms.currentCrop;
        const friendBonus = UnifiedState.atoms.friendBonus || 1;
        let tileValue = 0;

        if (currentCrop && currentCrop.length) {
          currentCrop.forEach(slot => {
            if (slot && slot.species) {
              const multiplier = calculateMutationMultiplier(slot.mutations);
              const speciesVal = speciesValues[slot.species] || 0;
              const scale = slot.targetScale || 1;
              tileValue += Math.round(multiplier * speciesVal * scale * friendBonus);
            }
          });
        }

        return tileValue;
      }

      calculateInventoryValue() {
        const inventory = UnifiedState.atoms.inventory;
        const friendBonus = UnifiedState.atoms.friendBonus || 1;
        let inventoryValue = 0;

        if (inventory && inventory.items) {
          inventory.items.forEach(item => {
            if (item.itemType === 'Produce' && item.species) {
              const multiplier = calculateMutationMultiplier(item.mutations);
              const speciesVal = speciesValues[item.species] || 0;
              const scale = item.scale || 1;
              inventoryValue += Math.round(multiplier * speciesVal * scale * friendBonus);
            }
          });
        }

        return inventoryValue;
      }

      calculateGardenValue() {
        const myGarden = UnifiedState.atoms.myGarden;
        const friendBonus = UnifiedState.atoms.friendBonus || 1;
        let gardenValue = 0;

        if (myGarden && myGarden.garden && myGarden.garden.tileObjects) {
          const now = Date.now();
          Object.values(myGarden.garden.tileObjects).forEach(tile => {
            if (tile.objectType === 'plant' && tile.slots) {
              tile.slots.forEach(slot => {
                if (slot && slot.species && slot.endTime && now >= slot.endTime) {
                  const multiplier = calculateMutationMultiplier(slot.mutations);
                  const speciesVal = speciesValues[slot.species] || 0;
                  const scale = slot.targetScale || 1;
                  gardenValue += Math.round(multiplier * speciesVal * scale * friendBonus);
                }
              });
            }
          });
        }

        return gardenValue;
      }

      updateAllValues(forceRefresh = false) {
        const tileValue = this.getTileValue(forceRefresh);
        const inventoryValue = this.getInventoryValue(forceRefresh);
        const gardenValue = this.getGardenValue(forceRefresh);

        // Store in UnifiedState
        UnifiedState.data.tileValue = tileValue;
        UnifiedState.data.inventoryValue = inventoryValue;
        UnifiedState.data.gardenValue = gardenValue;

        // Update UI if values tab is active
        this.updateValueDisplays();

        debugLog('VALUE_MANAGER', 'All values updated', {
          tileValue,
          inventoryValue,
          gardenValue,
          cached: Object.keys(this.cache).map(k => `${k}: ${Date.now() - this.cache[k].lastUpdate}ms ago`)
        });

        return { tileValue, inventoryValue, gardenValue };
      }

      updateValueDisplays() {
        // Update main window if values tab is active
        if (UnifiedState.activeTab === 'values') {
          updateTabContent();
        }

        // Update all overlay windows showing values tab
        UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
          if (overlay && document.contains(overlay) && tabName === 'values') {
            if (overlay.className.includes('mga-overlay-content-only')) {
              updatePureOverlayContent(overlay, tabName);
              debugLog('VALUE_MANAGER', 'Updated pure values overlay');
            } else {
              // Legacy overlay structure
              const overlayContent = overlay.querySelector('.mga-overlay-content > div');
              if (overlayContent) {
                overlayContent.innerHTML = getValuesTabContent();
                debugLog('VALUE_MANAGER', 'Updated legacy values overlay');
              }
            }
          }
        });

        // Update separate windows
        UnifiedState.data.popouts.windows.forEach((windowRef, tabName) => {
          if (windowRef && !windowRef.closed && tabName === 'values') {
            try {
              const freshContent = getValuesTabContent();
              const contentElement = windowRef.document.getElementById('content');
              if (contentElement) {
                contentElement.innerHTML = freshContent;
                // Set up dashboard handlers in the separate window
                if (window.resourceDashboard) {
                  window.resourceDashboard.setupDashboardHandlers(windowRef.document);
                }
                debugLog('VALUE_MANAGER', 'Updated values in separate window');
              }
            } catch (error) {
              debugError('VALUE_MANAGER', 'Failed to update separate window', error);
            }
          }
        });
      }

      invalidateCache() {
        Object.keys(this.cache).forEach(key => {
          this.cache[key].lastUpdate = 0;
        });
      }

      getStatus() {
        const now = Date.now();
        return {
          cache: Object.keys(this.cache).reduce((acc, key) => {
            const cached = this.cache[key];
            acc[key] = {
              value: cached.value,
              age: now - cached.lastUpdate,
              fresh: now - cached.lastUpdate < this.throttleMs
            };
            return acc;
          }, {}),
          throttleMs: this.throttleMs,
          retryAttempts: this.retryAttempts
        };
      }

      destroy() {
        if (this.observer) {
          this.observer.disconnect();
          this.observer = null;
        }
      }
    }

    // Initialize global ValueManager
    let globalValueManager = null;

    function initializeValueManager() {
      if (!globalValueManager) {
        globalValueManager = new ValueManager();
      }
      return globalValueManager;
    }

    function updateValues() {
      // Use enhanced ValueManager instead of manual calculations
      const valueManager = globalValueManager || initializeValueManager();
      valueManager.updateAllValues();

      // Refresh Values tab if it's currently active
      if (UnifiedState.activeTab === 'values') {
        updateTabContent();
      }

      // Refresh any open Values overlays
      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
        if (overlay && document.contains(overlay) && tabName === 'values') {
          if (overlay.className.includes('mga-overlay-content-only')) {
            updatePureOverlayContent(overlay, tabName);
          }
        }
      });

      // Refresh Values in separate window popouts
      refreshSeparateWindowPopouts('values');

      debugLog('VALUES_UPDATE', 'Values updated and UI refreshed');
    }

    // ==================== SEED DELETION ====================
    function deleteSelectedSeeds() {
      if (
        !UnifiedState.atoms.inventory ||
        !UnifiedState.atoms.inventory.items ||
        !UnifiedState.data.seedsToDelete.length
      ) {
        productionWarn('‚ö†Ô∏è No seeds selected for deletion!');
        return;
      }

      // Confirmation dialog for manual deletion
      const selectedSeedsText = UnifiedState.data.seedsToDelete.join(', ');
      const confirmMessage = `‚ö†Ô∏è WARNING: This action is IRREVERSIBLE!\n\nYou are about to permanently delete the following seeds:\n${selectedSeedsText}\n\nThis cannot be undone. Are you sure you want to continue?`;

      if (!confirm(confirmMessage)) {
        return;
      }

      // seedsToDelete now contains internal IDs (e.g., "OrangeTulip"), so direct comparison works
      productionLog('üå± [SEED-DELETE-DEBUG] Deletion attempt:', {
        seedsToDelete: UnifiedState.data.seedsToDelete,
        inventoryItems:
          UnifiedState.atoms.inventory.items?.map(item => ({ species: item.species, quantity: item.quantity })) ||
          'No inventory',
        inventoryCount: UnifiedState.atoms.inventory.items?.length || 0
      });

      const itemsToDelete = UnifiedState.atoms.inventory.items.filter(
        item => item && item.species && UnifiedState.data.seedsToDelete.includes(item.species)
      );

      productionLog(
        'üå± [SEED-DELETE-DEBUG] Items found for deletion:',
        itemsToDelete.map(item => ({ species: item.species, quantity: item.quantity }))
      );

      if (!itemsToDelete.length) {
        productionLog('üå± [SEED-DELETE-DEBUG] No matching items found. Details:', {
          selectedSeeds: UnifiedState.data.seedsToDelete,
          availableSpecies: UnifiedState.atoms.inventory.items?.map(item => item.species) || []
        });
        productionWarn('‚ö†Ô∏è No matching seeds found in inventory!');
        return;
      }

      const summary = itemsToDelete.map(item => `${item.species}: ${item.quantity}`).join('\n');

      if (confirm(`Delete the following seeds?\n\n${summary}`)) {
        itemsToDelete.forEach(item => {
          const qty = item.quantity || 0;
          for (let i = 0; i < qty; i++) {
            safeSendMessage({
              scopePath: ['Room', 'Quinoa'],
              type: 'Wish',
              itemId: item.species
            });
          }
        });

        // Clear selections
        UnifiedState.data.seedsToDelete = [];

        // Clear checkboxes in main panel
        targetDocument.querySelectorAll('.seed-checkbox').forEach(cb => (cb.checked = false));

        // Update main tab content
        if (UnifiedState.activeTab === 'seeds') {
          updateTabContent();
        }

        // Update all seed overlays
        UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
          if (overlay && document.contains(overlay) && tabName === 'seeds') {
            if (overlay.className.includes('mga-overlay-content-only')) {
              updatePureOverlayContent(overlay, tabName);
              // Also clear checkboxes in overlay
              overlay.querySelectorAll('.seed-checkbox').forEach(cb => (cb.checked = false));
              debugLog('OVERLAY_LIFECYCLE', 'Updated pure seeds overlay after deletion');
            }
          }
        });

        // Update separate window popouts
        refreshSeparateWindowPopouts('seeds');
      }
    }

    function startAutoDelete() {
      if (!UnifiedState.data.autoDeleteEnabled) return;

      // Clear existing interval to prevent multiple intervals
      clearManagedInterval('autoDelete');

      // Use managed interval to prevent memory leaks
      setManagedInterval(
        'autoDelete',
        () => {
          if (UnifiedState.data.autoDeleteEnabled && UnifiedState.data.seedsToDelete.length) {
            const inventory = UnifiedState.atoms.inventory;
            if (!inventory || !inventory.items) return;

            // seedsToDelete now contains internal IDs (e.g., "OrangeTulip"), so direct comparison works
            UnifiedState.data.seedsToDelete.forEach(seedToDelete => {
              const matchingItems = inventory.items.filter(
                item => item && item.species && item.species === seedToDelete
              );

              matchingItems.forEach(item => {
                const qty = item.quantity || 0;
                for (let i = 0; i < qty; i++) {
                  safeSendMessage({
                    scopePath: ['Room', 'Quinoa'],
                    type: 'Wish',
                    itemId: seedToDelete
                  });
                }
              });
            });
          }
        },
        2000
      );
    }

    function stopAutoDelete() {
      clearManagedInterval('autoDelete');
      UnifiedState.data.autoDeleteEnabled = false;
      debugLog('PERFORMANCE', 'Auto-delete stopped and disabled');
    }

    // ==================== TIMERS ====================
    // ==================== ENHANCED TIMER MANAGER ====================
    class TimerManager {
      constructor() {
        this.activeTimers = new Map();
        this.isRunning = false;
        this.animationFrameId = null;
        this.lastHeartbeat = Date.now();
        this.heartbeatInterval = 1000; // 1 second heartbeat
        this.frozenThreshold = 3000; // 3 seconds to consider frozen

        // Initialize active timers storage
        if (!UnifiedState.data.activeTimers) {
          UnifiedState.data.activeTimers = {};
        }

        this.loadPersistedTimers();
        this.startHeartbeat();

        debugLog('TIMER_MANAGER', 'TimerManager initialized', {
          heartbeatInterval: this.heartbeatInterval,
          frozenThreshold: this.frozenThreshold
        });
      }

      startTimer(id, callback, interval = 1000) {
        if (this.activeTimers.has(id)) {
          this.stopTimer(id);
        }

        const timer = {
          id,
          callback,
          interval,
          lastRun: Date.now(),
          running: true,
          frozen: false
        };

        this.activeTimers.set(id, timer);
        UnifiedState.data.activeTimers[id] = {
          interval,
          lastRun: timer.lastRun,
          running: true
        };

        this.saveTimerState();

        if (!this.isRunning) {
          this.startMainLoop();
        }

        debugLog('TIMER_MANAGER', `Timer started: ${id}`, { interval });
        return timer;
      }

      stopTimer(id) {
        if (this.activeTimers.has(id)) {
          this.activeTimers.delete(id);
          delete UnifiedState.data.activeTimers[id];
          this.saveTimerState();
          debugLog('TIMER_MANAGER', `Timer stopped: ${id}`);
        }
      }

      pauseAll() {
        this.activeTimers.forEach((timer, id) => {
          timer.running = false;
          UnifiedState.data.activeTimers[id].running = false;
        });
        this.saveTimerState();
        debugLog('TIMER_MANAGER', 'All timers paused');
      }

      resumeAll() {
        this.activeTimers.forEach((timer, id) => {
          timer.running = true;
          timer.lastRun = Date.now(); // Reset to prevent immediate execution
          UnifiedState.data.activeTimers[id].running = true;
          UnifiedState.data.activeTimers[id].lastRun = timer.lastRun;
        });
        this.saveTimerState();
        debugLog('TIMER_MANAGER', 'All timers resumed');
      }

      startMainLoop() {
        if (this.isRunning) return;

        this.isRunning = true;
        const loop = currentTime => {
          if (!this.isRunning || this.activeTimers.size === 0) {
            this.isRunning = false;
            this.animationFrameId = null;
            return;
          }

          this.processTimers(currentTime);
          this.animationFrameId = requestAnimationFrame(loop);
        };

        this.animationFrameId = requestAnimationFrame(loop);
        debugLog('TIMER_MANAGER', 'Main loop started');
      }

      processTimers(currentTime) {
        this.activeTimers.forEach((timer, id) => {
          if (!timer.running) return;

          const elapsed = currentTime - timer.lastRun;
          if (elapsed >= timer.interval) {
            try {
              timer.callback();
              timer.lastRun = currentTime;
              timer.frozen = false;
              UnifiedState.data.activeTimers[id].lastRun = timer.lastRun;
            } catch (error) {
              debugError('TIMER_MANAGER', `Timer callback error for ${id}`, error);
            }
          }
        });
      }

      startHeartbeat() {
        const heartbeat = () => {
          const now = Date.now();
          const timeSinceLastBeat = now - this.lastHeartbeat;

          // Detect if main loop is frozen
          if (this.isRunning && timeSinceLastBeat > this.frozenThreshold) {
            debugLog('TIMER_MANAGER', 'Heartbeat detected frozen timers, restarting main loop', {
              timeSinceLastBeat
            });
            this.restartMainLoop();
          }

          // Check individual timers for freezing
          this.checkForFrozenTimers(now);

          this.lastHeartbeat = now;
          setTimeout(heartbeat, this.heartbeatInterval);
        };

        // Start first heartbeat
        setTimeout(heartbeat, this.heartbeatInterval);
        debugLog('TIMER_MANAGER', 'Heartbeat monitor started');
      }

      checkForFrozenTimers(now) {
        this.activeTimers.forEach((timer, id) => {
          if (!timer.running) return;

          const timeSinceLastRun = now - timer.lastRun;
          const expectedRuns = Math.floor(timeSinceLastRun / timer.interval);

          if (expectedRuns > 2 && !timer.frozen) {
            debugLog('TIMER_MANAGER', `Timer appears frozen: ${id}`, {
              timeSinceLastRun,
              expectedRuns,
              interval: timer.interval
            });
            timer.frozen = true;
            this.restartTimer(id);
          }
        });
      }

      restartTimer(id) {
        const timer = this.activeTimers.get(id);
        if (timer) {
          timer.lastRun = Date.now();
          timer.frozen = false;
          debugLog('TIMER_MANAGER', `Timer restarted: ${id}`);
        }
      }

      restartMainLoop() {
        if (this.animationFrameId) {
          cancelAnimationFrame(this.animationFrameId);
          this.animationFrameId = null;
        }
        this.isRunning = false;
        setTimeout(() => this.startMainLoop(), 100); // Small delay before restart
      }

      saveTimerState() {
        try {
          MGA_saveJSON('MGA_timerStates', UnifiedState.data.activeTimers);
        } catch (error) {
          debugError('TIMER_MANAGER', 'Failed to save timer state', error);
        }
      }

      loadPersistedTimers() {
        try {
          const saved = MGA_loadJSON('MGA_timerStates', {});
          UnifiedState.data.activeTimers = { ...saved };
          debugLog('TIMER_MANAGER', 'Loaded persisted timer states', {
            count: Object.keys(saved).length
          });
        } catch (error) {
          debugError('TIMER_MANAGER', 'Failed to load persisted timers', error);
        }
      }

      getStatus() {
        return {
          isRunning: this.isRunning,
          activeCount: this.activeTimers.size,
          frozenCount: Array.from(this.activeTimers.values()).filter(t => t.frozen).length,
          lastHeartbeat: this.lastHeartbeat
        };
      }
    }

    // Initialize global TimerManager
    let globalTimerManager = null;

    function initializeTimerManager() {
      if (!globalTimerManager) {
        globalTimerManager = new TimerManager();
      }
      return globalTimerManager;
    }

    function updateTimers() {
      // Update restock timers
      const quinoaData = UnifiedState.atoms.quinoaData;
      if (quinoaData && quinoaData.shops) {
        UnifiedState.data.timers.seed = (quinoaData.shops.seed && quinoaData.shops.seed.secondsUntilRestock) || null;
        UnifiedState.data.timers.egg = (quinoaData.shops.egg && quinoaData.shops.egg.secondsUntilRestock) || null;
        UnifiedState.data.timers.tool = (quinoaData.shops.tool && quinoaData.shops.tool.secondsUntilRestock) || null;
      }

      // Calculate lunar event
      const lunarResult = getSecondsToNextLunarEvent();
      UnifiedState.data.timers.lunar = lunarResult.secondsLeft;

      // Note: checkForWatchedItems() now runs on its own 5-second interval

      // Always update timer display (needed for pop-out windows to work independently)
      updateTimerDisplay();
    }

    function getSecondsToNextLunarEvent() {
      const eventZone = 'America/Chicago';
      const lunarHours = [3, 7, 11, 15, 19, 23];

      // Get current time in Central Time Zone
      const now = new Date();
      const centralTime = new Date(now.toLocaleString('en-US', { timeZone: eventZone }));

      const currentHour = centralTime.getHours();
      const currentMin = centralTime.getMinutes();
      const currentSec = centralTime.getSeconds();

      // Find next lunar event hour
      let nextEventHour = null;
      for (const eventHour of lunarHours) {
        if (eventHour > currentHour || (eventHour === currentHour && currentMin === 0 && currentSec === 0)) {
          nextEventHour = eventHour;
          break;
        }
      }

      // If no event found today, get first event tomorrow
      if (nextEventHour === null) {
        nextEventHour = lunarHours[0];
      }

      // Create next event date in Central Time
      const nextEvent = new Date(centralTime);
      nextEvent.setHours(nextEventHour, 0, 0, 0);

      // If event is in the past today, move to tomorrow
      if (nextEvent <= centralTime) {
        nextEvent.setDate(nextEvent.getDate() + 1);
      }

      // Calculate seconds until event (precise calculation without manual adjustment)
      const secondsLeft = Math.max(0, Math.floor((nextEvent.getTime() - centralTime.getTime()) / 1000));

      return {
        secondsLeft: secondsLeft, // Precise calculation without manual adjustment
        eventDateLocal: nextEvent
      };
    }

    // PERFORMANCE OPTIMIZATION: Cache timer elements to avoid repeated DOM queries
    let cachedTimerElements = {
      'timer-seed': [],
      'timer-egg': [],
      'timer-tool': [],
      'timer-lunar': []
    };
    let lastTimerElementCacheTime = 0;
    const TIMER_ELEMENT_CACHE_DURATION = 5000; // Refresh cache every 5 seconds

    function refreshTimerElementCache() {
      const timerIds = ['timer-seed', 'timer-egg', 'timer-tool', 'timer-lunar'];

      timerIds.forEach(id => {
        const elements = [];

        // Main window element
        const mainEl = document.getElementById(id);
        if (mainEl) elements.push(mainEl);

        // Overlay elements
        UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
          if (overlay && document.contains(overlay)) {
            const overlayEl = overlay.querySelector(`#${id}`);
            if (overlayEl) elements.push(overlayEl);
          }
        });

        // Target document elements (for popouts)
        try {
          const targetEls = targetDocument.querySelectorAll(`#${id}`);
          targetEls.forEach(el => {
            if (!elements.includes(el)) elements.push(el);
          });
        } catch (e) {
          // Ignore errors from closed windows
        }

        cachedTimerElements[id] = elements;
      });

      lastTimerElementCacheTime = Date.now();
    }

    function updateTimerDisplay() {
      const formatTime = seconds => {
        if (seconds == null) return '--:--';
        const s = Math.max(0, Math.floor(seconds));
        const m = Math.floor(s / 60);
        const ss = s % 60;
        return `${m}:${String(ss).padStart(2, '0')}`;
      };

      const formatTimeHoursMinutes = seconds => {
        if (seconds == null) return '--:--';
        const totalMinutes = Math.floor(seconds / 60);
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;

        if (hours > 0) {
          return `${hours}h ${minutes}m`;
        } else {
          return `${minutes}m`;
        }
      };

      // BUGFIX: Initialize cache on first run or refresh if expired
      const now = Date.now();
      if (lastTimerElementCacheTime === 0 || now - lastTimerElementCacheTime > TIMER_ELEMENT_CACHE_DURATION) {
        refreshTimerElementCache();
      }

      // PERFORMANCE: Update cached elements only (no DOM queries in hot path)
      const updateTimerElement = (id, value) => {
        const formatter = id === 'timer-lunar' ? formatTimeHoursMinutes : formatTime;
        const formattedValue = formatter(value);

        const elements = cachedTimerElements[id] || [];

        // FALLBACK: If cache is empty, query directly (first run before cache populated)
        if (elements.length === 0) {
          const el = document.getElementById(id);
          if (el) {
            el.textContent = formattedValue;
          }
          return;
        }

        elements.forEach(el => {
          // Verify element still in DOM before updating
          if (document.contains(el)) {
            el.textContent = formattedValue;
          }
        });
      };

      // Update all timer types
      updateTimerElement('timer-seed', UnifiedState.data.timers.seed);
      updateTimerElement('timer-egg', UnifiedState.data.timers.egg);
      updateTimerElement('timer-tool', UnifiedState.data.timers.tool);
      updateTimerElement('timer-lunar', UnifiedState.data.timers.lunar);
    }

    // ==================== DEBUGGING UTILITIES ====================
    window.debugPets = function () {
      productionLog('üîç [DEBUG] Debugging pets data...');
      productionLog('üêæ UnifiedState.atoms.activePets:', UnifiedState.atoms.activePets);
      productionLog('üêæ window.activePets:', window.activePets);

      // Try to access game's pet data directly
      if (targetWindow.MagicCircle_RoomConnection) {
        const roomState = targetWindow.MagicCircle_RoomConnection.lastRoomStateJsonable;
        productionLog('üéÆ Room state pets:', roomState?.child?.data?.petSlots);
        productionLog('üéÆ User slots:', roomState?.child?.data?.userSlots);
      }

      // Check jotai atoms
      if (targetWindow.jotaiAtomCache) {
        const allAtoms = Array.from(targetWindow.jotaiAtomCache.keys());
        const petAtoms = allAtoms.filter(
          key =>
            key.toLowerCase().includes('pet') ||
            key.toLowerCase().includes('slot') ||
            key.toLowerCase().includes('animal')
        );
        productionLog('üîç Pet-related atoms found:', petAtoms);
      }

      productionLog('üè† Presets saved:', Object.keys(UnifiedState.data.petPresets));
    };

    // Manual fallback to force update Active Pets display
    window.forceUpdateActivePets = function () {
      productionLog('üîß [MANUAL] Force updating Active Pets display...');

      // Try to get pets from room state as fallback
      if (targetWindow.MagicCircle_RoomConnection) {
        const roomState = targetWindow.MagicCircle_RoomConnection.lastRoomStateJsonable;
        const petSlots = roomState?.child?.data?.petSlots;

        if (petSlots && Array.isArray(petSlots)) {
          // Convert room state format to our expected format
          const activePetsFromRoom = petSlots
            .filter(slot => slot && slot.item)
            .map(slot => ({
              id: slot.item.id,
              petSpecies: slot.item.species || 'Unknown',
              mutations: slot.item.mutations || []
            }));

          productionLog('üêæ [FALLBACK] Found pets in room state:', activePetsFromRoom);

          // Manually set the active pets data
          UnifiedState.atoms.activePets = activePetsFromRoom;
          window.activePets = activePetsFromRoom;

          // Force update displays
          updateActivePetsDisplay(document);
          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
            if (overlay && document.contains(overlay) && tabName === 'pets') {
              updateActivePetsDisplay(overlay);
            }
          });

          productionLog('‚úÖ [FALLBACK] Active pets display updated manually');
          return activePetsFromRoom;
        }
      }

      productionWarn('‚ùå [FALLBACK] Could not find pet data in room state');
      return null;
    };

    // ==================== INITIALIZATION ====================
    function initializeAtoms() {
      productionLog('üîó [SIMPLE-ATOMS] Starting simple atom initialization...');

      // Start simple pet detection using room state
      productionLog('üêæ [SIMPLE-ATOMS] Setting up room state pet detection...');
      updateActivePetsFromRoomState(); // Get initial pets immediately

      // Set up periodic pet detection (reduced frequency to minimize console spam)
      setManagedInterval(
        'petDetection',
        () => {
          updateActivePetsFromRoomState();

          // ALSO check window.activePets directly (set by atom hook)
          if (window.activePets && Array.isArray(window.activePets) && window.activePets.length > 0) {
            productionLog('üêæ [PERIODIC-CHECK] Found pets in window.activePets:', window.activePets);

            // Update UnifiedState
            if (!UnifiedState.atoms.activePets || UnifiedState.atoms.activePets.length !== window.activePets.length) {
              UnifiedState.atoms.activePets = window.activePets;

              // Force UI update
              if (UnifiedState.activeTab === 'pets') {
                const context = document.getElementById('mga-tab-content');
                if (context) {
                  updateTabContent('pets', context);
                }
              }
            }
          }
        },
        30000
      ); // Check every 30 seconds

      // Hook #1: Pet SPECIES data (for active pets display)
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myPrimitivePetSlotsAtom',
        'activePets',
        petSlots => {
          if (UnifiedState.data.settings?.debugMode) {
            productionLog('üêæ [ATOM-DEBUG] myPetSlotsAtom raw value:', {
              value: petSlots,
              type: typeof petSlots,
              isArray: Array.isArray(petSlots),
              length: petSlots?.length,
              valueIsArray: Array.isArray(petSlots?.value),
              valueLength: petSlots?.value?.length
            });
          }

          // Extract the actual array from the wrapper object
          const actualPetSlots = Array.isArray(petSlots) ? petSlots : petSlots?.value;

          // Extract active pets with species info
          if (Array.isArray(actualPetSlots)) {
            // DEBUG: Log raw slot data to understand structure
            if (UnifiedState.data.settings?.debugMode) {
              actualPetSlots.forEach((slot, i) => {});
            }

            const activePets = actualPetSlots
              .filter(slot => {
                // Check if slot has pet data (handle multiple possible property names)
                const hasPet = slot && (slot.petSpecies || slot.species || slot.petId || slot.id);
                return hasPet;
              })
              .map((slot, index) => {
                const extracted = {
                  id: slot.id || slot.petId || `pet_${index}`,
                  petSpecies: slot.petSpecies || slot.species || 'Unknown',
                  mutations: slot.mutations || [],
                  abilities: slot.abilities || [],
                  hunger: slot.hunger ?? slot.petHunger ?? slot.health ?? 100, // Include hunger for pet hunger notifications
                  xp: slot.xp || 0, // CRITICAL: Required for turtle timer experience calculation
                  targetScale: slot.targetScale || slot.scale || 1, // CRITICAL: Required for turtle timer scale bonus calculation
                  strength: slot.strength || slot.str || 100, // Include strength for Hunger Boost calculations
                  str: slot.str || slot.strength || 100, // Fallback property name
                  slot: index + 1
                };

                if (UnifiedState.data.settings?.debugMode) {
                }

                return extracted;
              });

            if (UnifiedState.data.settings?.debugMode) {
              productionLog('üêæ [PETS] Extracted active pets:', activePets);
            }

            const previousCount = UnifiedState.atoms.activePets?.length || 0;
            const previousPets = UnifiedState.atoms.activePets || [];

            // Check if pets changed (count OR species/abilities)
            const petsChanged =
              activePets.length !== previousCount ||
              JSON.stringify(activePets.map(p => ({ s: p.petSpecies, a: p.abilities }))) !==
                JSON.stringify(previousPets.map(p => ({ s: p.petSpecies, a: p.abilities })));

            if (petsChanged) {
              // Update UI if pets tab is active
              if (UnifiedState.activeTab === 'pets') {
                const context = document.getElementById('mga-tab-content');
                if (context && typeof updateActivePetsDisplay === 'function') {
                  updateActivePetsDisplay(context);
                }
              }

              // Update all pet overlays
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                if (overlay && document.contains(overlay) && tabName === 'pets') {
                  updateActivePetsDisplay(overlay);
                }
              });

              // TURTLE TIMER: Refresh tooltip when pets change
              (targetDocument || document)
                .querySelectorAll('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]')
                .forEach(el => el.remove());

              setTimeout(() => {
                requestAnimationFrame(() => {
                  if (typeof insertTurtleEstimate === 'function') {
                    insertTurtleEstimate();
                  }
                });
              }, 150);
            }

            // CRITICAL: Return the extracted array so hookAtom stores it correctly
            if (UnifiedState.data.settings?.debugMode) {
              productionLog('üîÑ [RENDER-CYCLE] Atom callback returning pets to hookAtom system:', {
                petsCount: activePets.length,
                petsList: activePets.map(p => p.petSpecies),
                willUpdateUnifiedState: true,
                willUpdateWindowActivePets: true
              });
            }
            return activePets;
          } else {
            if (UnifiedState.data.settings?.debugMode) {
              productionLog('üêæ [EXTRACTION-ERROR] actualPetSlots is not an array:', actualPetSlots);
            }
            return [];
          }
        }
      );

      // Hook #2: Pet ABILITY data (for ability logs - event-driven + polling)
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myPetSlotInfosAtom',
        'petAbility',
        value => {
          // BUGFIX v3.7.8: Event-driven monitoring to catch abilities immediately
          // Polling still runs every 3s as backup for missed events
          if (value && typeof monitorPetAbilities === 'function') {
            monitorPetAbilities();
          }
        }
      );

      // Hook inventory
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/inventoryAtoms.ts/myInventoryAtom',
        'inventory',
        () => updateValues()
      );

      // Hook crop data
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom',
        'currentCrop',
        () => updateValues()
      );

      // Hook friend bonus from game (same as Slot,Inv,Garden script)
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/miscAtoms.ts/friendBonusMultiplierAtom',
        'friendBonus',
        value => {
          UnifiedState.atoms.friendBonus = value || 1;
          targetWindow.friendBonus = value; // Also needed for harvest/sell protection
          updateValues();
        }
      );

      // Hook garden data AND myData for auto-favorite
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/baseAtoms.ts/myUserSlotAtom',
        'myGarden',
        value => {
          targetWindow.myGarden = value?.data || value; // Extract .data property (has garden, inventory, petSlots)
          targetWindow.myData = value?.data || value; // Extract .data property for feed buttons & auto-favorite
          updateValues();
        }
      );

      // Hook quinoa data for timers and globalShop
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/baseAtoms.ts/quinoaDataAtom',
        'quinoaData',
        value => {
          // Store quinoa data for timers
          UnifiedState.atoms.quinoaData = value;
          // Also make globalShop available for notifications
          targetWindow.globalShop = value;
          // Update timers
          updateTimers();
        }
      );

      // Hook shopsAtom for real-time shop data (all 4 shops in one atom)
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/baseAtoms.ts/shopsAtom',
        'shops',
        value => {
          // value contains all 4 shops: { seed: {...}, egg: {...}, tool: {...}, decor: {...} }
          if (!targetWindow.globalShop) targetWindow.globalShop = {};
          targetWindow.globalShop.shops = value;

          // CRITICAL: Also update quinoaData.shops for timers
          if (!UnifiedState.atoms.quinoaData) UnifiedState.atoms.quinoaData = {};
          UnifiedState.atoms.quinoaData.shops = value;

          // Update timers when shop data changes
          updateTimers();

          // Trigger shop UI refresh if open
          if (typeof targetWindow.refreshAllShopWindows === 'function') {
            targetWindow.refreshAllShopWindows();
          }
        }
      );

      productionLog('‚úÖ [SIMPLE-ATOMS] Simple atom initialization complete (including shopsAtom)');

      // Capture Jotai store for fresh data queries
      setTimeout(() => {
        const store = captureJotaiStore();
        if (store) {
          productionLog('‚úÖ [STORE] Jotai store captured successfully');
        } else {
          productionWarn('‚ö†Ô∏è [STORE] Could not capture Jotai store, will retry on demand');
        }
      }, 1000); // Wait 1 second for React to mount

      // CRITICAL: Check if window.activePets already exists after hooks are set up
      setTimeout(() => {
        if (window.activePets && Array.isArray(window.activePets) && window.activePets.length > 0) {
          productionLog(
            'üêæ [INIT-CHECK] Found existing pets in window.activePets after hook setup:',
            window.activePets
          );
          UnifiedState.atoms.activePets = window.activePets;

          // Force UI update if on pets tab
          if (UnifiedState.activeTab === 'pets') {
            const context = document.getElementById('mga-tab-content');
            if (context) {
              updateTabContent('pets', context);
            }
          }
        } else {
          productionLog('üêæ [INIT-CHECK] No pets found in window.activePets yet');
        }
      }, 2000); // Wait 2 seconds for atoms to populate
    }

    // ==================== AUTO-FAVORITE SYSTEM ====================
    (function initAutoFavorite() {
      let lastInventoryCount = 0;

      // PERFORMANCE OPTIMIZATION: Increased interval from 500ms to 2000ms
      // Still responsive for new items, but 4x less CPU usage
      setInterval(() => {
        // Early exit if auto-favorite is disabled or no watched items
        if (!UnifiedState.data.settings.autoFavorite.enabled) {
          return;
        }

        const watchedSpecies = UnifiedState.data.settings.autoFavorite.species || [];
        const watchedMutations = UnifiedState.data.settings.autoFavorite.mutations || [];

        // Skip processing if nothing is being watched
        if (watchedSpecies.length === 0 && watchedMutations.length === 0) {
          return;
        }

        if (!targetWindow.myData?.inventory?.items) {
          return;
        }

        const currentCount = targetWindow.myData.inventory.items.length;
        // Only process if inventory count increased (new items added)
        if (currentCount > lastInventoryCount) {
          checkAndFavoriteNewItems(targetWindow.myData.inventory);
        }
        lastInventoryCount = currentCount;
      }, 2000); // OPTIMIZED: Every 2 seconds (was 500ms)

      function checkAndFavoriteNewItems(inventory) {
        if (!inventory?.items) return;

        // DEFENSIVE: Ensure petAbilities array exists (v2.0.0 fix for upgrade path)
        if (!UnifiedState.data.settings.autoFavorite.petAbilities) {
          UnifiedState.data.settings.autoFavorite.petAbilities = [];
        }

        if (
          !UnifiedState.data.settings.autoFavorite.species.length &&
          !UnifiedState.data.settings.autoFavorite.mutations.length &&
          !UnifiedState.data.settings.autoFavorite.petAbilities.length
        )
          return;

        const favoritedIds = new Set(inventory.favoritedItemIds || []);
        const targetSpecies = new Set(UnifiedState.data.settings.autoFavorite.species);
        const targetMutations = new Set(UnifiedState.data.settings.autoFavorite.mutations);
        const targetPetAbilities = new Set(UnifiedState.data.settings.autoFavorite.petAbilities);
        let cropCount = 0;
        let petCount = 0;

        for (const item of inventory.items) {
          if (favoritedIds.has(item.id)) continue; // Already favorited

          // Check if it's a pet
          if (item.itemType === 'Pet') {
            // Check pet mutations for Gold or Rainbow
            const petMutations = item.mutations || [];
            const hasGoldMutation = petMutations.includes('Gold');
            const hasRainbowMutation = petMutations.includes('Rainbow');

            // ALSO check abilities array for granter abilities
            const petAbilities = item.abilities || [];
            const hasGoldGranterAbility = petAbilities.some(a => {
              const abilityStr = typeof a === 'string' ? a : a?.type || a?.abilityType || '';
              return abilityStr.toLowerCase().includes('gold') && abilityStr.toLowerCase().includes('grant');
            });
            const hasRainbowGranterAbility = petAbilities.some(a => {
              const abilityStr = typeof a === 'string' ? a : a?.type || a?.abilityType || '';
              return abilityStr.toLowerCase().includes('rainbow') && abilityStr.toLowerCase().includes('grant');
            });

            const shouldFavorite =
              (targetPetAbilities.has('Gold Granter') && (hasGoldMutation || hasGoldGranterAbility)) ||
              (targetPetAbilities.has('Rainbow Granter') && (hasRainbowMutation || hasRainbowGranterAbility));

            if (shouldFavorite) {
              if (targetWindow.MagicCircle_RoomConnection?.sendMessage) {
                targetWindow.MagicCircle_RoomConnection.sendMessage({
                  scopePath: ['Room', 'Quinoa'],
                  type: 'ToggleFavoriteItem',
                  itemId: item.id
                });
                petCount++;
              }
            }
            continue; // Skip to next item
          }

          // Only auto-favorite crops beyond this point
          if (item.itemType !== 'Produce') continue;

          // CRITICAL: Explicitly exclude eggs and tools - CROPS ONLY
          if (item.itemType === 'Egg' || item.itemType === 'Tool') continue;
          if (item.category === 'Egg' || item.category === 'Tool') continue;
          if (item.species && (item.species.includes('Pet') || item.species.includes('Egg'))) continue;

          // Check if item matches species
          const matchesSpecies = targetSpecies.has(item.species);

          // Check if item matches any mutation
          const itemMutations = item.mutations || [];
          const matchesMutation = itemMutations.some(mut => targetMutations.has(mut));

          if (matchesSpecies || matchesMutation) {
            // Send favorite command
            if (targetWindow.MagicCircle_RoomConnection?.sendMessage) {
              targetWindow.MagicCircle_RoomConnection.sendMessage({
                scopePath: ['Room', 'Quinoa'],
                type: 'ToggleFavoriteItem',
                itemId: item.id
              });
              cropCount++;
            }
          }
        }

        if (cropCount > 0) {
          productionLog(`üåü [AUTO-FAVORITE] Auto-favorited ${cropCount} new crops`);
        }
        if (petCount > 0) {
          productionLog(`üåü [AUTO-FAVORITE] Auto-favorited ${petCount} new pets`);
        }
      }

      // Function to favorite ALL items of a species (called when checkbox is checked)
      targetWindow.favoriteSpecies = function (speciesName) {
        if (!targetWindow.myData?.inventory?.items) {
          productionLog('üåü [AUTO-FAVORITE] No myData available yet - waiting for game to load');
          return;
        }

        const items = targetWindow.myData.inventory.items;
        const favoritedIds = new Set(targetWindow.myData.inventory.favoritedItemIds || []);
        let count = 0;

        for (const item of items) {
          // CRITICAL: Multiple checks to ensure ONLY crops are favorited
          if (item.itemType !== 'Produce') continue;
          if (item.itemType === 'Pet' || item.itemType === 'Egg' || item.itemType === 'Tool') continue;
          if (item.category === 'Pet' || item.category === 'Egg' || item.category === 'Tool') continue;
          if (item.species && (item.species.includes('Pet') || item.species.includes('Egg'))) continue;

          if (item.species === speciesName && !favoritedIds.has(item.id)) {
            if (targetWindow.MagicCircle_RoomConnection?.sendMessage) {
              targetWindow.MagicCircle_RoomConnection.sendMessage({
                scopePath: ['Room', 'Quinoa'],
                type: 'ToggleFavoriteItem',
                itemId: item.id
              });
              count++;
            }
          }
        }

        if (count > 0) {
          productionLog(`‚úÖ [AUTO-FAVORITE] Favorited ${count} ${speciesName} crops`);
        } else {
          productionLog(
            `‚ÑπÔ∏è [AUTO-FAVORITE] No ${speciesName} crops to favorite (already favorited or none in inventory)`
          );
        }
      };

      // DISABLED: Script never unfavorites - only adds favorites
      targetWindow.unfavoriteSpecies = function (speciesName) {
        productionLog(
          `üîí [AUTO-FAVORITE] Checkbox unchecked for ${speciesName} - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
        );
        // Do nothing - script only adds favorites, never removes them
        // This protects user's manually-favorited items (pets, eggs, crops, etc.)
      };

      // Function to favorite ALL items with a specific mutation (called when mutation checkbox is checked)
      targetWindow.favoriteMutation = function (mutationName) {
        if (!targetWindow.myData?.inventory?.items) {
          productionLog('üåü [AUTO-FAVORITE] No myData available yet - waiting for game to load');
          return;
        }

        const items = targetWindow.myData.inventory.items;
        const favoritedIds = new Set(targetWindow.myData.inventory.favoritedItemIds || []);
        let count = 0;

        for (const item of items) {
          // CRITICAL: Multiple checks to ensure ONLY crops are favorited
          if (item.itemType !== 'Produce') continue;
          if (item.itemType === 'Pet' || item.itemType === 'Egg' || item.itemType === 'Tool') continue;
          if (item.category === 'Pet' || item.category === 'Egg' || item.category === 'Tool') continue;
          if (item.species && (item.species.includes('Pet') || item.species.includes('Egg'))) continue;

          const itemMutations = item.mutations || [];
          if (itemMutations.includes(mutationName) && !favoritedIds.has(item.id)) {
            if (targetWindow.MagicCircle_RoomConnection?.sendMessage) {
              targetWindow.MagicCircle_RoomConnection.sendMessage({
                scopePath: ['Room', 'Quinoa'],
                type: 'ToggleFavoriteItem',
                itemId: item.id
              });
              count++;
            }
          }
        }

        if (count > 0) {
          productionLog(`‚úÖ [AUTO-FAVORITE] Favorited ${count} crops with ${mutationName} mutation`);
        } else {
          productionLog(
            `‚ÑπÔ∏è [AUTO-FAVORITE] No crops with ${mutationName} mutation to favorite (already favorited or none in inventory)`
          );
        }
      };

      // DISABLED: Script never unfavorites - only adds favorites
      targetWindow.unfavoriteMutation = function (mutationName) {
        productionLog(
          `üîí [AUTO-FAVORITE] Checkbox unchecked for ${mutationName} mutation - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
        );
        // Do nothing - script only adds favorites, never removes them
        // This protects user's manually-favorited items (pets, eggs, crops, etc.)
      };

      // Favorite ALL pets with a specific ability (called when checkbox is checked)
      targetWindow.favoritePetAbility = function (abilityName) {
        if (!targetWindow.myData?.inventory?.items) {
          productionLog('üåü [AUTO-FAVORITE-PET] No myData available yet - waiting for game to load');
          return;
        }

        productionLog(`üîç [AUTO-FAVORITE-PET] Searching for pets with ${abilityName}...`);

        const items = targetWindow.myData.inventory.items;
        const favoritedIds = new Set(targetWindow.myData.inventory.favoritedItemIds || []);
        let count = 0;
        let petsChecked = 0;

        // Debug: Log first pet structure to understand data format
        const firstPet = items.find(i => i.itemType === 'Pet');
        if (firstPet) {
          productionLog('üêæ [AUTO-FAVORITE-PET-DEBUG] Sample pet structure:', {
            species: firstPet.petSpecies,
            mutations: firstPet.mutations,
            abilities: firstPet.abilities,
            hasAbilitiesArray: Array.isArray(firstPet.abilities),
            hasMutationsArray: Array.isArray(firstPet.mutations)
          });
        }

        for (const item of items) {
          if (item.itemType !== 'Pet') continue;
          petsChecked++;

          if (favoritedIds.has(item.id)) continue; // Already favorited

          // Check pet mutations for Gold or Rainbow
          const petMutations = item.mutations || [];
          const hasGoldMutation = petMutations.includes('Gold');
          const hasRainbowMutation = petMutations.includes('Rainbow');

          // ALSO check abilities array for granter abilities
          const petAbilities = item.abilities || [];
          const hasGoldGranterAbility = petAbilities.some(a => {
            const abilityStr = typeof a === 'string' ? a : a?.type || a?.abilityType || '';
            return abilityStr.toLowerCase().includes('gold') && abilityStr.toLowerCase().includes('grant');
          });
          const hasRainbowGranterAbility = petAbilities.some(a => {
            const abilityStr = typeof a === 'string' ? a : a?.type || a?.abilityType || '';
            return abilityStr.toLowerCase().includes('rainbow') && abilityStr.toLowerCase().includes('grant');
          });

          const shouldFavorite =
            (abilityName === 'Gold Granter' && (hasGoldMutation || hasGoldGranterAbility)) ||
            (abilityName === 'Rainbow Granter' && (hasRainbowMutation || hasRainbowGranterAbility));

          if (shouldFavorite) {
            productionLog(
              `‚ú® [AUTO-FAVORITE-PET] Found matching pet: ${item.petSpecies} (${item.id}) - mutations: [${petMutations.join(', ')}], abilities: ${petAbilities.length}`
            );

            if (targetWindow.MagicCircle_RoomConnection?.sendMessage) {
              targetWindow.MagicCircle_RoomConnection.sendMessage({
                scopePath: ['Room', 'Quinoa'],
                type: 'ToggleFavoriteItem',
                itemId: item.id
              });
              count++;
            }
          }
        }

        productionLog(`‚úÖ [AUTO-FAVORITE-PET] Scanned ${petsChecked} pets, favorited ${count} with ${abilityName}`);
      };

      // DISABLED: Script never unfavorites - only adds favorites
      targetWindow.unfavoritePetAbility = function (abilityName) {
        productionLog(
          `üîí [AUTO-FAVORITE-PET] Checkbox unchecked for ${abilityName} - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
        );
        // Do nothing - script only adds favorites, never removes them
      };

      productionLog('üåü [AUTO-FAVORITE] System initialized - monitoring inventory changes');
    })();

    // ==================== TURTLE TIMER (CROP GROWTH BOOST II) ====================
    // Calculates expected crop growth time with Turtle's Plant Growth Boost II ability

    function getCropHash(crop) {
      try {
        return JSON.stringify(crop);
      } catch (e) {
        return '__ref_changed__' + Date.now();
      }
    }

    function getTurtleExpectations(activePets) {
      // Debug: Only log when debug mode is enabled
      if (UnifiedState.data.settings?.debugMode) {
        logDebug('TURTLE', 'Checking active pets:', {
          petsCount: activePets?.length || 0,
          pets: (activePets || []).map(p => ({
            species: p?.petSpecies,
            hunger: p?.hunger,
            abilities: p?.abilities
          }))
        });
      }

      const turtles = (activePets || []).filter(
        p =>
          p &&
          p.petSpecies === 'Turtle' &&
          p.hunger > 0 &&
          p.abilities?.some(
            a =>
              a === 'Plant Growth Boost II' ||
              a === 'PlantGrowthBoostII' ||
              a === 'Plant Growth Boost 2' ||
              (typeof a === 'string' &&
                a.toLowerCase().includes('plant') &&
                a.toLowerCase().includes('growth') &&
                (a.includes('II') || a.includes('2')))
          )
      );

      if (UnifiedState.data.settings?.debugMode) {
        logDebug('TURTLE', 'Filtered turtles:', {
          turtleCount: turtles.length,
          turtles: turtles.map(t => ({
            species: t.petSpecies,
            hunger: t.hunger,
            abilities: t.abilities,
            xp: t.xp,
            targetScale: t.targetScale
          }))
        });
      }

      let expectedMinutesRemoved = 0;

      turtles.forEach(p => {
        const xpComponent = Math.min(Math.floor(((p.xp || 0) / (100 * 3600)) * 30), 30);
        const scaleComponent = Math.floor((((p.targetScale || 1) - 1) / (2.5 - 1)) * 20 + 80) - 30;
        const base = xpComponent + scaleComponent;
        const minutesRemoved = (base / 100) * 5 * 60 * (1 - Math.pow(1 - (0.27 * base) / 100, 1 / 60));

        if (UnifiedState.data.settings?.debugMode) {
          logDebug('TURTLE', 'Turtle calculation:', {
            xp: p.xp,
            targetScale: p.targetScale,
            xpComponent,
            scaleComponent,
            base,
            minutesRemoved
          });
        }

        expectedMinutesRemoved += minutesRemoved;
      });

      if (UnifiedState.data.settings?.debugMode) {
        logDebug('TURTLE', 'Total expected minutes removed:', expectedMinutesRemoved);
      }

      return {
        expectedMinutesRemoved
      };
    }

    function estimateUntilLatestCrop(currentCrop, activePets, slotIndex = null) {
      try {
        if (!currentCrop || currentCrop.length === 0) return null;
        if (!activePets || activePets.length === 0) return null;

        const turtleExpectations = getTurtleExpectations(activePets);
        if (!turtleExpectations || turtleExpectations.expectedMinutesRemoved === 0) {
          return null;
        }

        const now = Date.now();

        // If slotIndex provided and valid, use that slot's endTime
        // Otherwise use the latest crop's endTime
        let targetEndTime;
        if (slotIndex !== null && slotIndex >= 0 && slotIndex < currentCrop.length) {
          targetEndTime = currentCrop[slotIndex]?.endTime || 0;
        } else {
          targetEndTime = Math.max(...currentCrop.map(c => c.endTime || 0));
        }

        if (targetEndTime <= now) return null; // Crop already mature

        const remainingRealMinutes = (targetEndTime - now) / (1000 * 60);
        const { expectedMinutesRemoved } = turtleExpectations;
        const effectiveRate = expectedMinutesRemoved + 1;
        const expectedRealMinutes = remainingRealMinutes / effectiveRate;

        const hours = Math.floor(expectedRealMinutes / 60);
        const minutes = Math.floor(expectedRealMinutes % 60);

        return `${hours}h ${minutes}m`;
      } catch (error) {
        logError('TURTLE', 'ERROR in estimateUntilLatestCrop:', error);
        return null;
      }
    }

    // REPLACE the entire existing insertTurtleEstimate function with this complete robust version:
    // ---------- FULL REPLACEMENT: insertTurtleEstimate() ----------

    // ---------- REPLACEMENT: insertTurtleEstimate() with spatial matching ----------

    // ==================== GENERIC ABILITY EXPECTATIONS ====================
    function getAbilityExpectations(activePets, abilityName, minutesPerBase = 5, odds = 0.27) {
      const pets = (activePets || []).filter(p => p && p.hunger > 0 && p.abilities?.some(a => a === abilityName));

      let expectedMinutesRemoved = 0;

      pets.forEach(p => {
        const base =
          Math.min(Math.floor(((p.xp || 0) / (100 * 3600)) * 30), 30) +
          Math.floor((((p.targetScale || 1) - 1) / (2.5 - 1)) * 20 + 80) -
          30;

        expectedMinutesRemoved += (base / 100) * minutesPerBase * 60 * (1 - Math.pow(1 - (odds * base) / 100, 1 / 60));
      });

      return {
        expectedMinutesRemoved
      };
    }

    function getEggExpectations(activePets) {
      return getAbilityExpectations(activePets, 'EggGrowthBoostII', 10, 0.24);
    }

    function getGrowthExpectations(activePets) {
      return getAbilityExpectations(activePets, 'PlantGrowthBoostII', 5, 0.27);
    }

    // BUGFIX: Validate tooltip element position to prevent top-left corner misplacement
    // PERFORMANCE: Silent validation - no console spam unless debug mode enabled
    function isValidTooltipElement(element) {
      if (!element) return false;

      try {
        const rect = element.getBoundingClientRect();

        // Reject if element is in top-left corner (likely UI element, not tooltip)
        // Tooltips should be centered or follow cursor, never stuck at 0,0
        if (rect.top < 50 && rect.left < 50) {
          return false; // Silent rejection
        }

        // Reject if element is too small (likely not a tooltip container)
        if (rect.width < 50 || rect.height < 30) {
          return false; // Silent rejection
        }

        // Reject if element is off-screen
        const doc = targetDocument || document;
        const viewportWidth = window.innerWidth || doc.documentElement.clientWidth;
        const viewportHeight = window.innerHeight || doc.documentElement.clientHeight;

        if (rect.right < 0 || rect.bottom < 0 || rect.left > viewportWidth || rect.top > viewportHeight) {
          return false; // Silent rejection
        }

        // Additional check: Element should contain text (tooltips always have content)
        const hasText = element.textContent && element.textContent.trim().length > 0;
        if (!hasText) {
          return false; // Silent rejection
        }

        // Passed all validation checks
        return true;
      } catch (e) {
        // Only log errors, not validation failures
        if (UnifiedState?.data?.settings?.debugMode) {
          console.error('[CROP-VALUE] ‚ùå Error validating tooltip element:', e);
        }
        return false;
      }
    }

    function insertTurtleEstimate() {
      const doc = targetDocument || document;
      const ROOT_SEL = '.McFlex.css-fsggty';
      const INNER_SEL = '.McFlex.css-1omaybc, .McFlex.css-1c3sifn';
      const MARKER_VALUE = 'tm-crop-price-value';
      const MARKER_TURTLE = 'tm-turtle-timer';

      // Get current crop/egg data from atoms
      let currentCrop = targetWindow.currentCrop || UnifiedState.atoms.currentCrop;
      const currentEgg = targetWindow.currentEgg || UnifiedState.atoms.currentEgg;

      if (!currentCrop && !currentEgg) {
        return; // No data available
      }

      // Find all tooltip root elements
      const rootElements = Array.from(doc.querySelectorAll(ROOT_SEL));
      if (rootElements.length === 0) {
        return; // No tooltip visible
      }

      // Process each root element
      rootElements.forEach(rootEl => {
        const innerElements = Array.from(rootEl.querySelectorAll(INNER_SEL));

        innerElements.forEach(inner => {
          // Check if we're looking at an egg
          const isPlantedEgg = currentCrop?.[0]?.species?.endsWith('Egg') ||
                               currentCrop?.[0]?.species?.includes('Egg') ||
                               currentCrop?.[0]?.type === 'egg' ||
                               currentCrop?.[0]?.category === 'egg';
          const isEgg = currentEgg || isPlantedEgg;

          if (isEgg) {
            // Handle egg timer
            const activePets = targetWindow.activePets || UnifiedState.atoms.activePets;
            const eggExpectations = getEggExpectations(activePets);

            if (eggExpectations && eggExpectations.expectedMinutesRemoved > 0) {
              // Find time element in tooltip
              const timeElement = [...inner.childNodes].find(el =>
                /^\d+h(?: \d+m)?(?: \d+s)?$|^\d+m(?: \d+s)?$|^\d+s$/.test((el.textContent || '').trim())
              );

              if (timeElement) {
                const timeText = timeElement.textContent.trim();
                const timeMatch = timeText.match(/(?:(\d+)h)?\s*(?:(\d+)m)?\s*(?:(\d+)s)?/);

                if (timeMatch) {
                  const hours = parseInt(timeMatch[1] || '0', 10);
                  const minutes = parseInt(timeMatch[2] || '0', 10);
                  const seconds = parseInt(timeMatch[3] || '0', 10);
                  const totalSeconds = hours * 3600 + minutes * 60 + seconds;

                  if (totalSeconds > 0) {
                    const remainingRealMinutes = totalSeconds / 60;
                    const effectiveRate = eggExpectations.expectedMinutesRemoved + 1;
                    const boostedRealMinutes = remainingRealMinutes / effectiveRate;
                    const boostedTotalSeconds = boostedRealMinutes * 60;
                    const boostedHours = Math.floor(boostedTotalSeconds / 3600);
                    const boostedMinutes = Math.floor((boostedTotalSeconds % 3600) / 60);

                    const timerText = boostedHours > 0
                      ? `ü•ö Egg: ${boostedHours}h ${boostedMinutes}m`
                      : `ü•ö Egg: ${boostedMinutes}m`;

                    ensureSpanAtEnd(inner, timerText, MARKER_TURTLE, '#fbbf24');
                  }
                }
              }
            }
            return; // Don't process value for eggs
          }

          // Handle crops
          if (!currentCrop || currentCrop.length === 0) return;

          // Show turtle estimate if crop is growing
          const timeElement = [...inner.childNodes].find(el =>
            /^\d+h(?: \d+m)?(?: \d+s)?$|^\d+m(?: \d+s)?$|^\d+s$/.test((el.textContent || '').trim())
          );

          if (timeElement) {
            const activePets = targetWindow.activePets || UnifiedState.atoms.activePets;
            const slotIndex = getCurrentSlotIndex(currentCrop);
            const sortedIndices = UnifiedState.atoms.sortedSlotIndices || window.sortedSlotIndices;
            let actualSlotIndex = slotIndex;

            if (sortedIndices && Array.isArray(sortedIndices) && sortedIndices.length > 0 && slotIndex < sortedIndices.length) {
              actualSlotIndex = sortedIndices[slotIndex];
            }

            const estimate = estimateUntilLatestCrop(currentCrop, activePets, actualSlotIndex);
            if (estimate) {
              ensureSpanAtEnd(inner, estimate, MARKER_TURTLE, '#4ade80');
            }
          }

          // Show crop value
          const slotValue = calculateCurrentSlotValue(currentCrop);
          if (slotValue > 0) {
            const valueText = Number(slotValue).toLocaleString();
            ensureSpanAtEnd(inner, valueText, MARKER_VALUE, '#FFD84D', true);
          }
        });
      });
    }

    // Helper function to create/update spans (ref.user.js pattern)
    function ensureSpanAtEnd(inner, text, markerClass, color, showCoinIcon = false) {
      const COIN_URL = 'https://cdn.discordapp.com/emojis/1425389207525920808.webp?size=96';
      const ICON_CLASS = markerClass + '-icon';
      const LABEL_CLASS = markerClass + '-label';

      // Find or create the marker span
      const spans = Array.from(inner.querySelectorAll(`:scope > span.${markerClass}`));
      let span = spans[0] || null;

      // Remove duplicates
      for (let i = 1; i < spans.length; i++) {
        spans[i].remove();
      }

      if (!span) {
        span = document.createElement('span');
        span.className = markerClass;
      }

      // Style the span
      span.style.display = 'block';
      span.style.marginTop = '6px';
      span.style.fontWeight = '700';
      span.style.color = color;
      span.style.fontSize = '14px';

      // Add coin icon if needed
      if (showCoinIcon) {
        let icon = span.querySelector(`:scope > img.${ICON_CLASS}`);
        if (!icon) {
          icon = document.createElement('img');
          icon.className = ICON_CLASS;
          icon.alt = '';
          icon.setAttribute('aria-hidden', 'true');
          icon.style.width = '14px';
          icon.style.height = '14px';
          icon.style.display = 'inline-block';
          icon.style.verticalAlign = 'middle';
          icon.style.marginRight = '4px';
          icon.style.userSelect = 'none';
          icon.style.pointerEvents = 'none';
          span.insertBefore(icon, span.firstChild);
        }
        if (icon.src !== COIN_URL) {
          icon.src = COIN_URL;
        }
      }

      // Add or update label
      let label = span.querySelector(`:scope > span.${LABEL_CLASS}`);
      if (!label) {
        label = document.createElement('span');
        label.className = LABEL_CLASS;
        label.style.display = 'inline';
        span.appendChild(label);
      }
      if (label.textContent !== text) {
        label.textContent = text;
      }

      // Append to parent if not already there
      if (inner.lastElementChild !== span) {
        inner.appendChild(span);
      }
    }

    // Track current slot index for multi-harvest crops
    // Updated ONLY when cycling (X/C keys) in handleTooltipChange()
    // CRITICAL: Must be on window object to be accessible from both scopes
    if (typeof window._mgtools_currentSlotIndex === 'undefined') {
      window._mgtools_currentSlotIndex = 0;
    }

    function getCurrentSlotIndex(currentCrop) {
      if (!currentCrop || currentCrop.length <= 1) return 0;
      return window._mgtools_currentSlotIndex || 0;
    }

    function calculateCurrentSlotValue(currentCrop) {
      if (!currentCrop || currentCrop.length === 0) return 0;

      const friendBonus = UnifiedState.atoms.friendBonus || 1;
      const slotIndex = getCurrentSlotIndex(currentCrop);

      // If we have sorted indices, use them to get the actual slot
      const sortedIndices = UnifiedState.atoms.sortedSlotIndices || window.sortedSlotIndices;
      let actualSlotIndex = slotIndex;

      if (sortedIndices && Array.isArray(sortedIndices) && sortedIndices.length > 0) {
        // The window._mgtools_currentSlotIndex is the position in the sorted array
        // The value at that position is the actual slot index in currentCrop
        if (slotIndex < sortedIndices.length) {
          actualSlotIndex = sortedIndices[slotIndex];
          console.log(`üîÑ [CROP-VALUE] Using sorted index: position ${slotIndex} ‚Üí actual slot ${actualSlotIndex}`);
        }
      }

      // Debug logging
      console.log(`üìä [CROP-VALUE] Calculating value for slot ${actualSlotIndex}/${currentCrop.length}`, {
        displayIndex: slotIndex,
        actualSlotIndex,
        cropCount: currentCrop.length,
        windowIndex: window._mgtools_currentSlotIndex,
        sortedIndices
      });

      // Validate slot index
      if (actualSlotIndex < 0 || actualSlotIndex >= currentCrop.length) {
        console.error(
          `[CROP-VALUE] Invalid slot index: ${actualSlotIndex} for crop array length: ${currentCrop.length}`
        );
        window._mgtools_currentSlotIndex = 0; // Reset to safe value
        return 0;
      }

      const slot = currentCrop[actualSlotIndex];
      if (!slot || !slot.species) {
        console.log(`[CROP-VALUE] No species at slot ${actualSlotIndex}`, slot);
        return 0;
      }

      const multiplier = calculateMutationMultiplier(slot.mutations);
      const speciesVal = speciesValues[slot.species] || 0;
      const scale = slot.targetScale || 1;
      const value = Math.round(multiplier * speciesVal * scale * friendBonus);

      // Always log for debugging the issue
      console.log(
        `üí∞ [CROP-VALUE] Slot ${actualSlotIndex}/${currentCrop.length}: ${slot.species} = ${value.toLocaleString()}`,
        {
          species: slot.species,
          speciesVal,
          multiplier,
          scale,
          friendBonus,
          value
        }
      );

      return value;
    }

    // Hook currentCrop atom for turtle timer

    function initializeTurtleTimer() {
      console.log('üê¢üê¢üê¢ [TURTLE-TIMER-START] initializeTurtleTimer() called!');
      productionLog('üê¢ [TURTLE-TIMER] Initializing crop growth estimate...');

      // Start listening to slot index changes
      listenToSlotIndexAtom();

      // Also hook the sorted slot indices atom for proper order tracking
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentSortedGrowSlotIndicesAtom',
        'sortedSlotIndices',
        value => {
          return value;
        }
      );

      // Hook currentCrop atom (using unique windowKey to avoid conflict with crop highlighting hook)
      hookAtom(
        '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom',
        'currentCropForValue',
        value => {
          // CRITICAL: Extract the actual crop data from the atom value
          // The atom might return {data: {garden: {tileObjects: [...]}}} or {garden: {tileObjects: [...]}} or just an array
          let cropData = null;
          if (value?.data?.garden?.tileObjects) {
            cropData = value.data.garden.tileObjects; // NEW: Check nested .data structure first
          } else if (value?.garden?.tileObjects) {
            cropData = value.garden.tileObjects; // Fallback to old structure
          } else if (Array.isArray(value)) {
            cropData = value; // Direct array fallback
          }

          // Store the extracted crop data
          UnifiedState.atoms.currentCrop = cropData;
          targetWindow.currentCrop = cropData;

          const currentHash = getCropHash(cropData || value);

          if (currentHash !== globalThis.prevCropHash) {
            globalThis.prevCropHash = currentHash;

            // Update estimate when crop changes
            requestAnimationFrame(() => insertTurtleEstimate());
          }

          return value; // Return original value to game
        }
      );

      // Initial call to display tooltips immediately
      requestAnimationFrame(() => insertTurtleEstimate());

      const doc = targetDocument;

      // Also poll while player is on a tile to catch any missed updates
      setInterval(() => {
        let currentCrop = targetWindow.currentCrop || UnifiedState.atoms.currentCrop;
        const currentEgg = targetWindow.currentEgg || UnifiedState.atoms.currentEgg;

        // Try to find crop data manually - DIRECT ATOM READING
        let manualCrop = null;
        if (!currentCrop) {
          // Step 1: Find Jotai store if not already found
          if (!targetWindow.__foundJotaiStore) {
            const possibleStores = [
              targetWindow.jotaiStore,
              targetWindow.__JOTAI_STORE__,
              targetWindow.store,
              targetWindow.getDefaultStore?.(),
              targetWindow.globalStore,
              targetWindow.__jotaiStore,
              targetWindow._jotaiStore
            ];

            for (const store of possibleStores) {
              // Make sure it's NOT cookieStore (browser API)
              // And verify it looks like a Jotai store (has sub/unsub or set methods)
              if (
                store &&
                typeof store.get === 'function' &&
                store !== targetWindow.cookieStore &&
                store !== window.cookieStore &&
                (typeof store.set === 'function' || typeof store.sub === 'function')
              ) {
                targetWindow.__foundJotaiStore = store;
                break;
              }
            }

            // If still not found, explore window properties
            if (!targetWindow.__foundJotaiStore) {
              const storeKeys = Object.keys(targetWindow).filter(
                k => k.toLowerCase().includes('store') || k.toLowerCase().includes('jotai')
              );

              for (const key of storeKeys) {
                const val = targetWindow[key];
                if (
                  val &&
                  typeof val === 'object' &&
                  typeof val.get === 'function' &&
                  val !== targetWindow.cookieStore &&
                  val !== window.cookieStore &&
                  (typeof val.set === 'function' || typeof val.sub === 'function')
                ) {
                  targetWindow.__foundJotaiStore = val;
                  break;
                }
              }

              // ENHANCED: Explore jotaiAtomCache itself for store reference
              if (!targetWindow.__foundJotaiStore && targetWindow.jotaiAtomCache) {
                const cache = targetWindow.jotaiAtomCache;

                // Check if cache has store property
                if (cache.store) {
                  targetWindow.__foundJotaiStore = cache.store;
                } else if (cache.cache && cache.cache.store) {
                  targetWindow.__foundJotaiStore = cache.cache.store;
                }
              }
            }
          }

          // Step 2: Try to read atom using the store
          const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
          if (atomCache && atomCache.get) {
            const cropAtom = atomCache.get(
              '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom'
            );

            if (cropAtom) {
              // Try to read using found store
              if (targetWindow.__foundJotaiStore) {
                try {
                  const cropValue = targetWindow.__foundJotaiStore.get(cropAtom);

                  // Handle if it's a Promise
                  if (cropValue && typeof cropValue.then === 'function') {
                    cropValue
                      .then(val => {
                        targetWindow.currentCrop = val;
                        UnifiedState.atoms.currentCrop = val;

                        // Trigger update
                        if (val && !document.querySelector('[data-turtletimer-estimate="true"]')) {
                          insertTurtleEstimate();
                        }
                      })
                      .catch(e => {
                        // Promise rejected
                      });
                  } else {
                    manualCrop = cropValue;

                    // Store it for next time
                    targetWindow.currentCrop = cropValue;
                    UnifiedState.atoms.currentCrop = cropValue;
                  }
                } catch (e) {
                  // Error reading atom from store
                }
              }

              // Fallback: try debugValue
              if (!manualCrop && cropAtom.debugValue !== undefined) {
                manualCrop = cropAtom.debugValue;
              }

              // ENHANCED: Try calling atom.read directly if it exists
              if (!manualCrop && typeof cropAtom.read === 'function') {
                try {
                  const mockGetter = a => {
                    if (a === cropAtom && cropAtom.init !== undefined) {
                      return cropAtom.init;
                    }
                    return undefined;
                  };
                  const directValue = cropAtom.read(mockGetter);
                  if (directValue && typeof directValue.then !== 'function') {
                    manualCrop = directValue;
                  }
                } catch (e) {
                  // Failed to call atom.read()
                }
              }
            }
          }
        }

        // Update currentCrop if we found something manually
        if (manualCrop && !currentCrop) {
          currentCrop = manualCrop;
        }

        // Check if tooltip is visible (player might be standing on something)
        const doc = targetDocument || document;
        const tooltipVisible = doc.querySelector('div.QuinoaUI > div.McFlex:nth-of-type(2) > div.McGrid');

        // If player is standing on something (has crop/egg data OR tooltip is visible), ensure estimate is shown
        if (currentCrop || currentEgg || tooltipVisible) {
          const hasExisting = doc.querySelector(
            '[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]'
          );
          if (!hasExisting) {
            insertTurtleEstimate();
          }
        }
      }, 1000); // Check every second


      // Slot index tracking is now handled by listenToSlotIndexAtom()
      // which directly listens to the game's myCurrentGrowSlotIndex atom

      productionLog('‚úÖ [TURTLE-TIMER] Turtle timer initialized successfully');

      // Expose a debug function to manually check - make it available in page context
      const debugCropDetectionFunc = function () {
        console.log('=== MANUAL CROP DETECTION DEBUG ===');

        // Check atom cache
        const atomCache = window.jotaiAtomCache?.cache || window.jotaiAtomCache;
        console.log('atomCache exists:', !!atomCache);

        if (atomCache && atomCache.get) {
          console.log('Atom cache entries count:', atomCache.size || 'unknown');

          // Look for crop-related atoms
          try {
            const allKeys = Array.from(atomCache.keys ? atomCache.keys() : []);
            console.log('Total atoms:', allKeys.length);

            const cropAtoms = allKeys.filter(
              k => k.includes('Crop') || k.includes('crop') || k.includes('Grow') || k.includes('Egg')
            );
            console.log('Crop-related atoms:', cropAtoms);

            // Try to read the current crop atom
            const atom = atomCache.get(
              '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom'
            );
            console.log('Current crop atom:', atom);

            if (atom) {
              console.log('Atom properties:', Object.keys(atom));
              console.log('Atom.debugValue:', atom.debugValue);
              console.log('Atom.init:', atom.init);

              // Try to find store and read it
              const tw = window;
              if (tw.__foundJotaiStore) {
                console.log('Found store, trying to read...');
                try {
                  const val = tw.__foundJotaiStore.get(atom);
                  console.log('‚úÖ Store.get(atom) returned:', val);
                } catch (e) {
                  console.log('‚ùå Error reading from store:', e);
                }
              } else {
                console.log('‚ö†Ô∏è No Jotai store found yet');
              }
            }
          } catch (e) {
            console.log('Error exploring atoms:', e);
          }
        }

        // Force call insertTurtleEstimate
        console.log('Calling insertTurtleEstimate()...');
        if (typeof insertTurtleEstimate === 'function') {
          insertTurtleEstimate();
        } else {
          console.log('‚ùå insertTurtleEstimate not available in this context');
        }
      };

      // Attach to multiple contexts
      try {
        window.debugCropDetection = debugCropDetectionFunc;
        targetWindow.debugCropDetection = debugCropDetectionFunc;

        console.log('üí° TIP: Run window.debugCropDetection() in console to debug crop detection');
        console.log('üí° Available in: window, targetWindow');
      } catch (e) {
        console.log('‚ö†Ô∏è Could not attach debugCropDetection:', e);
      }

      // === EXPOSE STORAGE RECOVERY FUNCTIONS (v3.8.7) ===
      try {
        window.emergencyStorageScan = emergencyStorageScan;
        window.exportPetPresets = exportPetPresets;
        window.importPetPresets = importPetPresets;
        window.performStorageHealthCheck = performStorageHealthCheck;

        targetWindow.emergencyStorageScan = emergencyStorageScan;
        targetWindow.exportPetPresets = exportPetPresets;
        targetWindow.importPetPresets = importPetPresets;
        targetWindow.performStorageHealthCheck = performStorageHealthCheck;

        console.log('üí° TIP: Storage recovery functions available:');
        console.log('   - emergencyStorageScan("MGA_petPresets") - Scan for lost data');
        console.log('   - exportPetPresets() - Backup your presets to JSON');
        console.log('   - importPetPresets() - Restore presets from backup');
        console.log('   - performStorageHealthCheck() - Check storage system health');
      } catch (e) {
        console.log('‚ö†Ô∏è Could not attach storage recovery functions:', e);
      }
    }

    function loadSavedData() {
      // PERSISTENCE GUARD v3.6.6: Initialize guard to prevent premature saves during initialization
      window.MGA_PERSISTENCE_GUARD = {
        initializationSavesBlocked: true,
        finalSaveLocation: 23480,
        warningMessage:
          '‚ö†Ô∏è BLOCKED: Premature save during initialization detected! Only final save at line ~23480 is allowed.'
      };
      productionLog('üõ°Ô∏è [PERSISTENCE-GUARD] Initialized - blocking premature saves during initialization');

      // === STORAGE HEALTH CHECK (v3.8.7) ===
      productionLog('üè• [HEALTH-CHECK] Running storage health check...');
      const healthReport = performStorageHealthCheck();
      productionLog('üè• [HEALTH-CHECK] Results:', {
        GM: healthReport.writeTest.GM || 'N/A',
        localStorage: healthReport.writeTest.localStorage || 'N/A',
        issues: healthReport.issues.length
      });

      if (healthReport.issues.length > 0) {
        productionWarn('‚ö†Ô∏è [HEALTH-CHECK] Storage issues detected:');
        healthReport.issues.forEach(issue => productionWarn(`   - ${issue}`));
      } else {
        productionLog('‚úÖ [HEALTH-CHECK] All storage systems healthy');
      }

      // Enhanced storage diagnostics
      productionLog('üì¶ [STORAGE] Starting comprehensive data loading with diagnostics...');

      // ==================== DATA MIGRATION ====================
      // CRITICAL: Migrate existing localStorage data to GM storage before loading
      productionLog('üîÑ [STORAGE] Checking for data migration needs...');
      try {
        // Clean deprecated animation key
        try {
          const animEnabled = GM_getValue('animationEnabled');
          if (animEnabled !== undefined) {
            GM_deleteValue('animationEnabled');
            if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
              console.log('[FIX_ANIMATION] Removed deprecated animationEnabled from GM storage');
            }
          }
        } catch (e) {
          // Try localStorage fallback
          try {
            if (localStorage.getItem('animationEnabled') !== null) {
              localStorage.removeItem('animationEnabled');
              if (CONFIG.DEBUG.FLAGS.FIX_VALIDATION) {
                console.log('[FIX_ANIMATION] Removed deprecated animationEnabled from localStorage');
              }
            }
          } catch (e2) {
            // Silently fail if storage not available
          }
        }

        // MGA_migrateFromLocalStorage();
      } catch (migrationError) {
        console.error('‚ùå [MIGRATION] Migration failed, but continuing with initialization:', migrationError);
      }

      // Verify UnifiedState.data exists and is properly initialized
      if (!UnifiedState.data) {
        console.error('‚ùå [CRITICAL] UnifiedState.data is not initialized!');
        UnifiedState.data = {};
      }
      productionLog('‚úÖ [STORAGE] UnifiedState.data initialized:', typeof UnifiedState.data);

      // Storage availability check (lightweight version - removed blocking I/O test)
      productionLog('üìä [STORAGE-DIAGNOSTICS] Basic localStorage info:', {
        available: typeof localStorage !== 'undefined',
        // totalItems: localStorage.length,  // Not supported in unified storage wrapper
        mgaKeys: Object.keys(localStorage).filter(k => k.startsWith('MGA_'))
      });

      // Load pet presets with enhanced debugging
      productionLog('üì¶ [STORAGE] Loading pet presets...');
      const rawPresets = localStorage.getItem('MGA_petPresets');
      productionLog(
        'üì¶ [STORAGE] Raw pet presets from localStorage:',
        rawPresets
          ? (typeof rawPresets === 'string' ? rawPresets : JSON.stringify(rawPresets)).substring(0, 200) + '...'
          : 'null'
      );

      UnifiedState.data.petPresets = MGA_loadJSON('MGA_petPresets', {});
      productionLog('üì¶ [STORAGE] Loading pet presets, found:', Object.keys(UnifiedState.data.petPresets).length);
      productionLog(
        'üîç [STORAGE-DEBUG] Pet presets type check:',
        typeof UnifiedState.data.petPresets,
        'keys:',
        Object.keys(UnifiedState.data.petPresets || {})
      );

      // Load pet presets order (for reordering feature)
      UnifiedState.data.petPresetsOrder = MGA_loadJSON('MGA_petPresetsOrder', []);
      ensurePresetOrder(); // Initialize order if needed
      productionLog('üì¶ [STORAGE] Pet presets order initialized:', UnifiedState.data.petPresetsOrder.length, 'items');

      // Verify presets loaded correctly
      if (Object.keys(UnifiedState.data.petPresets).length > 0) {
        productionLog(
          '‚úÖ [STORAGE-VERIFY] Pet presets loaded successfully:',
          Object.keys(UnifiedState.data.petPresets)
        );
      } else {
        // Only show detailed warnings in debug mode - this is normal for new users
        if (UnifiedState.data.settings?.debugMode) {
          productionLog('‚ÑπÔ∏è [STORAGE-VERIFY] No pet presets found (fresh start or cleared data)');
          productionLog('   localStorage check:', localStorage.getItem('MGA_petPresets') ? 'Data exists' : 'No data');

          // === EMERGENCY STORAGE SCAN (v3.8.7) ===
          productionLog('üö® [EMERGENCY-SCAN] Running emergency storage scan for lost presets...');
          const scanReport = emergencyStorageScan('MGA_petPresets');
          productionLog('üö® [EMERGENCY-SCAN] Scan complete:', scanReport.locations);

          // Check if data exists anywhere
          let foundAnywhere = false;
          let recoveryLocation = null;
          for (const [location, result] of Object.entries(scanReport.locations)) {
            if (result.found && result.itemCount > 0) {
              foundAnywhere = true;
              recoveryLocation = location;
              productionWarn(`   üîç Found ${result.itemCount} presets in ${location}!`);
              productionLog(`   Preview: ${result.preview}`);
            }
          }

          if (foundAnywhere) {
            productionWarn(`‚ö†Ô∏è [DATA-RECOVERY] Presets found in ${recoveryLocation} but not loaded!`);
            productionWarn('   This indicates a storage synchronization issue.');
            productionWarn('   üí° TIP: Use console command: emergencyStorageScan("MGA_petPresets") for details');
          } else {
            productionLog('   üí° TIP: Use Export/Import buttons in Pets tab to backup/restore presets');
          }
        }

        // Enhanced debugging - try to parse the raw data manually (debug mode only)
        if (UnifiedState.data.settings?.debugMode) {
          const rawData = localStorage.getItem('MGA_petPresets');
          if (rawData) {
            const dataAsString = typeof rawData === 'string' ? rawData : JSON.stringify(rawData);
            productionLog('   Raw data length:', dataAsString.length);
            productionLog('   Raw data preview:', dataAsString.substring(0, 100));
            productionLog('   Data type:', typeof rawData, 'keys:', Object.keys(rawData || {}).length);
            if (typeof rawData !== 'object') {
              console.error('‚ùå [STORAGE-ERROR] Data exists but is not an object - storage wrapper issue!');
            }
          }
        }
      }

      // Check if logs were manually cleared - if so, keep them empty
      const clearFlag =
        localStorage.getItem('MGA_logs_manually_cleared') ||
        (typeof GM_getValue !== 'undefined' ? GM_getValue('MGA_logs_manually_cleared', null) : null);
      const clearSession = localStorage.getItem('MGA_logs_clear_session');

      // Declare skipLogLoading once in the smallest common scope
      let skipLogLoading;

      // If cleared within last 24 hours, stay empty and skip ALL loading
      if (clearFlag && clearSession) {
        const clearTime = parseInt(clearFlag, 10);
        const sessionTime = parseInt(clearSession, 10);

        // 24-hour session lock: If cleared within last 24 hours, respect the clear
        if (Date.now() - clearTime < 86400000) {
          productionLog('‚úÖ [ABILITY-LOGS] Respecting manual clear - logs remain empty (session lock active)');
          UnifiedState.data.petAbilityLogs = [];
          // Skip all loading including archive - jump to after load section
          // Return statement won't work here, so we use a flag
          skipLogLoading = true;
        } else {
          // Session expired - clear the flags and allow normal loading
          localStorage.removeItem('MGA_logs_manually_cleared');
          localStorage.removeItem('MGA_logs_clear_session');
          try {
            if (typeof GM_deleteValue !== 'undefined') {
              GM_deleteValue('MGA_logs_manually_cleared');
            }
          } catch (e) {}
          logDebug('STORAGE', '‚è∞ Clear session expired (>24h) - resuming normal log loading');
          skipLogLoading = false;
        }
      } else {
        skipLogLoading = false;
      }

      const wasManuallyCleared = skipLogLoading;
      logDebug('STORAGE', 'Loading ability logs:', {
        wasManuallyCleared,
        clearFlag: clearFlag,
        clearSession: clearSession,
        skipLogLoading: skipLogLoading
      });

      if (skipLogLoading) {
        // Logs were manually cleared recently - keeping empty
        logDebug('STORAGE', 'Logs were manually cleared recently - keeping empty');
        // Skip to after the loading section
      } else {
        // ENHANCED: Check all storage sources to see where logs will come from
        const gmRaw = typeof GM_getValue !== 'undefined' ? GM_getValue('MGA_petAbilityLogs', null) : null;
        const lsRaw = window.localStorage?.getItem('MGA_petAbilityLogs');
        const tgRaw =
          typeof targetWindow !== 'undefined' && targetWindow && targetWindow !== window
            ? targetWindow.localStorage?.getItem('MGA_petAbilityLogs')
            : null;

        // Count logs in each source
        const countLogs = raw => {
          if (!raw) return 0;
          try {
            const parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;
            return Array.isArray(parsed) ? parsed.length : 0;
          } catch (e) {
            return 0;
          }
        };

        const gmCount = countLogs(gmRaw);
        const lsCount = countLogs(lsRaw);
        const tgCount = countLogs(tgRaw);

        logDebug('STORAGE', 'üîç Ability log source analysis:', {
          gmStorage: gmCount > 0 ? `${gmCount} logs` : 'empty',
          windowLocalStorage: lsCount > 0 ? `${lsCount} logs` : 'empty',
          targetLocalStorage: tgCount > 0 ? `${tgCount} logs` : 'empty',
          willChoose:
            gmCount >= lsCount && gmCount >= tgCount
              ? 'GM'
              : lsCount >= tgCount
                ? 'window.localStorage'
                : 'targetWindow.localStorage'
        });

        const loadedLogs = MGA_loadJSON('MGA_petAbilityLogs', []);
        UnifiedState.data.petAbilityLogs = loadedLogs;

        logDebug('STORAGE', '‚úÖ Loaded main logs:', {
          count: loadedLogs.length,
          sample: loadedLogs
            .slice(0, 3)
            .map(l => ({ ability: l.abilityType, time: new Date(l.timestamp).toLocaleTimeString() }))
        });

        // DIAGNOSTIC: If logs appeared from nowhere after clear, log a warning
        if (loadedLogs.length > 0 && (gmCount > 0 || lsCount > 0 || tgCount > 0)) {
          const sources = [];
          if (gmCount > 0) sources.push(`GM:${gmCount}`);
          if (lsCount > 0) sources.push(`LS:${lsCount}`);
          if (tgCount > 0) sources.push(`TG:${tgCount}`);
          logDebug('STORAGE', `üìç Logs restored from: ${sources.join(', ')}`);
        }
      }

      // BUGFIX: One-time migration - normalize old "Produce Scale Boost" ability names to "Crop Size Boost"
      // BUGFIX: Normalize malformed ability names (e.g., "Seed FinderII" ‚Üí "Seed Finder II")
      // This fixes "lost logs" issue when game renamed the ability or had typos
      let migrationNeeded = false;
      let normalizationNeeded = false;
      UnifiedState.data.petAbilityLogs = UnifiedState.data.petAbilityLogs.map(log => {
        const updatedLog = { ...log };
        let wasUpdated = false;

        // Migration 1: Produce Scale Boost ‚Üí Crop Size Boost
        if (updatedLog.abilityType && /produce\s*scale\s*boost/i.test(updatedLog.abilityType)) {
          migrationNeeded = true;
          wasUpdated = true;
          updatedLog.abilityType = updatedLog.abilityType.replace(/produce\s*scale\s*boost/gi, 'Crop Size Boost');
        }

        // Migration 2: Normalize ability names (fix missing spaces before roman numerals)
        if (updatedLog.abilityType) {
          const normalized = normalizeAbilityName(updatedLog.abilityType);
          if (normalized !== updatedLog.abilityType) {
            normalizationNeeded = true;
            wasUpdated = true;
            logDebug('STORAGE', `üìù Normalizing ability name: "${updatedLog.abilityType}" ‚Üí "${normalized}"`);
            updatedLog.abilityType = normalized;
          }
        }

        return updatedLog;
      });

      // Also migrate archived logs (BUT skip if logs were manually cleared)
      const archivedLogs = wasManuallyCleared ? [] : MGA_loadJSON('MGA_petAbilityLogs_archive', []);
      logDebug('STORAGE', 'Archive logs:', {
        skippedDueToClear: wasManuallyCleared,
        count: archivedLogs.length,
        logs: archivedLogs
          .slice(0, 5)
          .map(l => ({ ability: l.abilityType, time: new Date(l.timestamp).toLocaleTimeString() }))
      });

      let archivedMigrationNeeded = false;
      let archivedNormalizationNeeded = false;
      const migratedArchive = archivedLogs.map(log => {
        const updatedLog = { ...log };
        let wasUpdated = false;

        // Migration 1: Produce Scale Boost ‚Üí Crop Size Boost
        if (updatedLog.abilityType && /produce\s*scale\s*boost/i.test(updatedLog.abilityType)) {
          archivedMigrationNeeded = true;
          wasUpdated = true;
          updatedLog.abilityType = updatedLog.abilityType.replace(/produce\s*scale\s*boost/gi, 'Crop Size Boost');
        }

        // Migration 2: Normalize ability names
        if (updatedLog.abilityType) {
          const normalized = normalizeAbilityName(updatedLog.abilityType);
          if (normalized !== updatedLog.abilityType) {
            archivedNormalizationNeeded = true;
            wasUpdated = true;
            updatedLog.abilityType = normalized;
          }
        }

        return updatedLog;
      });

      // Save if any migrations/normalizations occurred
      if (migrationNeeded || normalizationNeeded) {
        MGA_saveJSON('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
        if (migrationNeeded && normalizationNeeded) {
          productionLog('‚úÖ [MIGRATION] Migrated "Produce Scale Boost" and normalized malformed ability names');
        } else if (migrationNeeded) {
          productionLog('‚úÖ [MIGRATION] Migrated old "Produce Scale Boost" logs to "Crop Size Boost"');
        } else if (normalizationNeeded) {
          productionLog(
            '‚úÖ [MIGRATION] Normalized malformed ability names (fixed missing spaces before roman numerals)'
          );
        }
      }

      if (archivedMigrationNeeded || archivedNormalizationNeeded) {
        MGA_saveJSON('MGA_petAbilityLogs_archive', migratedArchive);
        if (archivedMigrationNeeded && archivedNormalizationNeeded) {
          productionLog('‚úÖ [MIGRATION] Migrated and normalized archived ability logs');
        } else if (archivedMigrationNeeded) {
          productionLog('‚úÖ [MIGRATION] Migrated archived "Produce Scale Boost" logs to "Crop Size Boost"');
        } else if (archivedNormalizationNeeded) {
          productionLog('‚úÖ [MIGRATION] Normalized archived malformed ability names');
        }
      }

      // NOW clear the manual clear flag (after we've used it for both main and archive)
      if (wasManuallyCleared) {
        // Sticky clear: do not remove here; will be cleared on first new log add.
      }

      productionLog(
        'üì¶ [STORAGE] Loading pet ability logs, found:',
        UnifiedState.data.petAbilityLogs.length,
        'entries'
      );

      // Check if external pet ability logging is active
      if (window.petAbilityLogs && Array.isArray(window.petAbilityLogs)) {
        productionLog(
          'üìù [COMPAT] Detected external pet ability logging system with',
          window.petAbilityLogs.length,
          'entries'
        );
        productionLog('üìù [COMPAT] Both systems will run independently with separate storage');
      }
      // BUGFIX: Load from MGA_data instead of MGA_settings (saves use MGA_data)
      // Always load from MGA_data first (this is where we save)
      const loadedData = MGA_loadJSON('MGA_data', null);

      // CRITICAL: Verify loaded data integrity before using
      if (loadedData && typeof loadedData === 'object') {
        productionLog('üì¶ [STORAGE-INTEGRITY] Loaded data structure:', {
          hasSettings: !!loadedData.settings,
          hasCustomRooms: !!loadedData.customRooms,
          hasSeedsToDelete: !!loadedData.seedsToDelete,
          hasLockedCrops: !!loadedData.lockedCrops,
          hasLockedDecor: !!loadedData.lockedDecor,
          hasLockedPetAbilities: !!loadedData.lockedPetAbilities,
          topLevelKeys: Object.keys(loadedData),
          settingsKeys: loadedData.settings ? Object.keys(loadedData.settings).length : 0
        });
      } else {
        productionLog('‚ö†Ô∏è [STORAGE-INTEGRITY] No valid saved data found - will use defaults');
      }

      if (loadedData && loadedData.settings) {
        // If MGA_data exists, use it (this is where saves go)
        UnifiedState.data.settings = loadedData.settings;
        productionLog('üì¶ [STORAGE] Loaded settings from MGA_data');
      } else {
        // Try legacy MGA_settings for migration
        const legacySettings = MGA_loadJSON('MGA_settings', null);
        if (legacySettings) {
          UnifiedState.data.settings = legacySettings;
          // Migration will be saved at the end of loadSavedData (line ~23444)
          productionLog('üì¶ [STORAGE] Migrated settings from MGA_settings to MGA_data (will save at end of init)');
        } else {
          // Use COMPLETE defaults for first run (must match full structure from lines 2074-2115)
          UnifiedState.data.settings = {
            opacity: 95,
            popoutOpacity: 50,
            theme: 'default',
            gradientStyle: 'blue-purple',
            effectStyle: 'none',
            compactMode: false,
            ultraCompactMode: false,
            useInGameOverlays: true,
            debugMode: false,
            hideWeather: false,
            notifications: {
              enabled: true,
              volume: 0.3,
              notificationType: 'epic',
              requiresAcknowledgment: false,
              continuousEnabled: false,
              watchedSeeds: ['Carrot', 'Sunflower', 'Moonbinder', 'Dawnbinder', 'Starweaver'],
              watchedEggs: ['CommonEgg', 'MythicalEgg'],
              watchedDecor: [],
              petHungerEnabled: false,
              petHungerThreshold: 25,
              petHungerSound: 'double',
              abilityNotificationsEnabled: false,
              watchedAbilities: [],
              watchedAbilityCategories: {
                xpBoost: true,
                cropSizeBoost: true,
                selling: true,
                harvesting: true,
                growthSpeed: true,
                specialMutations: true,
                other: true
              },
              abilityNotificationSound: 'single',
              abilityNotificationVolume: 0.2,
              weatherNotificationsEnabled: false,
              watchedWeatherEvents: ['Snow', 'Rain', 'AmberMoon', 'Dawn'],
              shopFirebaseEnabled: false,
              lastSeenTimestamps: {}
            },
            detailedTimestamps: true,
            autoFavorite: {
              enabled: false,
              species: [],
              mutations: []
            }
          };
          productionLog('üì¶ [STORAGE] Using complete default settings (first run - will save at end of init)');
          // Defaults will be saved at the end of loadSavedData (line ~23444)
        }
      }

      // Ensure notifications object exists and has all required fields
      if (!UnifiedState.data.settings.notifications) {
        UnifiedState.data.settings.notifications = {};
      }

      // Set defaults for any missing notification fields
      const notifDefaults = {
        enabled: true,
        volume: 0.3,
        notificationType: 'epic',
        requiresAcknowledgment: false,
        continuousEnabled: false,
        watchedSeeds: ['Carrot', 'Sunflower', 'Moonbinder', 'Dawnbinder', 'Starweaver'],
        watchedEggs: ['CommonEgg', 'MythicalEgg'],
        petHungerEnabled: false,
        petHungerThreshold: 25,
        petHungerSound: 'double',
        abilityNotificationsEnabled: false,
        watchedAbilities: [],
        watchedAbilityCategories: {
          xpBoost: true,
          cropSizeBoost: true,
          selling: true,
          harvesting: true,
          growthSpeed: true,
          specialMutations: true,
          other: true
        },
        abilityNotificationSound: 'single',
        abilityNotificationVolume: 0.2,
        weatherNotificationsEnabled: false,
        watchedWeatherEvents: ['Snow', 'Rain', 'AmberMoon', 'Dawn'],
        shopFirebaseEnabled: false,
        lastSeenTimestamps: {}
      };

      // Merge defaults with existing settings
      // CRITICAL: Don't override intentionally empty arrays with defaults
      Object.keys(notifDefaults).forEach(key => {
        const currentValue = UnifiedState.data.settings.notifications[key];

        if (currentValue === undefined) {
          // Only set default if field truly doesn't exist
          if (Array.isArray(notifDefaults[key])) {
            // For array fields, check if key exists in saved data
            if (!(key in UnifiedState.data.settings.notifications)) {
              UnifiedState.data.settings.notifications[key] = notifDefaults[key];
              productionLog(`üì¶ [SETTINGS] Initialized ${key} array with defaults (field was missing)`);
            } else {
              // Key exists but value is undefined - keep it undefined (user may have cleared it)
              productionLog(`üì¶ [SETTINGS] Preserved undefined ${key} (intentionally cleared)`);
            }
          } else {
            // Non-array fields just set default
            UnifiedState.data.settings.notifications[key] = notifDefaults[key];
          }
        }
      });

      // Ensure watchedAbilityCategories exists and has all categories
      if (!UnifiedState.data.settings.notifications.watchedAbilityCategories) {
        UnifiedState.data.settings.notifications.watchedAbilityCategories = notifDefaults.watchedAbilityCategories;
      }

      // Ensure detailedTimestamps setting exists
      if (UnifiedState.data.settings.detailedTimestamps === undefined) {
        UnifiedState.data.settings.detailedTimestamps = false;
      }

      // Ensure autoFavorite setting exists (for v3.3.4+)
      if (!UnifiedState.data.settings.autoFavorite) {
        UnifiedState.data.settings.autoFavorite = {
          enabled: false,
          species: [],
          mutations: []
        };
        productionLog('üåü [AUTO-FAVORITE] Initialized auto-favorite settings');
      }
      // Ensure mutations array exists for existing users
      if (!UnifiedState.data.settings.autoFavorite.mutations) {
        UnifiedState.data.settings.autoFavorite.mutations = [];
        productionLog('üåü [AUTO-FAVORITE] Added mutations array to existing settings');
      }

      // Try to restore auto-favorites from backup if primary data is empty
      if (
        UnifiedState.data.settings.autoFavorite.species.length === 0 &&
        UnifiedState.data.settings.autoFavorite.mutations.length === 0
      ) {
        try {
          const backup = localStorage.getItem('mgtools_auto_favorites');
          if (backup) {
            const parsed = JSON.parse(backup);
            if (parsed && (parsed.species?.length > 0 || parsed.mutations?.length > 0)) {
              UnifiedState.data.settings.autoFavorite = parsed;
              logInfo('AUTO-FAV', 'Restored auto-favorites from localStorage backup', {
                species: parsed.species?.length || 0,
                mutations: parsed.mutations?.length || 0
              });
            }
          }
        } catch (e) {
          // Silent fail - non-critical
          logDebug('AUTO-FAV', 'Failed to restore from backup', e);
        }
      }

      // Load customRooms from saved data
      if (
        loadedData &&
        loadedData.customRooms &&
        Array.isArray(loadedData.customRooms) &&
        loadedData.customRooms.length > 0
      ) {
        // Load from saved data
        UnifiedState.data.customRooms = loadedData.customRooms;
        productionLog('üè† [ROOMS] Loaded custom rooms from storage:', UnifiedState.data.customRooms);
      } else {
        // Initialize with defaults (first time only)
        UnifiedState.data.customRooms = [...DEFAULT_ROOMS];

        // Add Discord play rooms if in Discord environment
        if (isDiscordEnvironment()) {
          UnifiedState.data.customRooms.push(...DISCORD_PLAY_ROOMS);
          productionLog('üéÆ [ROOMS] Discord environment detected - added Discord play rooms');
        }

        // Custom rooms will be saved at the end of loadSavedData (line ~23444)
        productionLog(
          'üè† [ROOMS] Initialized custom rooms (first time - will save at end of init):',
          UnifiedState.data.customRooms
        );
      }

      // Load room status from storage (player counts for custom rooms)
      const savedRoomStatus = MGA_loadJSON('MGA_roomStatus', null);
      if (savedRoomStatus && savedRoomStatus.counts) {
        UnifiedState.data.roomStatus = savedRoomStatus;
        productionLog('üè† [ROOMS] Loaded saved room status:', Object.keys(savedRoomStatus.counts).length, 'rooms');
      } else {
        UnifiedState.data.roomStatus = { counts: {}, lastUpdate: {} };
        productionLog('üè† [ROOMS] Initialized empty room status (first time or no saved data)');
      }

      // Load hotkeys data
      const savedHotkeys = MGA_loadJSON('MGA_hotkeys', null);
      if (savedHotkeys) {
        // Merge saved hotkeys with defaults to handle new keys
        UnifiedState.data.hotkeys = {
          ...UnifiedState.data.hotkeys,
          ...savedHotkeys,
          gameKeys: {
            ...UnifiedState.data.hotkeys.gameKeys,
            ...savedHotkeys.gameKeys
          },
          mgToolsKeys: {
            ...UnifiedState.data.hotkeys.mgToolsKeys,
            ...(savedHotkeys.mgToolsKeys || {})
          }
        };
        productionLog('üéÆ [HOTKEYS] Loaded saved hotkey configuration');
      } else {
        productionLog('üéÆ [HOTKEYS] Using default hotkey configuration');
      }

      // Load pet preset hotkeys
      const savedPresetHotkeys = MGA_loadJSON('MGA_petPresetHotkeys', null);
      if (savedPresetHotkeys) {
        // Clean up orphaned hotkeys (hotkey exists but preset doesn't)
        let orphanCount = 0;
        Object.keys(savedPresetHotkeys).forEach(presetName => {
          if (!UnifiedState.data.petPresets[presetName]) {
            delete savedPresetHotkeys[presetName];
            orphanCount += 1;
          }
        });

        UnifiedState.data.petPresetHotkeys = savedPresetHotkeys;
        productionLog('[HOTKEYS] Loaded pet preset hotkeys');
        if (orphanCount > 0) {
          productionLog(`[HOTKEYS] Cleaned up ${orphanCount} orphaned hotkey(s)`);
          MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
        }
      }

      // Load PAL4 filter system data
      UnifiedState.data.filterMode = MGA_loadJSON('MGA_filterMode', 'categories');
      UnifiedState.data.abilityFilters = MGA_loadJSON('MGA_abilityFilters', {
        xpBoost: true,
        cropSizeBoost: true,
        selling: true,
        harvesting: true,
        growthSpeed: true,
        specialMutations: true,
        other: true
      });
      UnifiedState.data.customMode = MGA_loadJSON('MGA_customMode', { selectedAbilities: {} });
      UnifiedState.data.petFilters = MGA_loadJSON('MGA_petFilters', { selectedPets: {} });

      // Load seed deletion settings from MGA_data (primary) with fallback to legacy keys
      const rawSeedsData = localStorage.getItem('MGA_seedsToDelete');
      const rawAutoDeleteData = localStorage.getItem('MGA_autoDeleteEnabled');

      // Load seeds to delete from MGA_data (primary) with fallback to legacy keys
      if (loadedData && loadedData.seedsToDelete !== undefined) {
        UnifiedState.data.seedsToDelete = loadedData.seedsToDelete;
        productionLog('üì¶ [STORAGE] Loaded seedsToDelete from MGA_data:', UnifiedState.data.seedsToDelete.length);
      } else {
        // Backward compatibility: Try loading from old separate storage key
        UnifiedState.data.seedsToDelete = MGA_loadJSON('MGA_seedsToDelete', []);
        productionLog('üì¶ [STORAGE] Loaded seedsToDelete from legacy key');
        // Migrate to MGA_data on next save
        if (UnifiedState.data.seedsToDelete.length > 0) {
          productionLog('üì¶ [MIGRATION] Will migrate seedsToDelete to MGA_data on next save');
        }
      }

      if (loadedData && loadedData.autoDeleteEnabled !== undefined) {
        UnifiedState.data.autoDeleteEnabled = loadedData.autoDeleteEnabled;
        productionLog('üì¶ [STORAGE] Loaded autoDeleteEnabled from MGA_data:', UnifiedState.data.autoDeleteEnabled);
      } else {
        // Backward compatibility
        UnifiedState.data.autoDeleteEnabled = MGA_loadJSON('MGA_autoDeleteEnabled', false);
        productionLog('üì¶ [STORAGE] Loaded autoDeleteEnabled from legacy key');
      }
      productionLog(
        'üîç [STORAGE-DEBUG] Seeds type check:',
        typeof UnifiedState.data.seedsToDelete,
        'length:',
        UnifiedState.data.seedsToDelete?.length || 0
      );

      productionLog('üì¶ [STORAGE] Loading seed deletion settings:', {
        seedsToDelete: UnifiedState.data.seedsToDelete.length + ' seeds',
        autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled,
        seeds: UnifiedState.data.seedsToDelete,
        rawSeedsToDeleteFromStorage: rawSeedsData,
        rawAutoDeleteFromStorage: rawAutoDeleteData,
        parsedSeedsData: rawSeedsData, // Already parsed by storage wrapper
        parsedAutoDeleteData: rawAutoDeleteData // Already parsed by storage wrapper
      });

      // Verify seeds loaded correctly
      if (UnifiedState.data.seedsToDelete.length > 0) {
        productionLog('‚úÖ [STORAGE-VERIFY] Seed selections loaded successfully:', UnifiedState.data.seedsToDelete);
      } else {
        // Only show in debug mode - this is normal for users who haven't configured seed auto-delete
        if (UnifiedState.data.settings?.debugMode) {
          productionLog('‚ÑπÔ∏è [STORAGE-VERIFY] No seed auto-delete selections (not configured yet)');
          productionLog(
            '   localStorage check:',
            localStorage.getItem('MGA_seedsToDelete') ? 'Data exists' : 'No data'
          );
        }

        // Enhanced debugging for seeds (debug mode only)
        if (UnifiedState.data.settings?.debugMode) {
          const rawSeedsData = localStorage.getItem('MGA_seedsToDelete');
          if (rawSeedsData) {
            const dataAsString = typeof rawSeedsData === 'string' ? rawSeedsData : JSON.stringify(rawSeedsData);
            productionLog('   Raw seeds data length:', dataAsString.length);
            productionLog('   Raw seeds data preview:', dataAsString.substring(0, 100));
            productionLog(
              '   Seeds data type:',
              typeof rawSeedsData,
              Array.isArray(rawSeedsData) ? `array with ${rawSeedsData.length} items` : 'not array'
            );
            if (typeof rawSeedsData !== 'object') {
              console.error('‚ùå [STORAGE-ERROR] Seeds data exists but is not an object - storage wrapper issue!');
            }
          }
        }
      }

      // Load crop protection settings from MGA_data
      if (loadedData && loadedData.lockedCrops) {
        UnifiedState.data.lockedCrops = loadedData.lockedCrops;

        // MIGRATION: Convert old "No Mutation" to "Lock All Mutations"
        if (UnifiedState.data.lockedCrops.mutations) {
          const mutations = UnifiedState.data.lockedCrops.mutations;
          const oldIndex = mutations.indexOf('No Mutation');
          if (oldIndex !== -1) {
            mutations[oldIndex] = 'Lock All Mutations';
            productionLog('üì¶ [MIGRATION] Converted old "No Mutation" to "Lock All Mutations"');
          }
        }

        productionLog('üì¶ [STORAGE] Loaded crop protection locks from MGA_data:', {
          species: loadedData.lockedCrops.species?.length || 0,
          mutations: loadedData.lockedCrops.mutations?.length || 0
        });
      } else {
        UnifiedState.data.lockedCrops = { species: [], mutations: [] };
        productionLog('üì¶ [STORAGE] Initialized crop protection with defaults');
      }

      // Load decor protection settings from MGA_data
      if (loadedData && loadedData.lockedDecor && Array.isArray(loadedData.lockedDecor)) {
        UnifiedState.data.lockedDecor = loadedData.lockedDecor;
        productionLog(
          'üì¶ [STORAGE] Loaded decor protection locks from MGA_data:',
          UnifiedState.data.lockedDecor.length
        );
      } else {
        UnifiedState.data.lockedDecor = [];
        productionLog('üì¶ [STORAGE] Initialized decor protection with defaults');
      }

      // Load pet abilities protection settings from MGA_data
      if (loadedData && loadedData.lockedPetAbilities && Array.isArray(loadedData.lockedPetAbilities)) {
        UnifiedState.data.lockedPetAbilities = loadedData.lockedPetAbilities;
        productionLog(
          'üì¶ [STORAGE] Loaded pet abilities protection locks from MGA_data:',
          UnifiedState.data.lockedPetAbilities.length
        );
      } else {
        UnifiedState.data.lockedPetAbilities = [];
        productionLog('üì¶ [STORAGE] Initialized pet abilities protection with defaults');
      }

      if (loadedData && loadedData.sellBlockThreshold !== undefined) {
        UnifiedState.data.sellBlockThreshold = loadedData.sellBlockThreshold;
        productionLog('üì¶ [STORAGE] Loaded sell block threshold:', UnifiedState.data.sellBlockThreshold);
      } else {
        UnifiedState.data.sellBlockThreshold = 1.0;
        productionLog('üì¶ [STORAGE] Initialized sell block threshold to default (1.0)');
      }

      // Load persisted ability timestamps to prevent duplicate logging after refresh
      UnifiedState.data.lastAbilityTimestamps = MGA_loadJSON('MGA_lastAbilityTimestamps', {});

      // Clean up old ability timestamps (keep only last 24 hours to prevent memory bloat)
      const dayAgo = Date.now() - 24 * 60 * 60 * 1000;
      Object.keys(UnifiedState.data.lastAbilityTimestamps).forEach(petId => {
        if (UnifiedState.data.lastAbilityTimestamps[petId] < dayAgo) {
          delete UnifiedState.data.lastAbilityTimestamps[petId];
        }
      });

      // ==================== SAVE COMPLETE STATE ====================
      // CRITICAL: Save AFTER all data has been loaded from loadedData to prevent data loss
      MGA_saveJSON('MGA_data', UnifiedState.data);
      productionLog(
        'üíæ [STORAGE] Saved complete merged state (settings, customRooms, seedsToDelete, lockedCrops, sellBlockThreshold)'
      );

      // PERSISTENCE GUARD v3.8.6: Clear guard - initialization complete, saves now allowed
      if (window.MGA_PERSISTENCE_GUARD) {
        window.MGA_PERSISTENCE_GUARD.initializationSavesBlocked = false;
        productionLog('üõ°Ô∏è [PERSISTENCE-GUARD] Cleared - initialization complete, saves now allowed');
      }

      // ==================== STORAGE LOADING SUMMARY ====================
      productionLog('üìä [STORAGE-SUMMARY] Data loading complete:', {
        petPresets: {
          loaded: Object.keys(UnifiedState.data.petPresets).length,
          presets: Object.keys(UnifiedState.data.petPresets),
          rawExists: !!rawPresets
        },
        abilityLogs: {
          loaded: UnifiedState.data.petAbilityLogs.length,
          rawExists: !!localStorage.getItem('MGA_petAbilityLogs')
        },
        seedSettings: {
          seedsToDelete: UnifiedState.data.seedsToDelete.length,
          autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled,
          rawSeedsExists: !!rawSeedsData,
          rawAutoDeleteExists: !!rawAutoDeleteData
        },
        settings: {
          loaded: Object.keys(UnifiedState.data.settings).length,
          rawExists: !!localStorage.getItem('MGA_settings')
        },
        allMgaKeys: Object.keys(localStorage).filter(k => k.startsWith('MGA_')),
        timestamp: new Date().toISOString()
      });

      // Persistence verification test
      setTimeout(() => {
        // productionLog('üîç [STORAGE-VERIFICATION] Testing immediate save/load cycle...');
        const testKey = 'MGA_persistenceTest';
        const testData = { test: true, timestamp: Date.now() };

        try {
          MGA_saveJSON(testKey, testData);
          const retrieved = MGA_loadJSON(testKey, null);
          const success = retrieved && retrieved.test === true;

          productionLog('üìä [STORAGE-VERIFICATION] Persistence test result:', {
            success: success,
            saved: testData,
            retrieved: retrieved,
            matching: JSON.stringify(testData) === JSON.stringify(retrieved)
          });

          // Clean up test data
          localStorage.removeItem(testKey);

          if (!success) {
            console.error('‚ùå [STORAGE-VERIFICATION] Persistence test FAILED - data may not be saving correctly');
          } else {
            productionLog('‚úÖ [STORAGE-VERIFICATION] Persistence test PASSED - storage is working correctly');
          }
        } catch (error) {
          console.error('‚ùå [STORAGE-VERIFICATION] Persistence test ERROR:', error);
        }
      }, 100);
    }

    function startIntervals() {
      productionLog('üö®üö®üö® [CRITICAL] startIntervals() CALLED üö®üö®üö®');

      // Mark that intervals have been started
      window._mgaIntervalsStarted = true;

      // Initialize event-driven shop watcher
      productionLog('üîÑ Initializing event-driven shop monitoring...');
      initializeShopWatcher();

      // Initialize the enhanced TimerManager (make it global for debugging)
      window.timerManager = initializeTimerManager();

      // OPTIMIZED: Monitor abilities every 5 seconds (performance improvement)
      productionLog('üö® [CRITICAL] Setting up ability monitoring timer...');
      window.abilityMonitoringInterval = setInterval(() => {
        monitorPetAbilities();
      }, 5000);
      productionLog('üö® [CRITICAL] Ability monitoring started with simple setInterval (3s)');

      // OPTIMIZED: Update timers every 2 seconds (reduced from 1s)
      window.timerManager.startTimer('timers', () => updateTimers(), 2000);

      // OPTIMIZED: Update values every 3 seconds (reduced from 2s)
      window.timerManager.startTimer('values', () => updateValues(), 3000);

      // Optimized notification timer with performance monitoring
      productionLog('üö® [CRITICAL] Setting up optimized notification timer...');

      let notificationCheckCounter = 0;
      let skipNextChecks = 0;

      // Make notificationInterval global so we can check if it's running
      // OPTIMIZED: Increased to 10 seconds to dramatically reduce FPS impact
      window.notificationInterval = setInterval(() => {
        // Skip checks if we're in a performance-critical situation
        if (skipNextChecks > 0) {
          skipNextChecks--;
          productionLog('‚è≠Ô∏è [PERFORMANCE] Skipping notification checks to improve FPS');
          return;
        }

        // Check if we're in a weather event and should throttle
        const currentWeather = window.roomState?.child?.data?.weather || window.roomState?.weather || null;
        const isWeatherActive = currentWeather && currentWeather !== 'none' && currentWeather !== 'clear';

        notificationCheckCounter++;

        // OPTIMIZED: During weather events, only check every 2nd interval (20s instead of 10s)
        if (isWeatherActive && notificationCheckCounter % 2 !== 0) {
          productionLog('üå§Ô∏è [PERFORMANCE] Throttling checks during weather event:', currentWeather);
          return;
        }

        // Measure performance impact
        const startTime = performance.now();

        try {
          // Run checks with try-catch to prevent errors from breaking the interval
          try {
            checkForWatchedItems();
          } catch (e) {
            console.error('‚ùå Error in checkForWatchedItems:', e);
          }

          try {
            checkPetHunger();
          } catch (e) {
            console.error('‚ùå Error in checkPetHunger:', e);
          }

          // Only check weather if enabled and not already in weather event
          if (!isWeatherActive) {
            try {
              detectWeatherEvents();
            } catch (e) {
              console.error('‚ùå Error in detectWeatherEvents:', e);
            }
          }

          // Check if we're taking too long
          const elapsed = performance.now() - startTime;
          if (elapsed > 50) {
            // If checks take more than 50ms
            productionWarn(
              `‚ö†Ô∏è [PERFORMANCE] Notification checks took ${elapsed.toFixed(2)}ms - throttling next checks`
            );
            skipNextChecks = 2; // Skip next 2 checks (20 seconds total)
          }
        } catch (error) {
          console.error('‚ùå [CRITICAL] Error in notification interval:', error);
        }
      }, 15000); // OPTIMIZED: Check every 15 seconds for better performance

      // Store interval reference for cleanup
      MGA_addInterval(window.notificationInterval);

      productionLog('üö® [CRITICAL] Optimized notification timer started with performance monitoring');

      // HUNGER TIMER: Update hunger countdown timers
      // PERFORMANCE OPTIMIZATION: Reduced from 1000ms to 2000ms, cache timer elements
      productionLog('üçñ [HUNGER-TIMER] Setting up hunger timer updates...');

      // Cache for timer elements (refreshed when pets tab is opened/updated)
      let cachedTimerElements = [];
      let lastTimerCacheTime = 0;
      const TIMER_CACHE_DURATION = 5000; // Refresh cache every 5 seconds

      window.hungerTimerInterval = setInterval(() => {
        try {
          const activePets = window.activePets || UnifiedState.atoms.activePets || [];

          // Refresh timer element cache if needed
          const now = Date.now();
          if (cachedTimerElements.length === 0 || now - lastTimerCacheTime > TIMER_CACHE_DURATION) {
            cachedTimerElements = Array.from(document.querySelectorAll('.mga-hunger-timer'));
            lastTimerCacheTime = now;
          }

          if (UnifiedState.data.settings?.debugMode) {
            console.log('üçñ [TIMER-UPDATE] Cached timer elements:', cachedTimerElements.length);
            console.log('üçñ [TIMER-UPDATE] Active pets:', activePets.length);
            if (activePets.length > 0) {
              activePets.forEach((p, i) => {
                console.log(`üçñ [TIMER-UPDATE] Pet ${i}:`, {
                  species: p.petSpecies,
                  hunger: p.hunger,
                  abilities: p.abilities,
                  strength: p.strength,
                  str: p.str
                });
              });
            }
          }

          if (cachedTimerElements.length > 0) {
            cachedTimerElements.forEach(element => {
              // Skip if element was removed from DOM
              if (!document.contains(element)) {
                cachedTimerElements = []; // Force cache refresh
                return;
              }

              const petIndex = parseInt(element.dataset.petIndex);
              if (petIndex >= 0 && petIndex < activePets.length) {
                const pet = activePets[petIndex];
                const timeUntilHungry = calculateTimeUntilHungry(pet);
                const timerText = formatHungerTimer(timeUntilHungry);
                const timerColor =
                  timeUntilHungry === null
                    ? '#999'
                    : timeUntilHungry <= 0
                      ? '#8B0000'
                      : timeUntilHungry < 5 * 60 * 1000
                        ? '#ff4444'
                        : timeUntilHungry < 15 * 60 * 1000
                          ? '#ffa500'
                          : '#4caf50';
                element.textContent = timerText;
                element.style.color = timerColor;
              }
            });
          }
        } catch (error) {
          console.error('‚ùå Error updating hunger timers:', error);
        }
      }, 2000); // OPTIMIZED: Update every 2 seconds (was 1s)

      MGA_addInterval(window.hungerTimerInterval);
      productionLog('üçñ [HUNGER-TIMER] Hunger timer updates started (1s interval)');

      debugLog('INTERVALS', 'All intervals started with TimerManager', {
        timerCount: timerManager.activeTimers.size,
        status: timerManager.getStatus()
      });

      // BUGFIX: Visibility-aware performance optimization (from v1.11.3)
      // Slower refresh when tab is hidden to save CPU/battery
      document.addEventListener(
        'visibilitychange',
        function () {
          const hidden = document.hidden;
          productionLog(`üëÅÔ∏è [VISIBILITY] Tab ${hidden ? 'hidden' : 'visible'} - adjusting intervals`);

          // Adjust ability monitoring interval
          if (window.abilityMonitoringInterval) {
            clearInterval(window.abilityMonitoringInterval);
          }
          window.abilityMonitoringInterval = setInterval(
            () => {
              monitorPetAbilities();
            },
            hidden ? 5000 : 3000
          ); // 5s when hidden, 3s when visible

          // Adjust notification interval
          if (window.notificationInterval) {
            clearInterval(window.notificationInterval);
          }
          window.notificationInterval = setInterval(
            () => {
              // ... notification logic (same as above)
              if (skipNextChecks > 0) {
                skipNextChecks--;
                return;
              }
              const currentWeather = window.roomState?.child?.data?.weather || window.roomState?.weather || null;
              const isWeatherActive = currentWeather && currentWeather !== 'none' && currentWeather !== 'clear';
              notificationCheckCounter++;
              if (isWeatherActive && notificationCheckCounter % 2 !== 0) return;

              const startTime = performance.now();
              try {
                try {
                  checkPetHunger();
                } catch (hungerError) {
                  console.error('Error in checkPetHunger:', hungerError);
                }
              } catch (error) {
                console.error('Critical error in notification checks:', error);
              }

              const checkDuration = performance.now() - startTime;
              if (checkDuration > 50) {
                productionLog(`‚è±Ô∏è [PERFORMANCE] Notification checks took ${checkDuration.toFixed(2)}ms`);
                skipNextChecks = 2;
              }
            },
            hidden ? 20000 : 10000
          ); // 20s when hidden, 10s when visible

          productionLog(`üëÅÔ∏è [VISIBILITY] Intervals adjusted for ${hidden ? 'background' : 'foreground'} mode`);
        },
        { passive: true }
      );
    }

    // ==================== NAVIGATION HELPERS ====================
    function handleTabNavigation(e, forward) {
      const focusableElements = getFocusableElements();
      const currentIndex = focusableElements.indexOf(e.target);

      if (currentIndex === -1) return;

      const nextIndex = forward
        ? (currentIndex + 1) % focusableElements.length
        : (currentIndex - 1 + focusableElements.length) % focusableElements.length;

      focusableElements[nextIndex]?.focus();
    }

    function handleArrowNavigation(e, direction) {
      const focusable = getFocusableElements();
      const current = e.target;

      if (current.classList.contains('mga-btn') || current.classList.contains('mga-tab')) {
        const siblings = getSiblingsInDirection(current, direction);
        if (siblings.length > 0) {
          siblings[0].focus();
        }
      }
    }

    function getFocusableElements() {
      return Array.from(
        targetDocument.querySelectorAll(
          'button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
        )
      ).filter(el => el.offsetParent !== null); // Only visible elements
    }

    function getSiblingsInDirection(element, direction) {
      const parent = element.parentElement;
      const siblings = Array.from(parent.children).filter(el => el !== element && getFocusableElements().includes(el));

      // Simple directional logic - could be enhanced with position calculations
      return siblings;
    }

    function openCommandPalette(e) {
      createCommandPalette();
    }

    function openQuickSearch(e) {
      createQuickSearchOverlay();
    }

    function handleEnterKey(e) {
      const target = e.target;
      if (target.classList.contains('mga-btn')) {
        target.click();
      }
    }

    function handleSpaceKey(e) {
      const target = e.target;
      if (target.classList.contains('mga-btn')) {
        target.click();
      }
    }

    function handleEscapeKey() {
      // Close any open modals/overlays in order of priority
      const commandPalette = targetDocument.querySelector('#mga-command-palette');
      if (commandPalette) {
        commandPalette.remove();
        return;
      }

      const searchOverlay = targetDocument.querySelector('#mga-search-overlay');
      if (searchOverlay) {
        searchOverlay.remove();
        return;
      }

      // Close focused popout
      targetDocument.querySelectorAll('.mga-overlay').forEach(overlay => {
        if (overlay.style.display !== 'none') {
          overlay.style.display = 'none';
        }
      });
    }

    function closeAllPopouts() {
      targetDocument.querySelectorAll('.mga-overlay').forEach(overlay => {
        overlay.style.display = 'none';
      });

      // Close separate windows
      UnifiedState.popoutWindows.forEach(window => {
        try {
          window.close();
        } catch (e) {}
      });
      UnifiedState.popoutWindows.clear();
    }

    function refreshAllContent() {
      updateTabContent();
      refreshSeparateWindowPopouts();
      productionLog('üîÑ All content refreshed');
    }

    function loadPetPreset(preset) {
      if (!preset || !Array.isArray(preset)) {
        productionWarn('[PETS] Invalid preset data');
        return;
      }

      // Always use SwapPet for atomic swapping (works regardless of inventory space)
      productionLog('[PETS] Using SwapPet for atomic swapping');

      preset.forEach((presetPet, i) => {
        // BUGFIX: Read current state INSIDE timeout to get fresh data after previous swaps
        // This fixes race condition where slow networks don't update activePets fast enough
        setTimeout(() => {
          // Get FRESH state each time (not stale reference from before loop)
          const currentPets = UnifiedState.atoms.activePets || window.activePets || [];
          const currentPet = currentPets[i];

          if (currentPet) {
            // Check if desired pet is already equipped
            if (currentPet.id === presetPet.id) {
              if (UnifiedState.data.settings?.debugMode) {
                productionLog(`[PET-SWAP] Slot ${i + 1}: Already equipped (${currentPet.id}), skipping`);
              }
              return; // Skip swap, pet already in place
            }

            // Swap: active pet <-> inventory pet
            if (UnifiedState.data.settings?.debugMode) {
              productionLog(`[PET-SWAP] Slot ${i + 1}: Swapping ${currentPet.id} ‚Üí ${presetPet.id}`);
            }

            safeSendMessage({
              scopePath: ['Room', 'Quinoa'],
              type: 'SwapPet',
              petSlotId: currentPet.id,
              petInventoryId: presetPet.id
            });
          } else {
            // No pet in this slot, just place
            if (UnifiedState.data.settings?.debugMode) {
              productionLog(`[PET-SWAP] Slot ${i + 1}: Placing ${presetPet.id} (empty slot)`);
            }

            safeSendMessage({
              scopePath: ['Room', 'Quinoa'],
              type: 'PlacePet',
              itemId: presetPet.id,
              position: { x: 17 + i * 2, y: 13 },
              localTileIndex: 64,
              tileType: 'Boardwalk'
            });
          }
        }, i * 200); // Increased delay from 100ms ‚Üí 200ms for network latency tolerance
      });

      productionLog(`‚úÖ [PETS] Loaded pet preset (${preset.length} pets)`);
    }

    function loadPresetByNumber(number) {
      const presets = Object.keys(UnifiedState.data.petPresets);
      if (presets[number - 1]) {
        const presetName = presets[number - 1];
        const preset = UnifiedState.data.petPresets[presetName];
        loadPetPreset(preset);
        productionLog(`üêæ Loaded preset ${number}: ${presetName}`);
      }
    }

    function createCommandPalette() {
      // Remove existing palette
      const existing = targetDocument.querySelector('#mga-command-palette');
      if (existing) existing.remove();

      const overlay = targetDocument.createElement('div');
      overlay.id = 'mga-command-palette';
      overlay.style.cssText = `
              position: fixed;
              top: 0;
              left: 0;
              width: 100vw;
              height: 100vh;
              background: rgba(0, 0, 0, 0.5);
              z-index: 20000;
              display: flex;
              align-items: flex-start;
              justify-content: center;
              padding-top: 100px;
          `;

      const palette = targetDocument.createElement('div');
      palette.style.cssText = `
              background: #1f2937;
              border: 1px solid #4b5563;
              border-radius: 8px;
              width: 500px;
              max-height: 400px;
              box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
              overflow: hidden;
          `;

      const input = targetDocument.createElement('input');
      input.type = 'text';
      input.placeholder = 'Type a command...';
      input.style.cssText = `
              width: 100%;
              padding: 16px;
              background: transparent;
              border: none;
              color: white;
              font-size: 16px;
              outline: none;
          `;

      const commands = [
        { name: 'Open Pets', action: () => openTabInPopout('pets'), key: 'Alt+P' },
        { name: 'Open Values', action: () => openTabInPopout('values'), key: 'Alt+V' },
        { name: 'Open Abilities', action: () => openTabInPopout('abilities'), key: 'Alt+A' },
        { name: 'Open Seeds', action: () => openTabInPopout('seeds'), key: 'Alt+S' },
        { name: 'Open Settings', action: () => openTabInPopout('settings'), key: 'Alt+G' },
        { name: 'Close All Windows', action: () => closeAllPopouts(), key: 'Alt+W' },
        { name: 'Refresh All Content', action: () => refreshAllContent(), key: 'Alt+R' }
      ];

      const commandsList = targetDocument.createElement('div');
      commandsList.style.cssText = `
              max-height: 300px;
              overflow-y: auto;
          `;

      const renderCommands = (filter = '') => {
        commandsList.innerHTML = '';
        const filtered = commands.filter(cmd => cmd.name.toLowerCase().includes(filter.toLowerCase()));

        filtered.forEach((cmd, index) => {
          const item = targetDocument.createElement('div');
          item.style.cssText = `
                      padding: 12px 16px;
                      color: white;
                      cursor: pointer;
                      display: flex;
                      justify-content: space-between;
                      align-items: center;
                      ${index === 0 ? 'background: #374151;' : ''}
                  `;
          item.innerHTML = `
                      <span>${cmd.name}</span>
                      <span style="color: #9ca3af; font-size: 12px;">${cmd.key}</span>
                  `;

          item.addEventListener('click', () => {
            cmd.action();
            overlay.remove();
          });

          commandsList.appendChild(item);
        });
      };

      input.addEventListener('input', e => {
        renderCommands(e.target.value);
      });

      input.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
          overlay.remove();
        } else if (e.key === 'Enter') {
          const firstCommand = commandsList.firstElementChild;
          if (firstCommand) firstCommand.click();
        }
      });

      renderCommands();
      palette.appendChild(input);
      palette.appendChild(commandsList);
      overlay.appendChild(palette);
      targetDocument.body.appendChild(overlay);

      input.focus();
    }

    function createQuickSearchOverlay() {
      // Remove existing search
      const existing = targetDocument.querySelector('#mga-search-overlay');
      if (existing) existing.remove();

      const overlay = targetDocument.createElement('div');
      overlay.id = 'mga-search-overlay';
      overlay.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              background: #1f2937;
              border: 1px solid #4b5563;
              border-radius: 8px;
              padding: 16px;
              z-index: 15000;
              width: 300px;
              box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
          `;

      const input = targetDocument.createElement('input');
      input.type = 'text';
      input.placeholder = 'Search content...';
      input.style.cssText = `
              width: 100%;
              padding: 8px;
              background: #374151;
              border: 1px solid #4b5563;
              border-radius: 4px;
              color: white;
              outline: none;
          `;

      const results = targetDocument.createElement('div');
      results.style.cssText = `
              margin-top: 8px;
              max-height: 200px;
              overflow-y: auto;
          `;

      input.addEventListener('input', e => {
        const query = e.target.value.toLowerCase();
        if (query.length < 2) {
          results.innerHTML = '';
          return;
        }

        // Search through all content
        const searchResults = searchAllContent(query);
        results.innerHTML = searchResults
          .map(
            result => `
                  <div style="padding: 8px; cursor: pointer; border-radius: 4px; margin: 4px 0;"
                       onmouseover="this.style.background='#374151'"
                       onmouseout="this.style.background='transparent'"
                       onclick="window.${result.action}">
                      <div style="color: #60a5fa; font-size: 12px;">${result.tab}</div>
                      <div style="color: white; font-size: 14px;">${result.title}</div>
                      <div style="color: #9ca3af; font-size: 11px;">${result.preview}</div>
                  </div>
              `
          )
          .join('');
      });

      input.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
          overlay.remove();
        }
      });

      overlay.appendChild(input);
      overlay.appendChild(results);
      targetDocument.body.appendChild(overlay);

      input.focus();
    }

    // ==================== CROP HIGHLIGHTING SYSTEM ====================
    // Ctrl+H clears highlights, UI in settings for crop highlighting
    function setupCropHighlightingSystem() {
      productionLog('üå± [DEBUG] setupCropHighlightingSystem() called - setting up crop highlighting...');
      // FIRST: Verify crop highlighting utilities are installed
      if (typeof window.removeAllTileOverrides !== 'function') {
        debugLog(
          'CROP_HIGHLIGHT',
          'Crop highlighting utilities not available - they should have been installed earlier'
        );
      } else {
        debugLog('CROP_HIGHLIGHT', 'Crop highlighting utilities confirmed available');
      }

      if (window.__cropHighlightInstalled) {
        debugLog('CROP_HIGHLIGHT', 'Crop highlighting system already installed');
        return;
      }

      function cropHighlightHandler(e) {
        // Ctrl+H clears all highlights
        if (e.ctrlKey && e.key === 'h') {
          e.preventDefault();
          e.stopPropagation();

          try {
            if (typeof window.removeAllTileOverrides === 'function') {
              window.removeAllTileOverrides();
              debugLog('CROP_HIGHLIGHT', 'Ctrl+H ‚Üí cleared all tile highlights');
            } else {
              debugLog('CROP_HIGHLIGHT', 'removeAllTileOverrides function not available');
            }
          } catch (err) {
            debugError('CROP_HIGHLIGHT', 'Failed to clear highlights', err);
          }
        }
      }

      window.addEventListener('keydown', cropHighlightHandler, true);
      window.__cropHighlightInstalled = true;
      debugLog('CROP_HIGHLIGHT', 'Ctrl+H crop highlight hotkey installed');
    }

    // Crop highlighting function moved to settings section (line 5505) to avoid duplication

    function searchAllContent(query) {
      const results = [];
      const tabs = ['pets', 'abilities', 'seeds', 'values', 'timers', 'settings'];

      tabs.forEach(tab => {
        // Mock search results - in real implementation would search actual content
        if (tab.includes(query)) {
          results.push({
            tab: tab.charAt(0).toUpperCase() + tab.slice(1),
            title: `${tab.charAt(0).toUpperCase() + tab.slice(1)} Tab`,
            preview: `Open the ${tab} management interface`,
            action: `openTabInPopout('${tab}')`
          });
        }
      });

      return results;
    }

    // ==================== KEYBOARD SHORTCUTS ====================
    function initializeKeyboardShortcuts() {
      const shortcuts = {
        // Panel Management
        // NOTE: Alt+M is handled by setupToolbarToggle() in TEST VERSION - disabled here to prevent conflict
        /* 'Alt+M': () => {
          const panel = UnifiedState.panels.main;
          if (panel) {
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';

            // Hide any stuck tooltips when panel is toggled via keyboard
            if (window.MGA_Tooltips && window.MGA_Tooltips.hide) {
              window.MGA_Tooltips.hide();
            }

            UnifiedState.data.settings.panelVisible = !isVisible;
            productionLog(`üéÆ MGA Keyboard shortcut: Panel ${isVisible ? 'hidden' : 'shown'}`);
          }
        }, */

        // Quick Tab Access
        'Alt+V': () => openTabInPopout('values'),
        'Alt+P': () => openTabInPopout('pets'),
        'Alt+A': () => openTabInPopout('abilities'),
        'Alt+T': () => openTabInPopout('timers'),
        'Alt+S': () => openTabInPopout('seeds'),
        'Alt+G': () => openTabInPopout('settings'),

        // Navigation
        Tab: e => handleTabNavigation(e, true),
        'Shift+Tab': e => handleTabNavigation(e, false),
        ArrowUp: e => handleArrowNavigation(e, 'up'),
        ArrowDown: e => handleArrowNavigation(e, 'down'),
        ArrowLeft: e => handleArrowNavigation(e, 'left'),
        ArrowRight: e => handleArrowNavigation(e, 'right'),

        // Quick Actions
        'Ctrl+K': e => openCommandPalette(e),
        'Ctrl+F': e => openQuickSearch(e),
        'Ctrl+B': () => toggleShopWindows(),
        Enter: e => handleEnterKey(e),
        Space: e => handleSpaceKey(e),

        // Window Management
        Escape: () => handleEscapeKey(),
        'Alt+W': () => closeAllPopouts(),
        'Alt+R': () => refreshAllContent(),

        // Quick Pet Actions
        'Shift+1': () => loadPresetByNumber(1),
        'Shift+2': () => loadPresetByNumber(2),
        'Shift+3': () => loadPresetByNumber(3),
        'Shift+4': () => loadPresetByNumber(4),
        'Shift+5': () => loadPresetByNumber(5),

        // Crop Highlighting
        'Ctrl+H': () => clearCropHighlighting(),
        'Ctrl+Shift+H': () => {
          // Open settings tab and focus on crop highlighting section
          UnifiedState.activeTab = 'settings';
          updateTabContent();
          setTimeout(() => {
            const highlightSection = targetDocument.querySelector('#highlight-species-select');
            if (highlightSection) {
              highlightSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
              highlightSection.focus();
            }
          }, 100);
          productionLog('üå± Opened crop highlighting settings');
        }
      };

      document.addEventListener('keydown', e => {
        // BUGFIX v3.7.5: Ignore controller-generated keyboard events to prevent conflicts
        if (!e.isTrusted) return;
        // Skip if typing in input/textarea or contenteditable
        if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) {
          return;
        }
        // Skip if typing in contenteditable element (chat, etc.)
        if (e.target.isContentEditable || e.target.getAttribute?.('contenteditable') === 'true') {
          return;
        }
        // Skip if active element is an input (chat focus)
        if (
          document.activeElement &&
          (document.activeElement.tagName === 'INPUT' ||
            document.activeElement.tagName === 'TEXTAREA' ||
            document.activeElement.isContentEditable)
        ) {
          return;
        }

        const key = [];
        if (e.altKey) key.push('Alt');
        if (e.ctrlKey) key.push('Ctrl');
        if (e.shiftKey) key.push('Shift');

        // Special key handling
        if (e.key === 'Escape') key.push('Escape');
        else if (e.key === 'Tab') key.push('Tab');
        else if (e.key === 'Enter') key.push('Enter');
        else if (e.key === ' ') key.push('Space');
        else if (e.key.startsWith('Arrow')) key.push(e.key);
        else if (e.key.length === 1) key.push(e.key.toUpperCase());

        const shortcut = key.join('+');
        if (shortcuts[shortcut]) {
          e.preventDefault();
          shortcuts[shortcut](e);
        }
      });

      productionLog('‚å®Ô∏è Keyboard shortcuts initialized:', Object.keys(shortcuts));
    }

    // ==================== LOCAL TELEPORT UTILITIES ====================
    // Install window.localTeleport function for client-side position updates
    function installLocalTeleport() {
      if (window.localTeleport && window.localTeleport.__installed) {
        debugLog('TELEPORT', 'localTeleport already installed');
        return;
      }

      window.localTeleport = async function localTeleport(x, y, opts = {}) {
        const timeout = typeof opts.timeout === 'number' ? opts.timeout : 3000;

        // 1) Prefer built-in PlayerService if available (clean)
        try {
          const PS = targetWindow.PlayerService || (targetWindow.Quinoa && targetWindow.Quinoa.PlayerService) || null;
          if (PS && typeof PS.setPosition === 'function') {
            await PS.setPosition(x, y);
            targetWindow.MagicCircle_RoomConnection.sendMessage({
              scopePath: ['Room', 'Quinoa'],
              type: 'PlayerPosition',
              position: {
                x: x,
                y: y
              }
            });
            try {
              globalThis.__lastLocalTeleport = { x, y, at: Date.now() };
            } catch (e) {}
            return { ok: true, x, y, method: 'PlayerService.setPosition' };
          }
        } catch (e) {
          // ignore and continue to fallback
        }

        // 2) Fallback: use jotai atom cache capture technique (captures store.set)
        try {
          const cache = targetWindow.jotaiAtomCache?.cache;
          if (!cache) return { ok: false, error: 'jotaiAtomCache.cache not found' };

          // find positionAtom
          let positionAtom = null;
          for (const a of cache.values()) {
            const lbl = a?.debugLabel || a?.label || '';
            if (String(lbl) === 'positionAtom') {
              positionAtom = a;
              break;
            }
          }
          if (!positionAtom) return { ok: false, error: 'positionAtom not found in atom cache' };

          // capture set by temporarily wrapping write functions
          let capturedSet = null;
          const patched = [];
          try {
            for (const atom of cache.values()) {
              if (!atom || typeof atom.write !== 'function') continue;
              const orig = atom.write;
              // avoid double-wrap
              if (atom.__lt_origWrite) {
                patched.push(atom);
                continue;
              }

              atom.__lt_origWrite = orig;
              atom.write = function (get, set, ...args) {
                if (!capturedSet) {
                  capturedSet = set;
                  // restore patched writes immediately after capture (so we don't keep wrappers)
                  for (const p of patched) {
                    if (p.__lt_origWrite) {
                      try {
                        p.write = p.__lt_origWrite;
                      } catch (e) {}
                      try {
                        delete p.__lt_origWrite;
                      } catch (e) {}
                    }
                  }
                }
                return orig.call(this, get, set, ...args);
              };
              patched.push(atom);
            }

            // trigger the app to call writes (same trick used before)
            try {
              globalThis.dispatchEvent?.(new Event('visibilitychange'));
            } catch (e) {}

            // wait for capture (short loop)
            const until = Date.now() + timeout;
            while (!capturedSet && Date.now() < until) {
              await new Promise(r => setTimeout(r, 40));
            }
          } finally {
            // restore any remaining patched atoms
            for (const p of patched) {
              if (p.__lt_origWrite) {
                try {
                  p.write = p.__lt_origWrite;
                } catch (e) {}
                try {
                  delete p.__lt_origWrite;
                } catch (e) {}
              }
            }
          }

          if (!capturedSet) return { ok: false, error: 'Could not capture store.set from atom writes (timeout)' };

          // perform the local-only set (this does NOT send teleport packet)
          try {
            capturedSet(positionAtom, { x, y });
            try {
              globalThis.__lastLocalTeleport = { x, y, at: Date.now() };
            } catch (e) {}
            return { ok: true, x, y, method: 'jotai-capture' };
          } catch (err) {
            return { ok: false, error: 'capturedSet failed: ' + String(err) };
          }
        } catch (err) {
          return { ok: false, error: 'unexpected error: ' + String(err) };
        }
      };

      window.localTeleport.__installed = true;
      debugLog('TELEPORT', 'localTeleport(x,y) installed on window');
    }

    // ==================== TELEPORT SYSTEM ====================
    function initializeTeleportSystem() {
      productionLog('üöÄ [DEBUG] initializeTeleportSystem() called - setting up teleport system...');
      // FIRST: Install window.localTeleport if not already installed
      if (typeof window.localTeleport !== 'function' || !window.localTeleport.__installed) {
        installLocalTeleport();
      }

      if (window.__altSlotTeleportInstalled) {
        debugLog('TELEPORT', 'Alt-slot teleport hotkeys already installed');
        return;
      }

      async function teleportHandler(e) {
        if (!e.altKey) return;
        const num = parseInt(e.key, 10);
        if (!(num >= 1 && num <= 6)) return;

        e.preventDefault();
        e.stopPropagation();

        try {
          const slots = targetWindow.MagicCircle_RoomConnection?.lastRoomStateJsonable?.child?.data?.userSlots;
          if (!Array.isArray(slots)) {
            productionWarn('‚ö†Ô∏è userSlots not found in room state');
            return;
          }

          const slot = slots[num - 1];
          const pos = slot?.position;
          if (!pos || typeof pos.x !== 'number' || typeof pos.y !== 'number') {
            productionWarn(`‚ö†Ô∏è userSlots[${num - 1}] has no valid position`);
            return;
          }

          productionLog(`üéØ TELEPORTING Alt+${num} to userSlots[${num - 1}] @ (${pos.x}, ${pos.y})`);

          let clientUpdateSuccess = false;
          let serverSyncSuccess = false;

          // Method 1: CLIENT-SIDE POSITION UPDATE (using jotai atom access)
          try {
            productionLog(`üîß CLIENT: Updating local position via jotai atoms...`);

            // Method 1A: Try jotaiAtomCache for player position
            if (targetWindow.jotaiAtomCache) {
              productionLog(`üîç CLIENT: Searching jotaiAtomCache for player position atom...`);

              // Common player position atom paths to try
              const playerPositionPaths = [
                '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myPositionAtom',
                '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/playerPositionAtom',
                '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/playerAtoms.ts/myPositionAtom'
              ];

              let playerPositionAtom = null;
              for (const atomPath of playerPositionPaths) {
                const atom = targetWindow.jotaiAtomCache.get(atomPath);
                if (atom) {
                  productionLog(`‚úÖ CLIENT: Found player position atom at: ${atomPath}`);
                  playerPositionAtom = atom;
                  break;
                }
              }

              // If we found the atom, try to use it
              if (playerPositionAtom && playerPositionAtom.write) {
                try {
                  // Try to get the jotai store from window
                  const store = targetWindow.jotaiStore || targetWindow.store;
                  if (store && store.set) {
                    await store.set(playerPositionAtom, { x: pos.x, y: pos.y });
                    clientUpdateSuccess = true;
                    productionLog(`‚úÖ CLIENT: jotai atom position update successful to (${pos.x}, ${pos.y})`);
                  } else {
                    productionLog(`‚ö†Ô∏è CLIENT: Found atom but no jotai store available`);
                  }
                } catch (atomError) {
                  productionLog(`‚ùå CLIENT: jotai atom update failed:`, atomError);
                }
              } else {
                productionLog(`‚ùå CLIENT: No player position atom found in jotaiAtomCache`);

                // Debug: List available atoms
                if (UnifiedState.data.settings.debugMode) {
                  productionLog(
                    `üîç CLIENT: Available atoms in cache:`,
                    Array.from(targetWindow.jotaiAtomCache.keys()).filter(
                      key =>
                        key.includes('position') ||
                        key.includes('Position') ||
                        key.includes('player') ||
                        key.includes('Player')
                    )
                  );
                }
              }
            }

            // Method 1B: Try direct Atoms access (from reference script)
            if (!clientUpdateSuccess && window.Atoms?.player?.position?.set) {
              await window.Atoms.player.position.set({ x: pos.x, y: pos.y });
              clientUpdateSuccess = true;
              productionLog(`‚úÖ CLIENT: Atoms.player.position.set successful to (${pos.x}, ${pos.y})`);
            }

            // Method 1C: Fallback to existing localTeleport
            if (!clientUpdateSuccess && typeof window.localTeleport === 'function') {
              const res = await window.localTeleport(pos.x, pos.y);
              if (res?.ok) {
                clientUpdateSuccess = true;
                productionLog(`‚úÖ CLIENT: window.localTeleport successful to (${pos.x}, ${pos.y})`);
              }
            }

            // Method 1D: Fallback to PlayerService
            if (!clientUpdateSuccess) {
              const PS = targetWindow.PlayerService || targetWindow.Quinoa?.PlayerService;
              if (PS?.setPosition) {
                await PS.setPosition(pos.x, pos.y);
                clientUpdateSuccess = true;
                productionLog(`‚úÖ CLIENT: PlayerService.setPosition successful to (${pos.x}, ${pos.y})`);
              }
            }

            if (!clientUpdateSuccess) {
              productionLog(`‚ùå CLIENT: All client-side position update methods failed`);
              productionLog(`üîç CLIENT: Available globals:`, {
                jotaiAtomCache: !!targetWindow.jotaiAtomCache,
                windowAtoms: !!window.Atoms,
                localTeleport: typeof window.localTeleport,
                PlayerService: !!(targetWindow.PlayerService || targetWindow.Quinoa?.PlayerService)
              });
            }
          } catch (error) {
            productionLog(`‚ùå CLIENT: Client-side position update failed:`, error);
          }

          // Method 2: SERVER SYNC (using reference script pattern)
          try {
            productionLog(`üåê SERVER: Syncing position for multiplayer...`);

            // Use the proven working pattern: sendToGame with "Teleport" type
            const teleportSuccess = sendToGame({
              type: 'Teleport',
              position: { x: pos.x, y: pos.y }
            });

            if (teleportSuccess) {
              serverSyncSuccess = true;
              productionLog(`‚úÖ SERVER: Teleport message sent successfully`);
            } else {
              // Fallback to PlayerPosition message
              productionLog(`üîÑ SERVER: Trying PlayerPosition fallback...`);
              const fallbackSuccess = sendToGame({
                type: 'PlayerPosition',
                position: { x: pos.x, y: pos.y }
              });

              if (fallbackSuccess) {
                serverSyncSuccess = true;
                productionLog(`‚úÖ SERVER: PlayerPosition fallback successful`);
              }
            }

            if (!serverSyncSuccess) {
              productionLog(`‚ùå SERVER: All server sync methods failed`);
            }
          } catch (error) {
            productionLog(`‚ùå SERVER: Server sync failed:`, error);
          }

          // FINAL STATUS REPORT
          productionLog(`üéØ TELEPORT RESULT for Alt+${num}:`);
          productionLog(`   üë§ Client Update: ${clientUpdateSuccess ? '‚úÖ SUCCESS' : '‚ùå FAILED'}`);
          productionLog(`   üåê Server Sync: ${serverSyncSuccess ? '‚úÖ SUCCESS' : '‚ùå FAILED'}`);

          if (clientUpdateSuccess && serverSyncSuccess) {
            productionLog(`üéâ COMPLETE SUCCESS: Player teleported to (${pos.x}, ${pos.y})!`);
            debugLog(
              'TELEPORT',
              `Complete teleport success for Alt+${num} to userSlots[${num - 1}] @ (${pos.x}, ${pos.y})`
            );
          } else if (clientUpdateSuccess) {
            productionWarn(`‚ö†Ô∏è PARTIAL: You moved but others may not see it (server sync failed)`);
          } else if (serverSyncSuccess) {
            productionWarn(`‚ö†Ô∏è PARTIAL: Server updated but you didn't move visually (client update failed)`);
          } else {
            console.error(`‚ùå TOTAL FAILURE: Neither client nor server teleport worked`);
          }
        } catch (err) {
          console.error('‚ùå Alt-slot teleport error:', err);
          debugError('TELEPORT', 'Alt-slot teleport error', err);
        }
      }

      window.addEventListener('keydown', teleportHandler, true);
      window.__altSlotTeleportInstalled = true;
      productionLog('üöÄ Alt+1..Alt+6 teleport hotkeys installed');
      debugLog('TELEPORT', 'Teleport system initialized successfully');
    }

    // ==================== STANDALONE INITIALIZATION ====================
    function initializeStandalone() {
      if (UnifiedState.initialized) {
        productionLog('‚ö†Ô∏è Magic Garden Unified Assistant already initialized, skipping...');
        return;
      }

      productionLog('üéÆ Magic Garden Assistant - Demo Mode');
      productionLog('üí° Running in standalone mode with demo data');
      productionLog('üìù Note: This is a demonstration - no real game integration');

      // Ensure DOM is ready
      if (document.readyState === 'loading') {
        productionLog('‚è≥ DOM not ready, waiting for DOMContentLoaded...');
        document.addEventListener('DOMContentLoaded', initializeStandalone);
        return;
      }

      try {
        // Initialize demo data
        const demoData = createDemoData();

        // Populate UnifiedState with demo data
        UnifiedState.atoms.inventory = demoData.inventory;
        UnifiedState.atoms.myGarden = {
          garden: {
            tileObjects: generateDemoTiles(demoData.garden.readyTiles)
          }
        };
        UnifiedState.atoms.friendBonus = 1.2; // Demo bonus
        // Demo data disabled - only use real ability logs from users actual gameplay
        // UnifiedState.data.petAbilityLogs = demoData.abilityLogs;
        logDebug('DEMO', 'üìù Skipping demo ability logs injection - using real logs only');
        UnifiedState.data.timers = demoData.timers;

        // Load saved data (or use defaults)
        productionLog('üíæ Loading saved settings...');
        loadSavedData();

        // Create UI with demo banner
        productionLog('üé® Creating Demo UI...');
        // Clean up any corrupted dock position data before creating UI
        cleanupCorruptedDockPosition();
        createUnifiedUI();

        // TEST VERSION: Add UI health check and Alt+M toggle
        ensureUIHealthy();
        setupToolbarToggle();
        setupDockSizeControl();

        addDemoBanner();

        // Setup demo timers
        productionLog('‚è∞ Setting up demo timers...');
        setupDemoTimers();

        // Mark as initialized
        UnifiedState.initialized = true;
        productionLog('‚úÖ Magic Garden Assistant Demo initialized successfully!');
        productionLog('üéØ Try the features - they work with realistic demo data');
      } catch (error) {
        console.error('‚ùå Failed to initialize demo mode:', error);
        debugError('STANDALONE_INIT', 'Demo initialization failed', error);
        UnifiedState.initialized = false;
      }
    }

    function generateDemoTiles(count) {
      const tiles = {};
      const species = ['Carrot', 'Apple', 'Banana', 'Lily', 'Dragon Fruit'];

      for (let i = 0; i < count; i++) {
        tiles[i] = {
          objectType: 'plant',
          slots: [
            {
              species: species[i % species.length],
              endTime: Date.now() - 1000, // Ready for harvest
              targetScale: 1 + Math.random() * 0.5, // Random scale
              mutations: i % 3 === 0 ? ['Gold'] : [] // Some have mutations
            }
          ]
        };
      }

      return tiles;
    }

    function addDemoBanner() {
      // Add a demo mode banner to the main panel
      const panel = UnifiedState.panels.main;
      if (!panel) return;

      const banner = targetDocument.createElement('div');
      banner.style.cssText = `
              background: linear-gradient(90deg, #3b82f6, #8b5cf6);
              color: white;
              text-align: center;
              padding: 6px 12px;
              font-size: 11px;
              font-weight: 600;
              position: relative;
              margin: -1px -1px 8px -1px;
              border-radius: 6px 6px 0 0;
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.30);
          `;
      banner.innerHTML = 'üéÆ DEMO MODE - Showcasing full functionality with sample data';

      // Insert banner at the top of the panel
      const header = panel.querySelector('.mga-header');
      if (header) {
        panel.insertBefore(banner, header.nextSibling);
      }
    }

    function setupDemoTimers() {
      // Start demo timer countdown
      const timerManager = globalTimerManager || initializeTimerManager();

      timerManager.startTimer('demo-timer', 1000, () => {
        // Update demo timers
        if (UnifiedState.data.timers.seed > 0) UnifiedState.data.timers.seed--;
        if (UnifiedState.data.timers.egg > 0) UnifiedState.data.timers.egg--;
        if (UnifiedState.data.timers.tool > 0) UnifiedState.data.timers.tool--;

        // Update timer displays
        updateTimerDisplay();
      });
    }

    /* ============================================================================
     * 12. INITIALIZATION MODULE - MAIN BOOTSTRAP
     * ============================================================================
     * Main script initialization and startup sequence
     */

    /**
     * Main script initialization function
     * Bootstraps all modules and starts the application
     * @function initializeScript
     * @returns {void}
     */
    function initializeScript() {
      // DEBUG: Log initialization attempt
      if (window.MGA_DEBUG) {
        window.MGA_DEBUG.logStage('INITIALIZE_SCRIPT_CALLED', {
          initialized: UnifiedState.initialized,
          domState: document.readyState,
          retryAttempt: window.MGA_initRetryCount || 0
        });
      }

      if (UnifiedState.initialized) {
        productionLog('‚ö†Ô∏è Magic Garden Unified Assistant already initialized, skipping...');
        if (window.MGA_DEBUG) {
          window.MGA_DEBUG.logStage('ALREADY_INITIALIZED', { skipReason: 'UnifiedState.initialized is true' });
        }
        return;
      }

      // Ensure DOM is ready
      if (document.readyState === 'loading') {
        productionLog('‚è≥ DOM not ready, waiting for DOMContentLoaded...');
        if (window.MGA_DEBUG) {
          window.MGA_DEBUG.logStage('DOM_NOT_READY', { domState: document.readyState });
        }
        document.addEventListener('DOMContentLoaded', initializeScript);
        return;
      }

      // REMOVED: Modal check - was causing false positives and infinite retry loops

      // Improved initialization timing to prevent splash screen stall
      productionLog('‚è≥ Waiting for game initialization to complete...');
      let retryCount = 0;
      const maxRetries = 3;
      // CRITICAL FIX: If game is already ready, don't delay! Only delay if we need to retry
      const gameAlreadyReady =
        (targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache) && targetWindow.MagicCircle_RoomConnection;
      const initialDelay = gameAlreadyReady ? 0 : 2000;

      const attemptInit = () => {
        // Check if game is ready
        const gameReadiness = {
          jotaiAtomCache: !!targetWindow.jotaiAtomCache,
          magicCircleConnection: !!targetWindow.MagicCircle_RoomConnection,
          jotaiType: typeof targetWindow.jotaiAtomCache,
          connectionType: typeof targetWindow.MagicCircle_RoomConnection
        };

        if (window.MGA_DEBUG) {
          window.MGA_DEBUG.logStage('GAME_READINESS_CHECK', {
            retryCount,
            maxRetries,
            gameReadiness,
            timestamp: performance.now()
          });
        }

        if (targetWindow.jotaiAtomCache && targetWindow.MagicCircle_RoomConnection) {
          productionLog('‚úÖ Game ready, initializing script...');
          if (window.MGA_DEBUG) {
            window.MGA_DEBUG.logStage('GAME_READY', gameReadiness);
            // Safe performance metric setting
            if (window.MGA_DEBUG.performanceMetrics) {
              window.MGA_DEBUG.performanceMetrics.gameReady = performance.now();
            }
          }
          continueInitialization();
        } else if (retryCount < maxRetries) {
          retryCount++;
          productionLog(
            `‚è≥ Game not ready (jotaiAtomCache: ${!!targetWindow.jotaiAtomCache}, RoomConnection: ${!!targetWindow.MagicCircle_RoomConnection}), retry ${retryCount}/${maxRetries} in 1s...`
          );
          if (window.MGA_DEBUG) {
            window.MGA_DEBUG.logStage('GAME_NOT_READY_RETRYING', { retryCount, gameReadiness });
          }
          setTimeout(attemptInit, 1000);
        } else {
          productionWarn('‚ö†Ô∏è Max retries reached, initializing anyway...');
          if (window.MGA_DEBUG) {
            window.MGA_DEBUG.logStage('MAX_RETRIES_REACHED', { retryCount, gameReadiness });
          }
          continueInitialization();
        }
      };

      setTimeout(attemptInit, initialDelay);

      // CRITICAL: Ensure intervals start even if initialization partially fails
      setTimeout(() => {
        if (typeof window.notificationInterval === 'undefined' || !window._mgaIntervalsStarted) {
          productionWarn('‚ö†Ô∏è [FAILSAFE] Intervals not started after 30s, forcing start...');
          try {
            if (typeof startIntervals === 'function') {
              startIntervals();
              productionLog('‚úÖ [FAILSAFE] Successfully started intervals');
            } else {
              console.error('‚ùå [FAILSAFE] startIntervals function not found!');
            }
          } catch (e) {
            console.error('‚ùå [FAILSAFE] Could not start intervals:', e);
          }
        } else {
          productionLog('‚úÖ [FAILSAFE] Intervals already running, no action needed');
        }
      }, 30000); // Failsafe after 30 seconds

      function continueInitialization() {
        productionLog('üå± Magic Garden Unified Assistant initializing...');
        productionLog(
          'üìä Connection Status:',
          targetWindow.MagicCircle_RoomConnection ? '‚úÖ Available' : '‚ùå Not found'
        );

        if (window.MGA_DEBUG) {
          window.MGA_DEBUG.logStage('CONTINUE_INITIALIZATION', {
            connectionStatus: !!targetWindow.MagicCircle_RoomConnection,
            jotaiStatus: !!targetWindow.jotaiAtomCache,
            domState: document.readyState,
            timestamp: performance.now()
          });
        }

        // ==================== IDLE PREVENTION MOVED ====================
        // NOTE: Idle prevention code has been moved to line ~380 to execute immediately
        // This ensures the game doesn't kick users out while the script loads
        productionLog('üìù [IDLE-PREVENTION] Idle prevention already applied at script start');

        try {
          // Load saved data
          productionLog('üíæ Loading saved data...');
          loadSavedData();

          // Room polling handled by anonymous IIFE system (lines 28200-28365)
          // This system already polls all rooms including Discord rooms

          // ==================== SORT INVENTORY BUTTON (FIX ISSUE D) ====================

          // FIX BUG #1: Full autosort.txt implementation (v3.8.6) - replaces stub
          const sortInventoryKeepHeadAndSendMovesOptimized = function (inventoryObj, options = {}) {
            if (!inventoryObj || !Array.isArray(inventoryObj.items)) {
              console.error('[MGTOOLS-FIX-D] Invalid inventory object passed to sorter.');
              return null;
            }
            const items = inventoryObj.items;
            const fixedCount = Number(options.fixedCount || 9);
            const petSortBy = options.petSortBy === 'rarity' ? 'rarity' : 'xp';

            // Default pet rarity map (lower = earlier in sort)
            const defaultPetRarityMap = {
              Capybara: 0,
              Peacock: 0.1,
              Butterfly: 0.2, // Mythical
              Turtle: 1,
              Goat: 1.1, // Legendary
              Cow: 2,
              Pig: 2.1, // Rare
              Chicken: 3,
              Dragonfly: 3.1, // Uncommon
              Bee: 4,
              Worm: 4.1,
              Snail: 4.2 // Common
            };
            const petRarityMap = Object.assign({}, defaultPetRarityMap, options.petRarityMap || {});

            // helpers
            const toNum = v => (typeof v === 'number' ? v : Number(v) || 0);
            const toStr = v => (v == null ? '' : String(v));

            function groupRank(item) {
              if (!item) return 6;
              switch (item.itemType) {
                case 'Seed':
                  return 0;
                case 'Produce':
                  return 1;
                case 'Pet':
                  return 2;
                case 'Egg':
                  return 3;
                case 'Decor':
                  return 4;
                default:
                  return 5;
              }
            }

            function seedMetric(it) {
              return toNum(it.quantity);
            }
            function produceMetric(it) {
              return toNum(it.scale);
            }
            function petXpMetric(it) {
              return toNum(it.xp);
            }
            function eggMetric(it) {
              return toNum(it.quantity);
            }
            function decorMetric(it) {
              return toStr(it.decorId).toLowerCase();
            }
            function fallbackKey(it) {
              return (it && (it.species || it.decorId || it.toolId || it.eggId || it.id || ''))
                .toString()
                .toLowerCase();
            }

            function petRarityRank(species) {
              if (!species) return Number.MAX_SAFE_INTEGER;
              if (Object.prototype.hasOwnProperty.call(petRarityMap, species)) return petRarityMap[species];
              const lower = species.toLowerCase();
              for (const k of Object.keys(petRarityMap)) {
                if (k.toLowerCase() === lower) return petRarityMap[k];
              }
              return Number.MAX_SAFE_INTEGER;
            }

            // comparator for tail sorting
            function cmp(a, b) {
              const ga = groupRank(a),
                gb = groupRank(b);
              if (ga !== gb) return ga - gb;
              switch (ga) {
                case 0: {
                  // Seeds: quantity desc, tie -> species A-Z
                  const d = seedMetric(b) - seedMetric(a);
                  if (d !== 0) return d;
                  break;
                }
                case 1: {
                  // Produce: scale desc
                  const d = produceMetric(b) - produceMetric(a);
                  if (d !== 0) return d;
                  break;
                }
                case 2: {
                  // Pets
                  if (petSortBy === 'rarity') {
                    const ra = petRarityRank(a.petSpecies || a.species);
                    const rb = petRarityRank(b.petSpecies || b.species);
                    if (ra !== rb) return ra - rb; // lower = earlier
                    // tie-break: xp desc
                    const d = petXpMetric(b) - petXpMetric(a);
                    if (d !== 0) return d;
                    // final tie: species A-Z
                    const sa = (a.petSpecies || a.species || '').toString().toLowerCase();
                    const sb = (b.petSpecies || b.species || '').toString().toLowerCase();
                    if (sa < sb) return -1;
                    if (sa > sb) return 1;
                    break;
                  } else {
                    // xp sort
                    const d = petXpMetric(b) - petXpMetric(a);
                    if (d !== 0) return d;
                  }
                  break;
                }
                case 3: {
                  // Eggs: quantity desc
                  const d = eggMetric(b) - eggMetric(a);
                  if (d !== 0) return d;
                  break;
                }
                case 4: {
                  // Decor: A-Z by decorId
                  const da = decorMetric(a),
                    db = decorMetric(b);
                  if (da < db) return -1;
                  if (da > db) return 1;
                  break;
                }
                default:
                  break;
              }
              const fa = fallbackKey(a),
                fb = fallbackKey(b);
              if (fa < fb) return -1;
              if (fa > fb) return 1;
              return 0;
            }

            function getMoveItemId(item) {
              if (!item) return null;
              if (item.id) return item.id;
              if (item.species) return item.species;
              if (item.toolId) return item.toolId;
              if (item.eggId) return item.eggId;
              if (item.decorId) return item.decorId;
              return null;
            }

            // Build target order by keeping head and sorting the tail
            const head = items.slice(0, fixedCount);
            const tail = items.slice(fixedCount);
            const sortedTail = tail.slice().sort(cmp);
            const targetOrder = head.concat(sortedTail);

            // Working copy to simulate moves and compute from/to indices correctly
            const working = items.slice();

            function findIndexInWorking(desiredItem) {
              if (!desiredItem) return -1;
              // exact unique id first
              if (desiredItem.id) {
                for (let i = 0; i < working.length; i++) {
                  const it = working[i];
                  if (it && it.id && it.id === desiredItem.id) return i;
                }
              }
              // collect candidates for stackable matches or pets without id
              const candidates = [];
              for (let i = 0; i < working.length; i++) {
                const it = working[i];
                if (!it) continue;
                // species match (seeds, produce)
                if (desiredItem.species && it.species && it.species === desiredItem.species) {
                  candidates.push({ idx: i, score: toNum(it.quantity) });
                  continue;
                }
                if (desiredItem.toolId && it.toolId && it.toolId === desiredItem.toolId) {
                  candidates.push({ idx: i, score: toNum(it.quantity) });
                  continue;
                }
                if (desiredItem.eggId && it.eggId && it.eggId === desiredItem.eggId) {
                  candidates.push({ idx: i, score: toNum(it.quantity) });
                  continue;
                }
                if (desiredItem.decorId && it.decorId && it.decorId === desiredItem.decorId) {
                  candidates.push({ idx: i, score: 0 });
                  continue;
                }
                // pets without id: match by petSpecies and prefer higher xp
                if (
                  desiredItem.itemType === 'Pet' &&
                  desiredItem.petSpecies &&
                  it.itemType === 'Pet' &&
                  it.petSpecies === desiredItem.petSpecies
                ) {
                  candidates.push({ idx: i, score: toNum(it.xp) });
                  continue;
                }
              }
              if (candidates.length === 0) {
                // fallback match by any moveItemId-like field
                const want = getMoveItemId(desiredItem);
                if (!want) return -1;
                for (let i = 0; i < working.length; i++) {
                  const it = working[i];
                  if (!it) continue;
                  if (
                    (it.id && it.id === want) ||
                    (it.species && it.species === want) ||
                    (it.toolId && it.toolId === want) ||
                    (it.eggId && it.eggId === want) ||
                    (it.decorId && it.decorId === want)
                  ) {
                    return i;
                  }
                }
                return -1;
              }
              // pick best candidate (largest stack or highest xp)
              candidates.sort((a, b) => b.score - a.score);
              return candidates[0].idx;
            }

            function sendMove(moveItemId, toIndex) {
              if (!moveItemId || typeof toIndex !== 'number') return;
              const msg = {
                scopePath: ['Room', 'Quinoa'],
                type: 'MoveInventoryItem',
                moveItemId: moveItemId,
                toInventoryIndex: toIndex
              };
              if (
                targetWindow &&
                targetWindow.MagicCircle_RoomConnection &&
                typeof targetWindow.MagicCircle_RoomConnection.sendMessage === 'function'
              ) {
                targetWindow.MagicCircle_RoomConnection.sendMessage(msg);
              } else {
                console.warn('[MGTOOLS-FIX-D] MagicCircle_RoomConnection not available ‚Äî simulated move:', msg);
              }
            }

            // Build move list for indices >= fixedCount and update working to reflect each planned move
            const moves = [];
            for (let targetIndex = fixedCount; targetIndex < targetOrder.length; targetIndex++) {
              const desiredItem = targetOrder[targetIndex];
              const workingItem = working[targetIndex];

              const desiredKey = getMoveItemId(desiredItem);
              const workingKey = getMoveItemId(workingItem);
              const alreadySame =
                desiredKey &&
                workingKey &&
                (desiredKey === workingKey ||
                  (desiredItem.species && workingItem.species && desiredItem.species === workingItem.species));
              if (alreadySame) continue;

              const curIndex = findIndexInWorking(desiredItem);
              if (curIndex === -1) {
                console.warn('[MGTOOLS-FIX-D] Could not find desired item in current inventory for', desiredItem);
                continue;
              }

              const moveId = getMoveItemId(desiredItem);
              if (!moveId) {
                console.warn('[MGTOOLS-FIX-D] No moveItemId for', desiredItem);
                continue;
              }

              moves.push({ moveId, from: curIndex, to: targetIndex });
              const [moved] = working.splice(curIndex, 1);
              working.splice(targetIndex, 0, moved);
            }

            // Send moves immediately
            for (const m of moves) {
              sendMove(m.moveId, m.to);
            }

            console.log('[MGTOOLS-FIX-D] ‚úÖ Sort completed. Moves sent:', moves.length, moves);
            return targetOrder;
          };

          // Add Sort Inventory button after each CLEAR FILTERS button
          const addSortButtonAfterClearFilters = function () {
            const clearButtons = Array.from(targetDocument.querySelectorAll('button')).filter(
              btn => btn.textContent.trim().toUpperCase() === 'CLEAR FILTERS'
            );

            clearButtons.forEach(clearButton => {
              if (clearButton.dataset.sortBtnAdded === 'true') return;

              // FIX ISSUE D: EXACT copy from autosort.txt
              const container = targetDocument.createElement('div');
              container.className = 'custom-sort-container';
              container.style.display = 'inline-flex';
              container.style.alignItems = 'center';
              container.style.gap = '6px';
              container.style.marginLeft = '6px';

              // FIX ISSUE D: Button with EXACT autosort.txt styling
              const btn = targetDocument.createElement('button');
              btn.className = 'custom-sort-button';
              btn.textContent = 'Sort Inventory';
              btn.title = 'Click to sort (Shift+Click to sort pets by XP)';
              Object.assign(btn.style, {
                background: '#2b2a2a',
                color: 'white',
                border: '1px solid #555',
                borderRadius: '6px',
                padding: '6px 10px',
                cursor: 'pointer',
                fontSize: '13px',
                transform: 'translateX(calc(-1 * var(--offset, -200%)))'
              });

              // FIX BUG #1: Click handler with 3-tier inventory detection (v3.8.6)
              btn.addEventListener('click', ev => {
                const petSortBy = ev.shiftKey ? 'xp' : 'rarity';

                // 3-TIER FALLBACK: UnifiedState ‚Üí targetWindow ‚Üí window search
                const inventoryObj =
                  UnifiedState.atoms.inventory ||
                  targetWindow.inventory ||
                  targetWindow.Inventory ||
                  targetWindow.gameInventory ||
                  (typeof inventory !== 'undefined' && inventory) ||
                  null;

                if (!inventoryObj || !Array.isArray(inventoryObj.items)) {
                  console.error('[MGTOOLS-FIX-D] Could not find inventory object. Searching window keys...');
                  // Try to find any object on window with .items array (best-effort)
                  for (const k of Object.keys(targetWindow)) {
                    try {
                      const candidate = targetWindow[k];
                      if (candidate && candidate.items && Array.isArray(candidate.items)) {
                        console.log(`[MGTOOLS-FIX-D] ‚úÖ Using inventory from window["${k}"]`);
                        sortInventoryKeepHeadAndSendMovesOptimized(candidate, { fixedCount: 9, petSortBy });
                        return;
                      }
                    } catch (e) {
                      /* ignore */
                    }
                  }
                  console.error('[MGTOOLS-FIX-D] ‚ùå Failed to find inventory object anywhere');
                  return;
                }

                console.log(`[MGTOOLS-FIX-D] üîÑ Sorting inventory (${petSortBy === 'xp' ? 'XP' : 'Rarity'} sort)`);
                sortInventoryKeepHeadAndSendMovesOptimized(inventoryObj, { fixedCount: 9, petSortBy });
              });

              container.appendChild(btn);
              clearButton.insertAdjacentElement('afterend', container);
              clearButton.dataset.sortBtnAdded = 'true';

              console.log('[MGTOOLS-FIX-D] ‚úÖ Sort button added after CLEAR FILTERS');
            });
          };

          // Initialize Sort Inventory button with mutation observer
          const initializeSortInventoryButton = function () {
            console.log('[MGTOOLS-FIX-D] üöÄ Initializing Sort Inventory button...');

            // Initial injection
            addSortButtonAfterClearFilters();

            // Watch for DOM changes (inventory opening/closing)
            const observer = new MutationObserver(() => {
              addSortButtonAfterClearFilters();
            });

            observer.observe(targetDocument.body, { childList: true, subtree: true });

            // Store observer for cleanup if needed
            if (!targetWindow.MGToolsObservers) targetWindow.MGToolsObservers = [];
            targetWindow.MGToolsObservers.push(observer);

            console.log('[MGTOOLS-FIX-D] ‚úÖ Sort Inventory button initialized with mutation observer');
          };

          // ==================== INSTANT FEED BUTTONS ====================
          // Pet species and their compatible crops (from game data)
          const PET_FEED_CATALOG = {
            Worm: ['Carrot', 'Strawberry', 'Aloe', 'Tomato', 'Apple'],
            Snail: ['Blueberry', 'Tomato', 'Corn', 'Daffodil'],
            Bee: ['Strawberry', 'Blueberry', 'OrangeTulip', 'Daffodil', 'Lily'],
            Chicken: ['Aloe', 'Corn', 'Watermelon', 'Pumpkin'],
            Bunny: ['Carrot', 'Strawberry', 'Blueberry', 'Echeveria'],
            Dragonfly: ['Apple', 'OrangeTulip', 'Echeveria'],
            Pig: ['Watermelon', 'Pumpkin', 'Mushroom', 'Bamboo'],
            Cow: ['Coconut', 'Banana', 'BurrosTail', 'Mushroom'],
            Squirrel: ['Pumpkin', 'Banana', 'Grape'],
            Turtle: ['Watermelon', 'BurrosTail', 'Bamboo', 'Pepper'],
            Goat: ['Pumpkin', 'Coconut', 'Cactus', 'Pepper'],
            Butterfly: ['Daffodil', 'Lily', 'Grape', 'Lemon', 'Sunflower'],
            Capybara: ['Lemon', 'PassionFruit', 'DragonFruit', 'Lychee'],
            Peacock: ['Cactus', 'Sunflower', 'Lychee'],
            Copycat: []
          };

          // Safely derive the inventory item id the server expects
          const getInventoryItemId = item => item?.itemId ?? item?.inventoryItemId ?? item?.id ?? null;

          // Create instant feed button with game-native styling
          const createInstantFeedButton = function (petIndex) {
            const btn = targetDocument.createElement('button');
            btn.className = 'mgtools-instant-feed-btn';
            btn.textContent = 'Feed'; // Always start with "Feed" text
            btn.setAttribute('data-pet-index', petIndex);
            btn.setAttribute('data-cooldown', 'false'); // Track cooldown state

            // FIX ISSUE B: Check if feed buttons should be hidden
            const shouldHide = UnifiedState.data.settings.hideFeedButtons;

            // Use ABSOLUTE positioning relative to pet panel container
            // This scales with zoom and hides when container is hidden
            btn.style.cssText = `
                      position: absolute !important;
                      right: -50px !important;
                      top: 50% !important;
                      transform: translateY(-50%) !important;
                      width: 48px !important;
                      height: 24px !important;
                      border: 2px solid #FFC83D !important;
                      background: rgba(0, 0, 0, 0.75) !important;
                      color: rgb(205, 200, 193) !important;
                      border-radius: 6px !important;
                      font-size: 11px !important;
                      font-weight: bold !important;
                      cursor: pointer !important;
                      z-index: 9999 !important;
                      transition: all 0.2s ease !important;
                      pointer-events: auto !important;
                      display: ${shouldHide ? 'none' : 'block'} !important;
                      visibility: visible !important;
                      opacity: 1 !important;
                  `;

            btn.addEventListener('mouseenter', () => {
              btn.style.setProperty('box-shadow', '0 0 8px rgba(255, 200, 61, 0.6)', 'important');
              btn.style.setProperty('transform', 'translateY(-50%) scale(1.05)', 'important');
            });

            btn.addEventListener('mouseleave', () => {
              btn.style.setProperty('box-shadow', 'none', 'important');
              btn.style.setProperty('transform', 'translateY(-50%) scale(1)', 'important');
            });

            btn.addEventListener('click', e => {
              e.preventDefault();
              e.stopPropagation();
              // eslint-disable-next-line no-use-before-define -- definition below; function wired via event listener
              handleInstantFeed(petIndex, btn);
            });

            return btn;
          };

          // Track used crop IDs to avoid feeding same crop twice
          const usedCropIds = new Set();

          // Visual feedback for feed action
          const flashButton = function (btn, type) {
            const color = type === 'success' ? '#4CAF50' : '#F44336';
            const originalBorder = btn.style.borderColor;
            const originalShadow = btn.style.boxShadow;

            btn.style.borderColor = color;
            btn.style.boxShadow = `0 0 10px ${color}`;

            setTimeout(() => {
              btn.style.borderColor = originalBorder || '#FFC83D';
              btn.style.boxShadow = originalShadow || 'none';
            }, 300);
          };

          // Handle instant feed logic with auto-favorite protection (ASYNC)
          // SIMPLE INSTANT FEED - Just like native button
          const handleInstantFeed = async function (petIndex, buttonEl) {
            if (buttonEl.disabled) return;

            // Show loading state AFTER click (not before)
            buttonEl.disabled = true;
            buttonEl.textContent = '...';
            buttonEl.style.opacity = '0.6';

            try {
              // FIX ISSUE A: 3-tier fallback for pet data
              let pet = null;

              // Tier 1: Try Jotai atom cache (only need cache, not store!)
              if (targetWindow.jotaiAtomCache) {
                try {
                  const freshPetSlots = await getAtomValue('myPrimitivePetSlotsAtom');
                  if (freshPetSlots?.[petIndex]) {
                    pet = freshPetSlots[petIndex];
                    console.log('[MGTOOLS-FIX-A] Using fresh pet data from Jotai atom cache (Tier 1)');
                  }
                } catch (e) {
                  console.warn('[MGTOOLS-FIX-A] Tier 1 (atom cache) failed:', e.message);
                }
              }

              // Tier 2: UnifiedState atoms (updated by subscriptions)
              if (!pet && UnifiedState.atoms.activePets?.[petIndex]) {
                pet = UnifiedState.atoms.activePets[petIndex];
                console.log('[MGTOOLS-FIX-A] Using UnifiedState atoms (Tier 2)');
              }

              // Tier 3: window.myData (game global)
              if (!pet && targetWindow.myData?.petSlots?.[petIndex]) {
                pet = targetWindow.myData.petSlots[petIndex];
                console.log('[MGTOOLS-FIX-A] Using window.myData (Tier 3)');
              }

              if (!pet) {
                console.error('[MGTOOLS-FIX-A] ‚ùå No pet data available from any source');
                alert('Pet data not ready. Please wait a moment and try again.');
                flashButton(buttonEl, 'error');
                // Re-enable button after error
                buttonEl.disabled = false;
                buttonEl.textContent = 'Feed';
                buttonEl.style.opacity = '1';
                return;
              }

              const species = pet.petSpecies;
              const petItemId = pet.id;

              // STEP 1: Log active pet data
              console.log('[Feed-Flow-1] üêæ Active Pet:', {
                species,
                petItemId: petItemId.substring(0, 8) + '...',
                hunger: pet.hunger,
                hungerPercentage: pet.hunger ? `${pet.hunger}%` : 'N/A'
              });

              // Get compatible crops
              const compatibleCrops = PET_FEED_CATALOG[species];

              // STEP 2: Log compatible crops list for this species
              console.log(`[Feed-Flow-2] üåæ Compatible crops for ${species}:`, compatibleCrops || []);

              if (!compatibleCrops || compatibleCrops.length === 0) {
                console.error('[MGTools Feed] No compatible crops for', species);
                flashButton(buttonEl, 'error');
                // Re-enable button after error
                buttonEl.disabled = false;
                buttonEl.textContent = 'Feed';
                buttonEl.style.opacity = '1';
                return;
              }

              // FIX ISSUE A: 3-tier fallback for inventory data with cache clearing
              // Force fresh inventory read - clear any cached data first
              if (typeof unsafeWindow !== 'undefined' && unsafeWindow.__mga_cachedInventory) {
                delete unsafeWindow.__mga_cachedInventory;
              }

              let inventoryItems = null;

              // Tier 1: Try Jotai atom cache (only need cache, not store!)
              if (targetWindow.jotaiAtomCache) {
                try {
                  const freshInventory = await getAtomValue('myCropInventoryAtom');
                  if (freshInventory?.items) {
                    inventoryItems = freshInventory.items;
                    console.log('[MGTOOLS-FIX-A] Using fresh inventory from Jotai atom cache (Tier 1)');
                  }
                } catch (e) {
                  console.warn('[MGTOOLS-FIX-A] Inventory Tier 1 (atom cache) failed:', e.message);
                }
              }

              // Try alternate atom if first failed
              if (!inventoryItems) {
                try {
                  inventoryItems = readAtom('myCropItemsAtom') || [];
                  if (inventoryItems.length > 0) {
                    console.log('[MGTOOLS-FIX-A] Using myCropItemsAtom (Tier 1.5)');
                  }
                } catch (e) {
                  console.warn('[MGTOOLS-FIX-A] myCropItemsAtom failed:', e.message);
                }
              }

              // Tier 2: UnifiedState atoms
              if (!inventoryItems || inventoryItems.length === 0) {
                if (UnifiedState.atoms.inventory?.items) {
                  inventoryItems = UnifiedState.atoms.inventory.items.filter(
                    i => i.itemType === 'Produce' || i.itemType === 'Crop'
                  );
                  console.log('[MGTOOLS-FIX-A] Using UnifiedState inventory (Tier 2)');
                }
              }

              // Tier 3: window.myData
              if (!inventoryItems || inventoryItems.length === 0) {
                if (targetWindow.myData?.inventory?.items) {
                  inventoryItems = targetWindow.myData.inventory.items;
                  console.log('[MGTOOLS-FIX-A] Using window.myData inventory (Tier 3)');
                }
              }

              console.log('[Feed-Inventory] Fresh read:', inventoryItems?.length || 0, 'items');

              if (!inventoryItems || inventoryItems.length === 0) {
                console.error('[MGTOOLS-FIX-A] ‚ùå No inventory data available from any source');
                alert('Inventory not ready. Please wait a moment.');
                flashButton(buttonEl, 'error');
                // Re-enable button after error
                buttonEl.disabled = false;
                buttonEl.textContent = 'Feed';
                buttonEl.style.opacity = '1';
                return;
              }

              // STEP 3: Log full crop inventory
              console.log('[Feed-Flow-3] üì¶ Full inventory:', {
                count: inventoryItems.length,
                species: inventoryItems.map(item => item.species),
                items: inventoryItems
              });

              // Get MGTools favorited species
              const favoritedSpecies = UnifiedState.data?.autoFavorite?.selectedSpecies || [];

              // STEP 4: Log favorited species list
              console.log('[Feed-Flow-4] üö´ Favorited species:', favoritedSpecies);

              // Find first compatible, non-favorited crop that we haven't used yet
              const nonFavoritedCompatibleCrops = inventoryItems.filter(item => {
                if (!item || !item.species || !item.id) return false;
                const isCompatible = compatibleCrops.includes(item.species);
                const isFavorited = favoritedSpecies.includes(item.species);
                const notUsed = !usedCropIds.has(item.id);
                return isCompatible && !isFavorited && notUsed;
              });

              // STEP 5: Log non-favorited compatible crops available
              console.log('[Feed-Flow-5] ‚úÖ Non-favorited compatible crops available:', {
                count: nonFavoritedCompatibleCrops.length,
                species: nonFavoritedCompatibleCrops.map(item => item.species),
                items: nonFavoritedCompatibleCrops
              });

              const cropToFeed = nonFavoritedCompatibleCrops[0];

              // STEP 6: Log boolean check if compatible crop exists
              console.log(`[Feed-Flow-6] ‚ùì Compatible crop exists: ${!!cropToFeed}`);

              if (!cropToFeed) {
                console.error('[MGTools Feed] No feedable crops (compatible, non-favorited, unused)');
                console.log('[MGTools Feed] Compatible species:', compatibleCrops);
                console.log('[MGTools Feed] Favorited species:', favoritedSpecies);
                console.log('[MGTools Feed] Used crop IDs:', Array.from(usedCropIds));
                // Clear used crops and try again
                usedCropIds.clear();
                flashButton(buttonEl, 'error');
                // Re-enable button after error
                buttonEl.disabled = false;
                buttonEl.textContent = 'Feed';
                buttonEl.style.opacity = '1';
                return;
              }

              // Mark this crop as used BEFORE sending
              usedCropIds.add(cropToFeed.id);

              // 1) Resolve the correct ID field (prioritize 'id' over others)
              const cropItemId = cropToFeed?.id || cropToFeed?.inventoryItemId || cropToFeed?.itemId;

              console.log('[Feed-Flow-7a] üß™ Selected crop:', {
                species: cropToFeed?.species,
                fullItem: cropToFeed,
                resolvedId: cropItemId
              });

              // Validate the crop ID exists and is fresh
              if (!cropItemId) {
                console.error('[Feed] No valid ID found in crop item:', cropToFeed);
                flashButton(buttonEl, 'error');
                buttonEl.disabled = false;
                buttonEl.textContent = 'Feed';
                buttonEl.style.opacity = '1';
                return;
              }

              // Double-check crop still exists in current inventory
              const currentInventory = inventoryItems || [];
              const cropStillExists = currentInventory.some(
                item => item.id === cropItemId || item.inventoryItemId === cropItemId || item.itemId === cropItemId
              );

              if (!cropStillExists) {
                console.error('[Feed] Crop no longer in inventory! ID:', cropItemId);
                console.log(
                  '[Feed] Current inventory IDs:',
                  currentInventory.map(i => i.id || i.inventoryItemId || i.itemId)
                );
                // Remove from usedCropIds to allow selecting a different crop
                usedCropIds.delete(cropItemId);
                flashButton(buttonEl, 'error');
                buttonEl.disabled = false;
                buttonEl.textContent = 'Feed';
                buttonEl.style.opacity = '1';
                return;
              }

              // 2) Rebind/refresh petItemId from current slots (prevents stale ids)
              const slotsNow = readMyPetSlots() || [];
              const reboundPetItemId = slotsNow?.[petIndex]?.id || petItemId;
              if (reboundPetItemId !== petItemId) {
                console.warn('[Feed-Guard] Rebound petItemId from slots', {
                  old: petItemId,
                  new: reboundPetItemId,
                  petIndex
                });
              }

              // 3) Send with proper inventory item id
              console.log('[Feed-Debug] üöÄ Sending FeedPet message with inventoryItemId');

              // 4) Continue to feedPetEnsureSync(...) as before
              try {
                // Fire-and-forget - send feed immediately
                await sendFeedPet(reboundPetItemId, cropItemId);
                console.log(`[MGTools Feed] üöÄ Sent feed: ${species} with ${cropToFeed.species}`);

                // Immediate success UI - atoms will update naturally
                flashButton(buttonEl, 'success');

                // Re-enable button quickly for responsive spam-feeding
                setTimeout(() => {
                  buttonEl.disabled = false;
                  buttonEl.textContent = 'Feed';
                  buttonEl.style.opacity = '1';
                }, 200); // Short delay for visual feedback only

                // Verify in background (non-blocking) for debugging
                feedPetEnsureSync(reboundPetItemId, cropItemId, petIndex, false)
                  .then(result => {
                    if (!result?.verified) {
                      console.warn('[MGTools Feed] ‚ö†Ô∏è Background verification failed (feed may have worked anyway)');
                    } else {
                      console.log('[MGTools Feed] ‚úÖ Background verification succeeded');
                    }
                  })
                  .catch(err => console.warn('[MGTools Feed] Background verification error:', err));
              } catch (err) {
                console.warn('[MGTools Feed] ‚ö†Ô∏è Feed failed:', err.message);
                flashButton(buttonEl, 'error');
                usedCropIds.delete(cropToFeed.id);
                buttonEl.disabled = false;
                buttonEl.textContent = 'Feed';
                buttonEl.style.opacity = '1';
              }
            } catch (error) {
              console.error('[MGTools Feed] Error:', error);
              flashButton(buttonEl, 'error');

              // Re-enable button after error
              buttonEl.disabled = false;
              buttonEl.textContent = 'Feed';
              buttonEl.style.opacity = '1';
            }
          };

          // Wait for pet hunger to increase (like reference implementation does)
          const waitForHungerIncrease = async function (petIndex, previousHunger, timeout = 2000) {
            const startTime = performance.now();
            const HUNGER_EPSILON = 0.1; // Minimum hunger increase to consider success (0.1%)

            // Small initial delay to let server process
            await new Promise(resolve => setTimeout(resolve, 150));

            while (performance.now() - startTime < timeout) {
              try {
                // Get TRULY FRESH pet data using stored atom reference
                const freshPets = getAtomValueFresh('activePets');
                const pets = freshPets || UnifiedState.atoms.activePets;

                if (!pets || !pets[petIndex]) {
                  await new Promise(resolve => setTimeout(resolve, 100));
                  continue;
                }

                const currentPet = pets[petIndex];
                const currentHunger = currentPet.hunger;

                if (currentHunger !== undefined && previousHunger !== undefined) {
                  // Check if hunger decreased by at least epsilon (hunger goes DOWN when fed)
                  const hungerChange = previousHunger - currentHunger;

                  if (hungerChange >= HUNGER_EPSILON || currentHunger <= 1) {
                    // Hunger decreased (pet was fed) or pet is full
                    console.log(
                      `[MGTools Feed] Pet ${petIndex + 1} hunger decreased by ${hungerChange.toFixed(2)}ms (${previousHunger.toFixed(2)}ms ‚Üí ${currentHunger.toFixed(2)}ms)`
                    );
                    return { success: true, hungerBefore: previousHunger, hungerAfter: currentHunger };
                  }
                }
              } catch (err) {
                console.warn('[MGTools Feed] Error checking hunger:', err);
              }

              // Wait 100ms before checking again
              await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Timeout - operation may have failed
            console.warn(
              `[MGTools Feed] Timeout waiting for pet ${petIndex + 1} hunger to change from ${previousHunger?.toFixed(2)}ms`
            );
            return { success: false, hungerBefore: previousHunger, hungerAfter: previousHunger };
          };

          // Get TRULY FRESH inventory data using stored atom reference
          const getFreshInventoryFromAtoms = async function () {
            try {
              // Use getAtomValueFresh to get fresh inventory from the hooked atom
              const freshInventory = getAtomValueFresh('inventory');

              if (freshInventory && freshInventory.items && Array.isArray(freshInventory.items)) {
                console.log(
                  `[MGTools Feed] üîÑ Got FRESH inventory from hooked atom: ${freshInventory.items.length} items`
                );
                return freshInventory.items;
              }

              // Fallback: Try to get from UnifiedState.atoms (might be stale but better than nothing)
              console.warn('[MGTools Feed] Could not get fresh inventory from atom, trying UnifiedState...');
              if (UnifiedState.atoms.inventory?.items) {
                console.warn('[MGTools Feed] Using UnifiedState.atoms.inventory (might be stale)');
                return UnifiedState.atoms.inventory.items;
              }

              // Last resort: targetWindow.myData
              if (targetWindow.myData?.inventory?.items) {
                console.warn('[MGTools Feed] Using targetWindow.myData.inventory (likely stale)');
                return targetWindow.myData.inventory.items;
              }

              console.error('[MGTools Feed] No inventory data available from any source!');
              return [];
            } catch (error) {
              console.error('[MGTools Feed] Error getting fresh inventory:', error);
              // Final fallback
              return UnifiedState.atoms.inventory?.items || targetWindow.myData?.inventory?.items || [];
            }
          };

          // Re-entry guard to prevent infinite loop
          let isInjecting = false;

          // Inject instant feed buttons next to pet avatars
          const injectInstantFeedButtons = function () {
            // Prevent re-entry while already injecting (avoids MutationObserver infinite loop)
            if (isInjecting) {
              return;
            }

            try {
              isInjecting = true;
              console.log('[MGTools Feed] üîç Starting container-based injection...');

              // Check which buttons already exist by data-pet-index
              const existingButtons = targetDocument.querySelectorAll('.mgtools-instant-feed-btn');
              const existingIndices = new Set();
              existingButtons.forEach(btn => {
                const index = btn.getAttribute('data-pet-index');
                if (index !== null) {
                  existingIndices.add(parseInt(index, 10));
                }
              });

              if (existingIndices.size === 3) {
                isInjecting = false;
                return;
              }

              const missingIndices = [0, 1, 2].filter(i => !existingIndices.has(i));

              // Find ALL canvas elements
              const allCanvases = Array.from(targetDocument.querySelectorAll('canvas'));

              // Filter to pet avatar canvases (left 15% of screen, reasonable size)
              const viewportWidth = targetWindow.innerWidth;
              const viewportHeight = targetWindow.innerHeight;
              const leftThreshold = viewportWidth * 0.15;
              const minTop = 80;
              const maxTop = viewportHeight - 100;

              const petAvatarCanvases = allCanvases
                .filter(canvas => {
                  const rect = canvas.getBoundingClientRect();
                  const isOnScreen = rect.left >= 0 && rect.left < leftThreshold;
                  const hasReasonableSize =
                    rect.width > 20 && rect.width < 200 && rect.height > 20 && rect.height < 200;
                  const isInValidVerticalRange = rect.top > minTop && rect.top < maxTop;

                  if (isOnScreen && hasReasonableSize && isInValidVerticalRange) {
                  }

                  return isOnScreen && hasReasonableSize && isInValidVerticalRange;
                })
                .sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top)
                .slice(0, 3);

              if (petAvatarCanvases.length === 0) {
                console.warn('[MGTools Feed] ‚ö†Ô∏è No pet avatar canvases found!');
                isInjecting = false;
                return;
              }

              // For EACH canvas, find its pet panel container and inject button
              petAvatarCanvases.forEach((canvas, index) => {
                try {
                  // Skip if button already exists
                  if (existingIndices.has(index)) {
                    return;
                  }

                  // Find the SMALLEST container with STR/INT text (the pet panel)
                  let container = canvas.parentElement;
                  let levelsUp = 0;
                  const maxLevels = 10;
                  const candidates = [];

                  while (container && levelsUp < maxLevels && container !== targetDocument.body) {
                    const hasStats = /STR\s+\d+|INT\s+\d+/.test(container.textContent);
                    const rect = container.getBoundingClientRect();

                    if (hasStats && rect.width < 200 && rect.height < 200) {
                      // Valid small container with stats
                      candidates.push({
                        element: container,
                        area: rect.width * rect.height,
                        width: rect.width,
                        height: rect.height
                      });
                    }

                    container = container.parentElement;
                    levelsUp++;
                  }

                  if (candidates.length === 0) {
                    console.warn(`[MGTools Feed] ‚ö†Ô∏è No valid container found for pet ${index + 1}`);
                    return;
                  }

                  // Use SMALLEST container (most direct parent)
                  candidates.sort((a, b) => a.area - b.area);
                  const targetContainer = candidates[0].element;

                  console.log(`[MGTools Feed] üìê Selected container:`, {
                    width: candidates[0].width.toFixed(1),
                    height: candidates[0].height.toFixed(1),
                    tagName: targetContainer.tagName
                  });

                  // Check if button already exists in this container
                  if (targetContainer.querySelector('.mgtools-instant-feed-btn')) {
                    return;
                  }

                  // Set container to position: relative
                  const currentPosition = targetWindow.getComputedStyle(targetContainer).position;
                  if (currentPosition === 'static') {
                    targetContainer.style.position = 'relative';
                  }

                  // Create and append button
                  const btn = createInstantFeedButton(index);
                  targetContainer.appendChild(btn);

                  productionLog(`[MGTools Feed] Injected feed button ${index + 1}`);
                } catch (err) {
                  console.error(`[MGTools Feed] Error processing canvas ${index + 1}:`, err);
                }
              });

              // Reset flag after successful injection
              isInjecting = false;
            } catch (error) {
              console.error('[MGTools Feed] Error in injectInstantFeedButtons:', error);
              isInjecting = false; // Reset flag even on error
            }
          };

          // Initialize instant feed buttons with polling (reliable for CSS visibility changes)
          const initializeInstantFeedButtons = function () {
            console.log('[MGTools Feed] üöÄ Initializing instant feed buttons with polling interval...');

            // Try to capture jotaiStore early (but don't block if unavailable)
            if (!jotaiStore) {
              jotaiStore = captureJotaiStore();
              if (jotaiStore) {
                console.log('[MGTools Feed] ‚úÖ Jotai store captured at initialization');
              } else {
                console.log('[MGTools Feed] ‚è≥ Jotai store not ready yet - will use fallback data');
              }
            }

            // Helper to find all visible pet containers
            function findVisiblePetContainers() {
              const allCanvases = Array.from(targetDocument.querySelectorAll('canvas'));
              const viewportWidth = targetWindow.innerWidth;
              const viewportHeight = targetWindow.innerHeight;
              const leftThreshold = viewportWidth * 0.15;
              const minTop = 80;
              const maxTop = viewportHeight - 100;

              // Filter to pet avatar canvases (left side, reasonable size, visible)
              const petAvatarCanvases = allCanvases
                .filter(canvas => {
                  const rect = canvas.getBoundingClientRect();

                  // Check if visible (not hidden with CSS)
                  const computedStyle = targetWindow.getComputedStyle(canvas);
                  const isVisible =
                    computedStyle.display !== 'none' &&
                    computedStyle.visibility !== 'hidden' &&
                    rect.width > 0 &&
                    rect.height > 0;

                  if (!isVisible) return false;

                  const isOnScreen = rect.left >= 0 && rect.left < leftThreshold;
                  const hasReasonableSize =
                    rect.width > 20 && rect.width < 200 && rect.height > 20 && rect.height < 200;
                  const isInValidVerticalRange = rect.top > minTop && rect.top < maxTop;

                  return isOnScreen && hasReasonableSize && isInValidVerticalRange;
                })
                .sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top)
                .slice(0, 3);

              // Find containers for each canvas
              const containers = [];
              petAvatarCanvases.forEach(canvas => {
                let container = canvas.parentElement;
                let levelsUp = 0;
                const maxLevels = 10;
                const candidates = [];

                while (container && levelsUp < maxLevels && container !== targetDocument.body) {
                  const hasStats = /STR\s+\d+|INT\s+\d+/.test(container.textContent);
                  const rect = container.getBoundingClientRect();

                  if (hasStats && rect.width < 200 && rect.height < 200 && rect.width > 0) {
                    candidates.push({
                      element: container,
                      area: rect.width * rect.height
                    });
                  }

                  container = container.parentElement;
                  levelsUp++;
                }

                if (candidates.length > 0) {
                  // Use smallest container (most direct parent)
                  candidates.sort((a, b) => a.area - b.area);
                  containers.push(candidates[0].element);
                }
              });

              return containers;
            }

            // Helper to inject button into container
            function injectButton(container, index) {
              // Skip if button already exists
              if (container.querySelector('.mgtools-instant-feed-btn')) {
                return false;
              }

              try {
                // Set container to position: relative
                const currentPosition = targetWindow.getComputedStyle(container).position;
                if (currentPosition === 'static') {
                  container.style.position = 'relative';
                }

                // Create and append button
                const btn = createInstantFeedButton(index);
                container.appendChild(btn);

                return true;
              } catch (err) {
                console.error(`[MGTools Feed] Error injecting button ${index + 1}:`, err);
                return false;
              }
            }

            // Main polling function - checks and injects buttons if needed
            function checkAndInjectButtons() {
              const containers = findVisiblePetContainers();

              if (containers.length === 0) {
                // No visible pet containers - buttons will be checked again next poll
                return;
              }

              // Check if we need to inject any buttons
              let injectedCount = 0;
              containers.forEach((container, index) => {
                const injected = injectButton(container, index);
                if (injected) injectedCount++;
              });

              // Log if buttons were re-injected (means they disappeared and came back)
              if (injectedCount > 0) {
              }
            }

            // Initial injection
            checkAndInjectButtons();

            // Poll every 2000ms (2s) to check if buttons need re-injection
            // Reduced from 500ms for better performance while maintaining functionality
            // This handles CSS visibility changes that MutationObserver can't detect
            const pollInterval = setInterval(() => {
              try {
                // Only check if pet containers are actually visible
                const petContainers = findVisiblePetContainers();
                if (petContainers.length > 0) {
                  checkAndInjectButtons();
                }
              } catch (err) {
                console.error('[MGTools Feed] Error in polling:', err);
              }
            }, 2000);

            // Store interval ID for potential cleanup
            if (!targetWindow.MGToolsIntervals) {
              targetWindow.MGToolsIntervals = [];
            }
            targetWindow.MGToolsIntervals.push(pollInterval);

            console.log(
              '[MGTools Feed] ‚úÖ Polling active (500ms) - buttons will auto-reappear when containers become visible'
            );
            productionLog('‚úÖ [MGTools] Instant feed buttons initialized with polling detection');
          };

          // Verify data loaded before UI creation
          // productionLog('üîç [STARTUP-VERIFY] Data loaded before UI creation:', {
          //     petPresets: Object.keys(UnifiedState.data.petPresets).length,
          //     seedsToDelete: UnifiedState.data.seedsToDelete.length,
          //     autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled,
          //     dataLoaded: !!UnifiedState.data
          // });

          // Create UI
          // productionLog('üé® Creating UI...');
          if (window.MGA_DEBUG) {
            window.MGA_DEBUG.logStage('CREATE_UI_STARTING', {
              dataLoaded: !!UnifiedState.data,
              petPresets: Object.keys(UnifiedState.data?.petPresets || {}).length,
              targetDocumentReady: !!targetDocument.body
            });
          }

          try {
            // Clean up any corrupted dock position data before creating UI
            cleanupCorruptedDockPosition();

            createUnifiedUI();

            // TEST VERSION: Add UI health check and Alt+M toggle
            ensureUIHealthy();
            setupToolbarToggle();
            setupDockSizeControl();

            if (window.MGA_DEBUG) {
              window.MGA_DEBUG.logStage('CREATE_UI_COMPLETED', {
                uiElements: targetDocument.querySelectorAll('.mga-panel, .mga-toggle-btn').length,
                mainPanelExists: !!targetDocument.querySelector('.mga-panel'),
                toggleBtnExists: !!targetDocument.querySelector('.mga-toggle-btn')
              });
              // Safe performance metric setting
              if (window.MGA_DEBUG.performanceMetrics) {
                window.MGA_DEBUG.performanceMetrics.uiCreated = performance.now();
              }
            }

            // Initialize instant feed buttons after UI is created AND atom cache is ready
            (async () => {
              try {
                console.log('[MGTools Feed] üîç Waiting for Jotai atom cache before initializing feed buttons...');

                // Wait for atom cache to be ready (max 10 seconds)
                const maxWait = 10000;
                const startTime = Date.now();
                let atomCacheReady = false;

                while (Date.now() - startTime < maxWait) {
                  // Check if atom cache is ready (this is what we actually need!)
                  if (targetWindow.jotaiAtomCache) {
                    const elapsed = Date.now() - startTime;
                    console.log(`[MGTools Feed] ‚úÖ Jotai atom cache ready after ${elapsed}ms`);
                    UnifiedState.jotaiReady = true; // Mark as ready in UnifiedState
                    atomCacheReady = true;

                    // Try to capture store (nice to have but not required)
                    if (!jotaiStore) {
                      jotaiStore = captureJotaiStore();
                      if (jotaiStore) {
                        console.log('[MGTools Feed] ‚úÖ Also captured Jotai store');
                      } else {
                        console.log('[MGTools Feed] ‚ÑπÔ∏è Store not captured, will use direct atom cache reading');
                      }
                    }
                    break;
                  }

                  // Wait 200ms before next check
                  await new Promise(r => setTimeout(r, 200));
                }

                if (!atomCacheReady) {
                  console.warn('[MGTools Feed] ‚ö†Ô∏è Jotai atom cache not ready after timeout - initializing anyway');
                  UnifiedState.jotaiReady = false;
                }

                // Now initialize feed buttons
                initializeInstantFeedButtons();
              } catch (error) {
                console.error('[MGTools] Error initializing instant feed buttons:', error);
              }
            })();

            // FIX ISSUE D: Initialize Sort Inventory button
            setTimeout(() => {
              try {
                initializeSortInventoryButton();
              } catch (error) {
                console.error('[MGTools] Error initializing sort inventory button:', error);
              }
            }, 1500); // Slightly longer delay to ensure inventory UI is ready
          } catch (error) {
            console.error('‚ùå Error creating UI:', error);

            // Show visible error popup for user (especially important in Discord browser)
            try {
              const errorDiv = targetDocument.createElement('div');
              errorDiv.style.cssText = `
                          position: fixed;
                          top: 50%;
                          left: 50%;
                          transform: translate(-50%, -50%);
                          background: rgba(220, 38, 38, 0.95);
                          color: white;
                          padding: 20px;
                          border-radius: 8px;
                          z-index: 9999999;
                          font-family: monospace;
                          max-width: 500px;
                          box-shadow: 0 8px 32px rgba(0,0,0,0.5);
                      `;
              errorDiv.innerHTML = `
                          <div style="font-weight: bold; margin-bottom: 10px; font-size: 14px;">‚ùå MGTools UI Failed to Load</div>
                          <div style="font-size: 12px; margin-bottom: 10px; color: #fecaca;">${error.message}</div>
                          <div style="font-size: 11px; color: #fef2f2;">Press F12 and check Console for details</div>
                          <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 8px 16px; background: white; color: #dc2626; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Close</button>
                      `;
              targetDocument.body.appendChild(errorDiv);
            } catch (e) {
              // If even error display fails, log it
              console.error('Failed to show error UI:', e);
            }

            if (window.MGA_DEBUG) {
              window.MGA_DEBUG.logError(error, 'createUnifiedUI');
            }
            productionWarn('‚ö†Ô∏è UI creation failed, but continuing with initialization...');
            // DON'T throw error - continue with intervals even if UI fails
          }

          // Verify UI reflects loaded data immediately after creation
          setTimeout(() => {
            const checkedSeeds = targetDocument.querySelectorAll('.seed-checkbox:checked');
            // productionLog('üîç [UI-VERIFY] UI state after creation:', {
            //     checkedSeedsInUI: checkedSeeds.length,
            //     seedsInState: UnifiedState.data.seedsToDelete.length,
            //     matches: checkedSeeds.length === UnifiedState.data.seedsToDelete.length
            // });
          }, 100);

          // Initialize atom hooks
          productionLog('üîó Initializing atom hooks...');
          initializeAtoms();

          // Initialize turtle timer
          productionLog('üê¢ Initializing turtle timer...');
          initializeTurtleTimer();

          // Start monitoring intervals
          productionLog('‚è±Ô∏è Starting monitoring intervals...');
          startIntervals();

          // Apply saved theme settings
          productionLog('üé® Applying saved theme settings...');
          applyTheme();

          // Apply saved UI mode
          if (UnifiedState.data.settings.ultraCompactMode) {
            productionLog('üì± Applying saved ultra-compact mode...');
            applyUltraCompactMode(true);
          }

          // Apply saved weather setting
          productionLog('üåßÔ∏è Applying saved weather setting...');
          applyWeatherSetting();

          // Initialize keyboard shortcuts
          initializeKeyboardShortcuts();

          // Force UI refresh to apply saved state (timing fix for data persistence)
          productionLog('üîÑ Applying delayed UI refresh to ensure saved state is displayed...');
          setTimeout(() => {
            productionLog('üîÑ [DATA-PERSISTENCE] Applying delayed UI refresh...');

            // Verify data before refreshing UI
            productionLog('üìä [DATA-PERSISTENCE] Current state:', {
              petPresets: Object.keys(UnifiedState.data.petPresets).length,
              seedsToDelete: UnifiedState.data.seedsToDelete.length,
              autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled
            });

            // Update main tab content to reflect loaded data
            if (typeof updateTabContent === 'function') {
              updateTabContent();
              productionLog('‚úÖ [DATA-PERSISTENCE] UI refreshed with saved state');
            }

            // Update any open popout overlays
            if (UnifiedState.data?.popouts?.overlays) {
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                if (overlay && document.contains(overlay)) {
                  try {
                    const content = getContentForTab(tabName, true);
                    const contentEl = overlay.querySelector('.mga-overlay-content, .mga-content');
                    if (contentEl) {
                      contentEl.innerHTML = content;
                      // Set up handlers for the refreshed content
                      if (tabName === 'seeds' && typeof setupSeedsTabHandlers === 'function') {
                        setupSeedsTabHandlers(overlay);
                      } else if (tabName === 'pets' && typeof setupPetsTabHandlers === 'function') {
                        setupPetsTabHandlers(overlay);
                      }
                      productionLog(`‚úÖ [DATA-PERSISTENCE] Refreshed ${tabName} overlay with saved state`);
                    }
                  } catch (error) {
                    productionWarn(`‚ö†Ô∏è [DATA-PERSISTENCE] Failed to refresh ${tabName} overlay:`, error);
                  }
                }
              });
            }
          }, 1000); // 1000ms delay to ensure all data loading is complete (increased for refresh stability)

          // Initialize teleport system
          initializeTeleportSystem();

          // Initialize crop highlighting system
          setupCropHighlightingSystem();

          // Initialize hotkey system
          initializeHotkeySystem();

          // Initialize tooltip system
          if (window.MGA_Tooltips) {
            window.MGA_Tooltips.init();
            productionLog('üí¨ Tooltip system initialized');
          }

          UnifiedState.initialized = true;
          window._MGA_INITIALIZED = true;
          try {
            delete window._MGA_INITIALIZING;
          } catch (e) {
            window._MGA_INITIALIZING = false;
          }
          window._MGA_TIMESTAMP = Date.now(); // Update timestamp on completion

          // NOW run conflict detection after game has loaded successfully
          // productionLog('üîç [MGA-ISOLATION] Running post-initialization external script conflict detection...');
          if (window.MGA_ConflictDetection) {
            // Detect external script presence
            const mainScriptDetected = window.MGA_ConflictDetection.detectMainScript();

            // Only create barriers if external scripts detected
            if (mainScriptDetected) {
              productionLog('üîí [MGA-ISOLATION] External scripts detected - creating protective barriers');
              window.MGA_ConflictDetection.createIsolationBarrier();
              window.MGA_ConflictDetection.preventAccess();
            }

            // Run integrity checks
            const integrityOk = window.MGA_ConflictDetection.checkGlobalIntegrity();
            const isolationOk = window.MGA_ConflictDetection.validateIsolation();

            if (integrityOk && isolationOk) {
              productionLog('‚úÖ [MGA-ISOLATION] Final integrity check passed - no conflicts detected');
              if (mainScriptDetected) {
                productionLog('‚úÖ [MGA-ISOLATION] Complete isolation validated - external script protection active');
              }
            } else {
              productionWarn('‚ö†Ô∏è [MGA-ISOLATION] Final integrity check found potential conflicts');
              if (!integrityOk) productionWarn('‚ö†Ô∏è [MGA-ISOLATION] Global integrity issues detected');
              if (!isolationOk) productionWarn('‚ö†Ô∏è [MGA-ISOLATION] Isolation validation failed');
            }
          } else {
            productionWarn('‚ö†Ô∏è [MGA-ISOLATION] ConflictDetection not available - running without isolation');
          }

          productionLog('‚úÖ Magic Garden Unified Assistant initialized successfully!');

          // Add global recovery function for users whose UI disappears
          targetWindow.MGA_SHOW_UI = function () {
            console.log('%cüîß MGTools Recovery', 'color: #4CAF50; font-weight: bold; font-size: 14px');
            console.log('Clearing corrupted UI state...');
            try {
              localStorage.removeItem('mgh_toolbar_visible');
              localStorage.removeItem('mgh_dock_position');
              localStorage.removeItem('mgh_dock_orientation');
              console.log('‚úÖ State cleared. Reloading page...');
              setTimeout(() => location.reload(), 500);
            } catch (e) {
              console.error('‚ùå Recovery failed:', e);
              console.log('Try manually: localStorage.clear() then refresh');
            }
          };

          // Startup banner with recovery instructions
          console.log(
            '%cüéÆ MGTools v' + (typeof GM_info !== 'undefined' ? GM_info.script.version : '1.1.1') + ' Loaded',
            'color: #4CAF50; font-weight: bold; font-size: 14px'
          );
          console.log('%cüí° UI not showing? Run in console: MGA_SHOW_UI()', 'color: #FFC107; font-size: 12px');

          // Remove test UI after successful initialization
          const testUI =
            targetDocument.querySelector('div[style*="Test UI Active"]') ||
            targetDocument.querySelector('div[style*="MGA Test UI"]') ||
            Array.from(targetDocument.querySelectorAll('div')).find(
              div => div.textContent && div.textContent.includes('Test UI Active')
            );
          if (testUI) {
            testUI.remove();
            debugLog('UI_LIFECYCLE', 'Test UI removed after successful initialization');
          }

          // Check connection status periodically using managed interval
          setManagedInterval(
            'connectionCheck',
            () => {
              const hasConnection =
                targetWindow.MagicCircle_RoomConnection &&
                typeof targetWindow.MagicCircle_RoomConnection.sendMessage === 'function';
              if (!UnifiedState.connectionStatus && hasConnection) {
                productionLog('üîå Game connection established!');
                UnifiedState.connectionStatus = true;
              } else if (UnifiedState.connectionStatus && !hasConnection) {
                productionWarn('‚ö†Ô∏è Game connection lost!');
                UnifiedState.connectionStatus = false;
              }
            },
            5000
          );
        } catch (error) {
          console.error('‚ùå Failed to initialize Magic Garden Unified Assistant:', error);
          console.error('Stack trace:', error.stack);
          UnifiedState.initialized = false; // Allow retry
        }
      } // End continueInitialization function
    }

    // ==================== ENVIRONMENT-AWARE INITIALIZATION ====================
    /* CHECKPOINT removed: ENVIRONMENT_INITIALIZATION_START */

    function initializeBasedOnEnvironment() {
      console.log('üîçüîçüîç [EXECUTION] ENTERED initializeBasedOnEnvironment()');
      /* CHECKPOINT removed: DETECT_ENVIRONMENT_CALL */
      console.log('üîç [EXECUTION] About to call detectEnvironment()');
      const environment = detectEnvironment();
      console.log('üîç [EXECUTION] detectEnvironment() returned:', environment);
      /* CHECKPOINT removed: DETECT_ENVIRONMENT_COMPLETE */

      productionLog('üìä Environment Analysis:', {
        domain: environment.domain,
        strategy: environment.initStrategy,
        isGame: environment.isGameEnvironment,
        hasAtoms: environment.hasJotaiAtoms,
        hasConnection: environment.hasMagicCircleConnection
      });

      switch (environment.initStrategy) {
        case 'game-ready':
          productionLog('‚úÖ Game environment ready - initializing with full integration');
          initializeScript();
          break;

        case 'game-wait':
          productionLog('‚è≥ Game environment detected - waiting for game atoms...');
          waitForGameReady();
          break;

        case 'standalone':
          productionLog('üéÆ Standalone environment - initializing demo mode');
          initializeStandalone();
          break;

        case 'skip':
          productionLog('‚è≠Ô∏è Skipping initialization - script will run in game iframe only');
          // Do not initialize on Discord page itself
          break;

        default:
          productionLog('‚ùì Unknown environment - attempting standalone mode');
          initializeStandalone();
          break;
      }
    }

    function waitForGameReady() {
      let attempts = 0;
      const maxAttempts = 20; // 10 seconds at 500ms intervals

      const checkGameReady = () => {
        // More flexible game readiness check - be less strict about requirements
        const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
        const hasAtoms = atomCache && typeof atomCache === 'object';
        const hasConnection =
          targetWindow.MagicCircle_RoomConnection && typeof targetWindow.MagicCircle_RoomConnection === 'object';
        const hasBasicDom = targetDocument.body && document.readyState === 'complete';

        // Check for alternative game indicators if primary ones fail (use regular document for game detection)
        const hasGameElements =
          document.querySelector('canvas') ||
          document.querySelector('[class*="game"]') ||
          document.querySelector('[id*="game"]') ||
          document.querySelector('div[style*="position"]');

        // Additional check: verify atoms actually contain expected keys
        const atomsReady = hasAtoms && atomCache.size > 0;

        // Be more lenient - initialize if we have DOM ready and some game indicators
        if ((atomsReady && hasConnection && hasBasicDom) || (hasBasicDom && hasGameElements && attempts >= 10)) {
          if (atomsReady && hasConnection) {
            productionLog('‚úÖ Game atoms and connection fully ready - switching to full mode');
            productionLog('üìä [GAME-READY] Atoms count:', atomCache.size);
          } else {
            productionLog('‚úÖ Game elements detected, proceeding with reduced functionality mode');
          }

          initializeScript();
          return true;
        }

        // Debug logging for what's missing
        if (attempts % 8 === 0) {
          // Every 4 seconds
          productionLog('‚è≥ [GAME-WAIT] Still waiting...', {
            hasAtoms,
            atomsCount: hasAtoms ? atomCache.size : 0,
            hasConnection,
            hasBasicDom,
            hasGameElements,
            readyState: document.readyState,
            attempt: attempts,
            willProceedAt: attempts >= 10 ? 'Next check (fallback mode)' : `Attempt ${10 - attempts} more`
          });
        }

        return false;
      };

      if (!checkGameReady()) {
        // Use managed interval for game check
        setManagedInterval(
          'gameCheck',
          () => {
            attempts++;

            if (checkGameReady() || attempts >= maxAttempts) {
              clearManagedInterval('gameCheck');

              if (attempts >= maxAttempts) {
                productionLog('‚ö†Ô∏è Game readiness timeout - falling back to demo mode');
                productionLog('üí° You can try MGA.init() later if the game loads');
                initializeStandalone();
              }
            }
          },
          500
        );
      }
    }

    // Start environment-based initialization
    /* CHECKPOINT removed: CALLING_MAIN_INITIALIZATION */
    console.log(
      'üîçüîçüîç [EXECUTION] Reached end of startMGAInitialization, about to call initializeBasedOnEnvironment()'
    );
    try {
      console.log('üîç [EXECUTION] Calling initializeBasedOnEnvironment()...');
      initializeBasedOnEnvironment();
      console.log('üîç [EXECUTION] initializeBasedOnEnvironment() returned!');
      /* CHECKPOINT removed: MAIN_INITIALIZATION_COMPLETE */

      // Initialize crop protection hooks
      setTimeout(() => {
        initializeProtectionHooks();
      }, 3000);
    } catch (error) {
      console.error('‚ùå‚ùå‚ùå [EXECUTION] MAIN_INITIALIZATION_FAILED:', error);
      console.error('‚ùå [EXECUTION] Error stack:', error.stack);
      console.error('üîß This error caused the script to stop working');
    }
    console.log('üîç [EXECUTION] Completed startMGAInitialization try-catch block');

    // ==================== IMMEDIATE TEST INITIALIZATION ====================
    // Additional fallback for manual testing - only if initialization failed
    productionLog('üß™ Setting up fallback timer for manual testing...');
    setTimeout(() => {
      // Only run demo mode if game mode completely failed to initialize
      if (!UnifiedState.initialized && !window._MGA_INITIALIZING) {
        productionLog('üîß Final fallback - trying demo mode');
        productionLog('üí° Use MGA.init() to force game mode initialization if needed');
        initializeStandalone();
      } else if (UnifiedState.initialized) {
        productionLog('‚úÖ Game mode already initialized - skipping demo fallback');
      }
    }, 5000);

    /* ============================================================================
     * 13. PUBLIC API MODULE
     * ============================================================================
     * External interfaces and debugging utilities
     */

    /**
     * Public API for debugging and external access
     * @namespace MGA
     * @global
     */
    window.MGA = {
      state: UnifiedState,

      // Manual controls
      showPanel: () => {
        if (UnifiedState.panels.main) {
          UnifiedState.panels.main.style.display = 'block';
        }
      },

      hidePanel: () => {
        if (UnifiedState.panels.main) {
          UnifiedState.panels.main.style.display = 'none';
        }
      },

      // Manual initialization - use if script doesn't auto-initialize
      init: () => {
        productionLog('üîÑ Manual initialization requested...');
        UnifiedState.initialized = false; // Reset flag
        initializeScript();
      },

      // Recovery function for stuck initialization
      forceReinit: () => {
        productionLog('üîÑ Force reinitialization requested...');
        try {
          delete window._MGA_INITIALIZING;
        } catch (e) {
          window._MGA_INITIALIZING = undefined;
        }
        try {
          delete window._MGA_INITIALIZED;
        } catch (e) {
          window._MGA_INITIALIZED = undefined;
        }
        try {
          delete window._MGA_TIMESTAMP;
        } catch (e) {
          window._MGA_TIMESTAMP = undefined;
        }
        window._MGA_FORCE_INIT = true;
        location.reload();
      },

      // Data persistence diagnostics
      checkPersistence: () => {
        productionLog('üìä Data Persistence Check:');
        productionLog('  Pet Presets in State:', Object.keys(UnifiedState.data.petPresets).length);
        productionLog('  Pet Presets in Storage:', localStorage.getItem('MGA_petPresets') ? 'EXISTS' : 'MISSING');
        productionLog('  Seeds in State:', UnifiedState.data.seedsToDelete.length);
        productionLog('  Seeds in Storage:', localStorage.getItem('MGA_seedsToDelete') ? 'EXISTS' : 'MISSING');

        if (localStorage.getItem('MGA_petPresets')) {
          productionLog('  Raw Presets:', localStorage.getItem('MGA_petPresets'));
        }
        if (localStorage.getItem('MGA_seedsToDelete')) {
          productionLog('  Raw Seeds:', localStorage.getItem('MGA_seedsToDelete'));
        }
      },

      // Pop-out functionality
      popout: {
        openTab: tabName => openTabInPopout(tabName),
        openSeparateWindow: tabName => openTabInSeparateWindow(tabName),
        createOverlay: tabName => createInGameOverlay(tabName),
        closeOverlay: tabName => closeInGameOverlay(tabName),
        refreshOverlay: tabName => refreshOverlayContent(tabName)
      },

      // Debug functions
      debug: {
        logState: () => productionLog('MGA State:', UnifiedState),
        logAtoms: () => productionLog('Atoms:', UnifiedState.atoms),
        logData: () => productionLog('Data:', UnifiedState.data),
        testTheming: () => {
          productionLog('üé® Testing universal theming system...');
          productionLog('Current theme:', UnifiedState.currentTheme);
          productionLog('Active overlays:', UnifiedState.data.popouts.overlays.size);
          productionLog('Theme sync working:', !!UnifiedState.currentTheme);

          // Apply a test theme change
          const originalStyle = UnifiedState.data.settings.gradientStyle;
          UnifiedState.data.settings.gradientStyle = 'rainbow-burst';
          UnifiedState.data.settings.opacity = 75;
          applyTheme();

          productionLog('‚úÖ Test theme applied! Check all windows for rainbow theme.');
          productionLog('üí° Open a pop-out or overlay to see the theme in action!');

          // Restore original after 5 seconds
          setTimeout(() => {
            UnifiedState.data.settings.gradientStyle = originalStyle;
            UnifiedState.data.settings.opacity = 95;
            applyTheme();
            productionLog('üîÑ Original theme restored.');
          }, 5000);
        },

        checkConnection: () => {
          const hasConnection =
            targetWindow.MagicCircle_RoomConnection &&
            typeof targetWindow.MagicCircle_RoomConnection.sendMessage === 'function';
          productionLog('üîå Connection Status:', hasConnection ? '‚úÖ Available' : '‚ùå Not Available');
          productionLog('üì° RoomConnection Object:', targetWindow.MagicCircle_RoomConnection);
          return hasConnection;
        },

        testSendMessage: () => {
          productionLog('üß™ Testing safeSendMessage...');
          const result = safeSendMessage({
            scopePath: ['Room'],
            type: 'Ping'
          });
          productionLog('Result:', result ? '‚úÖ Success' : '‚ùå Failed');
          return result;
        },

        debugStorage: () => window.MGA_debugStorage(),

        // Test functions
        testAbilityLog: () => {
          UnifiedState.data.petAbilityLogs.unshift({
            petName: 'Test Pet',
            abilityType: 'Test Ability',
            timestamp: Date.now(),
            timeString: new Date().toLocaleTimeString(),
            data: { test: true }
          });

          // Apply memory management for test logs too
          UnifiedState.data.petAbilityLogs = MGA_manageLogMemory(UnifiedState.data.petAbilityLogs);
          MGA_debouncedSave('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
          if (UnifiedState.activeTab === 'abilities') {
            updateTabContent();
          }
          // Update all overlay windows showing abilities tab
          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
            if (overlay && document.contains(overlay) && tabName === 'abilities') {
              if (overlay.className.includes('mga-overlay-content-only')) {
                // NEW: Pure content overlays - refresh entire overlay
                updatePureOverlayContent(overlay, tabName);
                debugLog('OVERLAY_LIFECYCLE', 'Updated pure abilities overlay after test ability');
              } else {
                // LEGACY: Old overlay structure
                const overlayContent = overlay.querySelector('.mga-overlay-content > div');
                if (overlayContent) {
                  overlayContent.innerHTML = getAbilitiesTabContent();
                  // Update ability log display within this overlay context
                  setTimeout(() => updateAbilityLogDisplay(overlay), 10);
                  // Re-add resize handle after content update
                  setTimeout(() => {
                    if (!overlay.querySelector('.mga-resize-handle')) {
                      addResizeHandleToOverlay(overlay);
                      productionLog('üîß [RESIZE] Re-added missing resize handle to ability logs overlay');
                    }
                  }, 50);
                }
              }
            }
          });
        },

        testTimer: () => {
          UnifiedState.data.timers = {
            seed: 120,
            egg: 240,
            tool: 180,
            lunar: 3600
          };
          if (UnifiedState.activeTab === 'timers') {
            updateTimerDisplay();
          }
        },

        testValues: () => {
          UnifiedState.data.inventoryValue = 123456;
          UnifiedState.data.tileValue = 78900;
          UnifiedState.data.gardenValue = 456789;
          if (UnifiedState.activeTab === 'values') {
            updateTabContent();
          }
        }
      },

      // Manual refresh functions
      refresh: {
        pets: () => {
          if (UnifiedState.activeTab === 'pets') {
            // Use targeted updates instead of full DOM rebuild to prevent UI interruption
            const context = document.getElementById('mga-tab-content');
            if (context) {
              updatePetPresetDropdown(context);
              // Update popouts without touching main tab
              refreshSeparateWindowPopouts('pets');
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                if (overlay && document.contains(overlay) && tabName === 'pets') {
                  if (overlay.className.includes('mga-overlay-content-only')) {
                    updatePureOverlayContent(overlay, tabName);
                  }
                }
              });
            }
          }
        },
        abilities: () => {
          if (UnifiedState.activeTab === 'abilities') updateTabContent();
        },
        seeds: () => {
          if (UnifiedState.activeTab === 'seeds') updateTabContent();
        },
        values: () => {
          updateValues();
          if (UnifiedState.activeTab === 'values') updateTabContent();
        },
        timers: () => {
          updateTimers();
          if (UnifiedState.activeTab === 'timers') updateTimerDisplay();
        },
        all: () => {
          updateTabContent();
          updateValues();
          updateTimers();
        }
      },

      // Export functions
      export: {
        petPresets: () => {
          const data = JSON.stringify(UnifiedState.data.petPresets, null, 2);
          const blob = new Blob([data], { type: 'application/json' });
          const link = targetDocument.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'MGA_PetPresets.json';
          link.click();
        },

        abilityLogs: () => exportAbilityLogs(),

        allData: () => {
          const data = JSON.stringify(
            {
              petPresets: UnifiedState.data.petPresets,
              petAbilityLogs: UnifiedState.data.petAbilityLogs,
              settings: {
                seedsToDelete: UnifiedState.data.seedsToDelete,
                autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled
              }
            },
            null,
            2
          );
          const blob = new Blob([data], { type: 'application/json' });
          const link = targetDocument.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `MGA_AllData_${new Date().toISOString().split('T')[0]}.json`;
          link.click();
        }
      },

      // Import functions
      import: {
        petPresets: jsonString => {
          try {
            const data = JSON.parse(jsonString);
            UnifiedState.data.petPresets = data;
            MGA_saveJSON('MGA_petPresets', data);
            if (UnifiedState.activeTab === 'pets') {
              // Use targeted update to prevent UI interruption
              const context = document.getElementById('mga-tab-content');
              if (context) {
                updatePetPresetDropdown(context);
                refreshSeparateWindowPopouts('pets');
              }
            }
            productionLog('‚úÖ Pet presets imported successfully');
          } catch (e) {
            console.error('‚ùå Failed to import pet presets:', e);
          }
        },

        allData: jsonString => {
          try {
            const data = JSON.parse(jsonString);
            if (data.petPresets) {
              UnifiedState.data.petPresets = data.petPresets;
              MGA_saveJSON('MGA_petPresets', data.petPresets);
            }
            if (data.petAbilityLogs) {
              UnifiedState.data.petAbilityLogs = data.petAbilityLogs;
              MGA_saveJSON('MGA_petAbilityLogs', data.petAbilityLogs);
            }
            if (data.settings) {
              if (data.settings.seedsToDelete) {
                UnifiedState.data.seedsToDelete = data.settings.seedsToDelete;
              }
              if (typeof data.settings.autoDeleteEnabled === 'boolean') {
                UnifiedState.data.autoDeleteEnabled = data.settings.autoDeleteEnabled;
              }
            }
            updateTabContent();
            productionLog('‚úÖ All data imported successfully');
          } catch (e) {
            console.error('‚ùå Failed to import data:', e);
          }
        }
      },

      // Clear functions
      clear: {
        petPresets: () => {
          if (confirm('Clear all pet presets?')) {
            UnifiedState.data.petPresets = {};
            MGA_saveJSON('MGA_petPresets', {});
            if (UnifiedState.activeTab === 'pets') {
              // Use targeted update to prevent UI interruption
              const context = document.getElementById('mga-tab-content');
              if (context) {
                updatePetPresetDropdown(context);
                refreshSeparateWindowPopouts('pets');
              }
            }
          }
        },

        abilityLogs: () => {
          if (confirm('Clear all ability logs?')) {
            UnifiedState.data.petAbilityLogs = [];
            MGA_saveJSON('MGA_petAbilityLogs', []);
            if (UnifiedState.activeTab === 'abilities') updateTabContent();

            // Also update ability overlays
            UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === 'abilities') {
                if (overlay.className.includes('mga-overlay-content-only')) {
                  // NEW: Pure content overlays - refresh entire overlay
                  updatePureOverlayContent(overlay, tabName);
                  debugLog('OVERLAY_LIFECYCLE', 'Updated pure abilities overlay after clearing logs');
                } else {
                  // LEGACY: Old overlay structure
                  const overlayContent = overlay.querySelector('.mga-overlay-content > div');
                  if (overlayContent) {
                    overlayContent.innerHTML = getAbilitiesTabContent();
                    setTimeout(() => updateAbilityLogDisplay(overlay), 10);
                    // Re-add resize handle after content update
                    setTimeout(() => {
                      if (!overlay.querySelector('.mga-resize-handle')) {
                        addResizeHandleToOverlay(overlay);
                        productionLog('üîß [RESIZE] Re-added missing resize handle to ability logs overlay');
                      }
                    }, 50);
                  }
                }
              }
            });
          }
        },

        allData: () => {
          if (confirm('Clear ALL saved data? This cannot be undone!')) {
            UnifiedState.data.petPresets = {};
            UnifiedState.data.petAbilityLogs = [];
            UnifiedState.data.seedsToDelete = [];
            UnifiedState.data.autoDeleteEnabled = false;
            MGA_saveJSON('MGA_petPresets', {});
            MGA_saveJSON('MGA_petAbilityLogs', []);
            updateTabContent();
          }
        }
      },

      // Debug controls for development and testing
      debugControls: {
        forceInit: () => {
          productionLog('üîÑ [DEBUG] Force re-initialization requested');
          window._MGA_FORCE_INIT = true;
          location.reload();
        },

        resetFlags: () => {
          productionLog('üîÑ [DEBUG] Resetting initialization flags');
          window._MGA_INITIALIZED = false;
          try {
            delete window._MGA_INITIALIZING;
          } catch (e) {
            window._MGA_INITIALIZING = false;
          }
          window._MGA_FORCE_INIT = false;
          productionLog('‚úÖ [DEBUG] Flags reset - you can now re-run the script');
        },

        checkPets: () => {
          productionLog('üêæ [DEBUG] Current pet state:');
          productionLog('‚Ä¢ UnifiedState.atoms.activePets:', UnifiedState.atoms.activePets);
          productionLog('‚Ä¢ window.activePets:', window.activePets);
          productionLog('‚Ä¢ Room state pets:', getActivePetsFromRoomState());
          return {
            unifiedState: UnifiedState.atoms.activePets,
            windowPets: window.activePets,
            roomState: getActivePetsFromRoomState()
          };
        },

        refreshPets: () => {
          productionLog('üîÑ [DEBUG] Manually refreshing pets from room state');
          const pets = updateActivePetsFromRoomState();
          productionLog('‚úÖ [DEBUG] Pets refreshed:', pets);
          return pets;
        },

        listIntervals: () => {
          productionLog('‚è∞ [DEBUG] Active managed intervals:');
          Object.entries(UnifiedState.intervals).forEach(([name, interval]) => {
            productionLog(`‚Ä¢ ${name}: ${interval ? 'Running' : 'Stopped'}`);
          });
          return UnifiedState.intervals;
        }
      }
    };

    // ==================== LOADING STATE UTILITIES ====================
    window.MGA_LoadingStates = {
      show: (element, text = 'Loading...') => {
        if (!element) return;
        const loadingHtml = `
                  <div class="mga-loading">
                      <div class="mga-loading-spinner"></div>
                      <span>${text}</span>
                  </div>
              `;
        element.innerHTML = loadingHtml;
      },

      showSkeleton: (element, lines = 3) => {
        if (!element) return;
        const skeletonLines = Array(lines)
          .fill(0)
          .map(
            () =>
              `<div class="mga-skeleton" style="height: 20px; margin-bottom: 8px; width: ${Math.floor(Math.random() * 40 + 60)}%;"></div>`
          )
          .join('');
        element.innerHTML = `<div style="padding: 20px;">${skeletonLines}</div>`;
      },

      hide: (element, content, fadeIn = true) => {
        if (!element) return;
        element.innerHTML = content;
        if (fadeIn) {
          element.classList.add('mga-fade-in');
          setTimeout(() => element.classList.remove('mga-fade-in'), 300);
        }
      },

      addToButton: (button, originalText) => {
        if (!button) return;
        button.disabled = true;
        button.innerHTML = `<div class="mga-loading-spinner" style="margin-right: 4px; width: 16px; height: 16px;"></div>Loading...`;
      },

      removeFromButton: (button, originalText) => {
        if (!button) return;
        button.disabled = false;
        button.innerHTML = originalText;
      }
    };

    // ==================== ERROR RECOVERY MECHANISMS ====================
    window.MGA_ErrorRecovery = {
      wrapFunction: (fn, fallback = null, context = 'Unknown') => {
        return function (...args) {
          try {
            return fn.apply(this, args);
          } catch (error) {
            debugError('ERROR_RECOVERY', `Error in ${context}`, error);

            // Show user-friendly error message
            const errorToast = targetDocument.createElement('div');
            errorToast.style.cssText = `
                          position: fixed; top: 20px; right: 20px; z-index: 20000;
                          background: rgba(220, 38, 38, 0.95); color: white;
                          padding: 12px 20px; border-radius: 8px;
                          font-family: Arial, sans-serif; font-size: 13px;
                          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                          animation: mga-fade-in 0.3s ease-out;
                      `;
            errorToast.innerHTML = `‚ö†Ô∏è Something went wrong in ${context}. Please try again.`;
            targetDocument.body.appendChild(errorToast);

            setTimeout(() => {
              errorToast.style.animation = 'mga-fade-out 0.3s ease-in forwards';
              setTimeout(() => targetDocument.body.removeChild(errorToast), 300);
            }, 4000);

            return fallback ? fallback.apply(this, args) : null;
          }
        };
      },

      safeAsync: async (asyncFn, fallback = null, context = 'Async Operation') => {
        try {
          return await asyncFn();
        } catch (error) {
          debugError('ERROR_RECOVERY', `Async error in ${context}`, error);
          return fallback;
        }
      },

      retryOperation: async (operation, maxRetries = 3, delay = 1000, context = 'Operation') => {
        for (let i = 0; i < maxRetries; i++) {
          try {
            return await operation();
          } catch (error) {
            if (i === maxRetries - 1) {
              debugError('ERROR_RECOVERY', `Final retry failed for ${context}`, error);
              throw error;
            }
            debugLog('ERROR_RECOVERY', `Retry ${i + 1}/${maxRetries} for ${context}`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
    };

    // ==================== PERFORMANCE OPTIMIZATIONS ====================
    window.MGA_Performance = {
      debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      },

      throttle: (func, limit) => {
        let inThrottle;
        return function () {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      },

      batchDOMUpdates: updates => {
        requestAnimationFrame(() => {
          const fragment = document.createDocumentFragment();
          updates.forEach(update => {
            if (typeof update === 'function') {
              update(fragment);
            }
          });
        });
      },

      optimizeScrolling: element => {
        if (!element) return;
        element.style.willChange = 'scroll-position';
        element.style.transform = 'translateZ(0)';
      }
    };

    // ==================== COMPREHENSIVE TOOLTIP SYSTEM ====================
    window.MGA_Tooltips = {
      tooltip: null,
      showTimeout: null,
      hideTimeout: null,
      currentEvent: null, // Store current mouse event for positioning

      init: () => {
        // Create tooltip element
        if (!window.MGA_Tooltips.tooltip) {
          window.MGA_Tooltips.tooltip = targetDocument.createElement('div');
          window.MGA_Tooltips.tooltip.className = 'mga-tooltip';
          targetDocument.body.appendChild(window.MGA_Tooltips.tooltip);
        }

        // Add event listeners to all elements with tooltip data
        document.addEventListener('mouseenter', window.MGA_Tooltips.handleMouseEnter, true);
        document.addEventListener('mouseleave', window.MGA_Tooltips.handleMouseLeave, true);
        document.addEventListener('mousemove', window.MGA_Tooltips.handleMouseMove, true);
      },

      handleMouseEnter: e => {
        const element = e.target?.closest?.('[data-tooltip]');
        if (!element) return;

        // Don't interfere with button interactions - check if target is a button or interactive element
        if (
          e.target &&
          typeof e.target.matches === 'function' &&
          (e.target.matches('button, input, select, .mga-btn') || e.target.closest('button, .mga-btn'))
        ) {
          return; // Skip tooltip for interactive elements to prevent hover interference
        }

        const text = element.dataset.tooltip;
        const delay = element.dataset.tooltipDelay || 500;

        // Store the event for positioning
        window.MGA_Tooltips.currentEvent = e;

        window.MGA_Tooltips.showTimeout = setTimeout(() => {
          window.MGA_Tooltips.show(element, text);
        }, parseInt(delay));
      },

      handleMouseLeave: e => {
        const element = e.target?.closest?.('[data-tooltip]');
        if (!element) return;

        clearTimeout(window.MGA_Tooltips.showTimeout);
        window.MGA_Tooltips.hide();
      },

      handleMouseMove: e => {
        // CRITICAL: Only handle MGA-related tooltip events
        if (!isMGAEvent(e)) {
          return;
        }

        // Don't interfere with button hover states
        if (
          e.target &&
          typeof e.target.matches === 'function' &&
          (e.target.matches('button, input, select, .mga-btn') || e.target.closest('button, .mga-btn'))
        ) {
          return;
        }

        // Update current event for positioning
        window.MGA_Tooltips.currentEvent = e;

        if (window.MGA_Tooltips.tooltip && window.MGA_Tooltips.tooltip.classList.contains('show')) {
          // Check if we're still over a tooltip element
          const tooltipElement = e.target?.closest?.('[data-tooltip]');
          if (!tooltipElement) {
            window.MGA_Tooltips.hide();
            return;
          }
          window.MGA_Tooltips.position(e);
        }
      },

      show: (element, text) => {
        const tooltip = window.MGA_Tooltips.tooltip;
        tooltip.textContent = text;

        // BUGFIX: Position immediately before showing to prevent flash at (0,0)
        if (window.MGA_Tooltips.currentEvent) {
          window.MGA_Tooltips.position(window.MGA_Tooltips.currentEvent);
        }

        tooltip.classList.add('show');
      },

      hide: () => {
        const tooltip = window.MGA_Tooltips.tooltip;
        tooltip.classList.remove('show');

        // BUGFIX: Reset position to prevent stuck tooltips
        tooltip.style.left = '-9999px';
        tooltip.style.top = '-9999px';
        window.MGA_Tooltips.currentEvent = null;
      },

      position: e => {
        const tooltip = window.MGA_Tooltips.tooltip;
        const rect = tooltip.getBoundingClientRect();
        const padding = 10;

        let x = e.clientX + padding;
        let y = e.clientY - rect.height - padding;

        // Adjust if tooltip goes off screen
        if (x + rect.width > window.innerWidth) {
          x = e.clientX - rect.width - padding;
        }
        if (y < 0) {
          y = e.clientY + padding;
        }

        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
      },

      addToElement: (element, text, options = {}) => {
        if (!element) return;
        element.setAttribute('data-tooltip', text);
        if (options.delay) element.setAttribute('data-tooltip-delay', options.delay);
      },

      removeFromElement: element => {
        if (!element) return;
        element.removeAttribute('data-tooltip');
        element.removeAttribute('data-tooltip-delay');
      }
    };

    // Add fade-out animation for error toasts and slot value centering
    const additionalStyles = `
    @keyframes mga-fade-out {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-10px); }
    }

    /* Ensure our estimate/slot-value paragraphs behave as full-width, centered lines
       so they appear centered inside the game's tooltip textbox regardless of container quirks. */
    [data-turtletimer-estimate="true"] {
      display: block !important;
      width: 100% !important;
      box-sizing: border-box !important;
      text-align: center !important;       /* centers text inside the tooltip textbox */
      margin: 2px 0 !important;
      padding: 0 !important;
      color: lime !important;
      font-weight: bold !important;
      font-size: 14px !important;
      line-height: 1.25 !important;
    }

    [data-turtletimer-slot-value="true"] {
      display: block !important;
      width: 100% !important;
      box-sizing: border-box !important;
      text-align: center !important;       /* centers text inside the tooltip textbox */
      margin: 2px 0 !important;
      padding: 0 !important;
      color: #FFD700 !important;
      font-weight: 600 !important;
      font-size: 13px !important;
      line-height: 1.25 !important;
    }
  `;
    const styleSheet = targetDocument.createElement('style');
    styleSheet.textContent = additionalStyles;
    targetDocument.head.appendChild(styleSheet);

    // ==================== AUTO-SAVE ====================
    // Auto-save data every 30 seconds using managed interval
    setManagedInterval(
      'autoSave',
      () => {
        MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
        // Only save ability logs if not in clear session
        const clearSession = localStorage.getItem('MGA_logs_clear_session');
        if (!clearSession || Date.now() - parseInt(clearSession, 10) > 86400000) {
          MGA_saveJSON('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
        }
        MGA_saveJSON('MGA_seedsToDelete', UnifiedState.data.seedsToDelete);
        MGA_saveJSON('MGA_autoDeleteEnabled', UnifiedState.data.autoDeleteEnabled);

        // Update resource tracking
        if (window.resourceDashboard) {
          window.resourceDashboard.updateResourceHistory();
        }
      },
      30000
    );

    // ==================== CLEANUP ====================
    window.addEventListener('beforeunload', () => {
      // Save all data before leaving - CRITICAL: Use immediate saves, not debounced!
      MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
      // Only save ability logs if not in clear session
      const clearSession = localStorage.getItem('MGA_logs_clear_session');
      if (!clearSession || Date.now() - parseInt(clearSession, 10) > 86400000) {
        MGA_saveJSON('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
      }
      MGA_saveJSON('MGA_seedsToDelete', UnifiedState.data.seedsToDelete);
      MGA_saveJSON('MGA_autoDeleteEnabled', UnifiedState.data.autoDeleteEnabled);

      // Clean up all managed intervals
      clearAllManagedIntervals();

      // Close all popout windows
      closeAllPopoutWindows();

      debugLog('PERFORMANCE', 'Cleanup completed on window unload');
    });

    // ==================== VERSION INFO ====================
    productionLog(
      '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n' +
        '‚ïë   üå± Magic Garden Unified Assistant    ‚ïë\n' +
        '‚ïë            Version 1.3.2               ‚ïë\n' +
        '‚ïë                                        ‚ïë\n' +
        '‚ïë  üéÆ Works in ANY browser console!     ‚ïë\n' +
        '‚ïë  ‚Ä¢ Game Mode: Full integration        ‚ïë\n' +
        '‚ïë  ‚Ä¢ Demo Mode: Standalone with samples ‚ïë\n' +
        '‚ïë                                        ‚ïë\n' +
        '‚ïë  Features:                             ‚ïë\n' +
        '‚ïë  ‚Ä¢ Pet Loadout Management             ‚ïë\n' +
        '‚ïë  ‚Ä¢ Ability Log Tracking               ‚ïë\n' +
        '‚ïë  ‚Ä¢ Seed Deletion & Auto-Delete        ‚ïë\n' +
        '‚ïë  ‚Ä¢ Value Calculations                 ‚ïë\n' +
        '‚ïë  ‚Ä¢ Restock & Event Timers            ‚ïë\n' +
        '‚ïë  ‚Ä¢ Theme Customization                ‚ïë\n' +
        '‚ïë  ‚Ä¢ Pop-out Windows                    ‚ïë\n' +
        '‚ïë                                        ‚ïë\n' +
        '‚ïë  Controls:                            ‚ïë\n' +
        '‚ïë  ‚Ä¢ window.MGA - Full API              ‚ïë\n' +
        '‚ïë  ‚Ä¢ MGA.showPanel() - Show UI          ‚ïë\n' +
        '‚ïë  ‚Ä¢ MGA.init() - Manual start          ‚ïë\n' +
        '‚ïë  ‚Ä¢ Alt+M - Toggle apanel               ‚ïë\n' +
        '‚ïë                                        ‚ïë\n' +
        '‚ïë  Debugging (if issues occur):         ‚ïë\n' +
        '‚ïë  ‚Ä¢ MGA.debug.debugStorage() - Storage ‚ïë\n' +
        '‚ïë  ‚Ä¢ MGA_debugStorage() - Same as above ‚ïë\n' +
        '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'
    );

    // ==================== IMMEDIATE INITIALIZATION TEST ====================
    // Final safety initialization for testing - removed to prevent demo mode interference
    // Demo mode is only triggered by the 8-second fallback if game mode completely fails
    productionLog('üß™ Skipping 2-second fallback to prevent demo mode interference');

    // Final checkpoint - script execution complete
    /* CHECKPOINT removed: SCRIPT_EXECUTION_COMPLETE */
    productionLog('‚úÖ Magic Garden Assistant script finished loading');
  }
})();

/* ==== MGTP Overlay + Ability Logs Proxy + Rooms /info + WS Watcher (2025-10-07) ==== */
(function () {
  'use strict';
  const d = document;

  // ---------- Slot/Estimate Overlay ----------
  const rootHost = d.createElement('div');
  rootHost.id = 'mgtp-overlay-root';
  rootHost.style.cssText = 'position:fixed;left:0;top:0;width:0;height:0;z-index:2147483646;pointer-events:none;';
  const shadow = rootHost.attachShadow({ mode: 'open' });
  const style = d.createElement('style');
  style.textContent = `
      .wrap{position:absolute;transform:translate(-50%,-100%); background:transparent; pointer-events:none; font-family: system-ui, sans-serif;}
      .line{display:block; white-space:nowrap; text-shadow:0 1px 1px rgba(0,0,0,.6); font-weight:700; text-align:center;}
      .estimate{font-size:13px; color:#70ff70;}
      .slot{font-size:14px; color:#ffd24d;}
      .hidden{display:none;}
    `;
  const wrap = d.createElement('div');
  wrap.className = 'wrap hidden';
  const est = d.createElement('div');
  est.className = 'line estimate';
  const slot = d.createElement('div');
  slot.className = 'line slot';
  wrap.appendChild(est);
  wrap.appendChild(slot);
  shadow.appendChild(style);
  shadow.appendChild(wrap);
  d.documentElement.appendChild(rootHost);

  function placeAtRect(rect) {
    wrap.style.left = rect.left + rect.width / 2 + 'px';
    wrap.style.top = rect.top + 2 + 'px';
  }
  function visible(v) {
    wrap.classList.toggle('hidden', !v);
  }

  function bestAnchorFrom(el) {
    try {
      if (el && el.getBoundingClientRect) return el.getBoundingClientRect();
    } catch {}
    // fallback: any visible tooltip-like container
    const cand = d.querySelectorAll(
      '[role="tooltip"], [data-popper-placement], .chakra-tooltip, .chakra-tooltip__popper'
    );
    let best = null,
      bestArea = -1;
    cand.forEach(e => {
      const r = e.getBoundingClientRect();
      if (r.width > 0 && r.height > 0) {
        // avoid pet panel/sidebar
        if (e.closest('[data-panel="pet-stats"], .pet-panel, [data-sidebar]')) return;
        const area = r.width * r.height;
        if (area > bestArea) {
          bestArea = area;
          best = r;
        }
      }
    });
    if (best) return best;
    // viewport fallback
    return { left: innerWidth / 2 - 1, top: innerHeight / 2 - 1, width: 2, height: 2 };
  }

  window.MGTP_slotOverlay = {
    update({ estimateText, slotValueText, anchorElement } = {}) {
      const hasEst = !!(estimateText && String(estimateText).trim());
      const hasSlot = !!(slotValueText && String(slotValueText).trim());
      est.textContent = hasEst ? String(estimateText) : '';
      slot.textContent = hasSlot ? String(slotValueText) : '';
      if (!hasEst && !hasSlot) {
        visible(false);
        return;
      }
      const r = bestAnchorFrom(anchorElement);
      placeAtRect(r);
      visible(true);
    },
    hide() {
      visible(false);
    }
  };

  // ---------- Ability Logs: Sticky Clear + Proxy dedupe ----------
  const CLEAR_FLAG = 'MGA_logs_manually_cleared';
  const SESSION_FLAG = 'MGA_logs_clear_session';
  function clearFlagIfNeededOnAdd() {
    // BUGFIX v3.7.8: Clear BOTH flags when new logs are added
    if (localStorage.getItem(CLEAR_FLAG) === 'true') {
      try {
        localStorage.removeItem(CLEAR_FLAG);
      } catch {}
    }
    if (localStorage.getItem(SESSION_FLAG)) {
      try {
        localStorage.removeItem(SESSION_FLAG);
      } catch {}
    }
  }
  function wrapLogsArray(arr) {
    let arrLocal = arr;
    if (!Array.isArray(arrLocal)) arrLocal = [];
    const seen = new Set();
    const fp = l => {
      const t = (l && l.abilityType) || '',
        p = (l && l.petName) || '';
      const ts = String((l && l.timestamp) || 0);
      let h = 2166136261 >>> 0,
        s = t + '|' + p + '|' + ts;
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0).toString(36);
    };
    const dedupePush = item => {
      const id = item.id || fp(item);
      if (seen.has(id)) return 0;
      seen.add(id);
      arrLocal.push({ ...item, id });
      return 1;
    };
    // seed seen
    for (const it of arrLocal) {
      seen.add(it.id || fp(it));
    }
    return new Proxy(arrLocal, {
      get(target, prop, recv) {
        if (['push', 'unshift', 'splice', 'concat'].includes(prop)) {
          return function (...args) {
            let added = 0;
            if (prop === 'push' || prop === 'unshift') {
              for (const it of args) {
                added += dedupePush(it);
              }
              if (added > 0) clearFlagIfNeededOnAdd();
              return target.length;
            }
            if (prop === 'splice') {
              // if items provided after start/deleteCount, dedupe them
              if (args.length > 2) {
                const start = args[0] >>> 0,
                  del = args[1] >>> 0,
                  newItems = args.slice(2);
                const before = target.slice(0, start);
                const after = target.slice(start + del);
                const rebuilt = wrapLogsArray(before);
                for (const it of newItems) {
                  dedupePush.call({ arr: rebuilt }, it);
                }
                for (const it of after) {
                  dedupePush.call({ arr: rebuilt }, it);
                }
                while (target.length) target.pop();
                for (const it of rebuilt) target.push(it);
                clearFlagIfNeededOnAdd();
                return [];
              }
            }
            return Array.prototype[prop].apply(target, args);
          };
        }
        return Reflect.get(target, prop, recv);
      },
      set(target, key, val) {
        // direct index sets count as add
        if (!isNaN(key)) {
          const added = dedupePush(val);
          if (added > 0) clearFlagIfNeededOnAdd();
          return true;
        }
        return Reflect.set(target, key, val);
      }
    });
  }

  // Install proxy once UnifiedState is ready
  (function waitUnified() {
    const us = window.UnifiedState && UnifiedState.data;
    if (us) {
      if (!us.petAbilityLogs || !us.petAbilityLogs.__proxied) {
        us.petAbilityLogs = wrapLogsArray(us.petAbilityLogs || []);
        Object.defineProperty(us.petAbilityLogs, '__proxied', { value: true });
      }
      // Intercept clear button globally to ensure sticky clear + full purge
      d.addEventListener(
        'click',
        function (e) {
          const tgt = e.target;
          if (tgt && tgt.id === 'clear-ability-logs') {
            e.preventDefault();
            e.stopImmediatePropagation();
            try {
              us.petAbilityLogs.length = 0;
              if (typeof GM_setValue !== 'undefined') {
                GM_setValue('MGA_petAbilityLogs', JSON.stringify([]));
              }
              localStorage.setItem('MGA_petAbilityLogs', JSON.stringify([]));
              localStorage.setItem(CLEAR_FLAG, 'true'); // keep sticky until next new log
              const archKeys = ['MGA_petAbilityLogs_archive'];
              archKeys.forEach(k => {
                try {
                  if (typeof GM_setValue !== 'undefined') GM_setValue(k, JSON.stringify([]));
                } catch {}
                try {
                  localStorage.removeItem(k);
                } catch {}
              });
              if (window.updateAbilityLogDisplay) {
                try {
                  window.updateAbilityLogDisplay(document);
                } catch {}
              }
            } catch (err) {
              console.error('[MGTP] clear logs failed', err);
            }
          }
        },
        true
      );
      return;
    }
    setTimeout(waitUnified, 200);
  })();

  function rerenderRoomsUI() {
    try {
      // BUGFIX: Use getRoomStatusTabContent directly (not window.getRoomStatusTabContent) - same scope
      if (typeof getRoomStatusTabContent !== 'function') {
        return;
      }

      // Find any active rooms tab content areas (main or overlays)
      const candidates = document.querySelectorAll('[data-tab="rooms"], .mga-tab-content, .mga-overlay-content');
      let updated = false;

      candidates.forEach((c, idx) => {
        // Check if this element contains or is a rooms UI
        const list = c.querySelector('#room-status-list');
        const isRoomsTab = c.getAttribute && c.getAttribute('data-tab') === 'rooms';

        if (list || isRoomsTab) {
          const html = getRoomStatusTabContent();
          c.innerHTML = html;
          if (typeof setupRoomJoinButtons === 'function') {
            setupRoomJoinButtons();
            setupRoomsTabButtons();
          }
          updated = true;
        }
      });
    } catch (e) {
      if (typeof logDebug === 'function') {
        logDebug('ROOMS-UI', '‚ùå Render error:', e);
      }
    }
  }

  // ---------- Rooms via /api/rooms/{code}/info with Fallbacks ----------
  (function roomsInfo() {
    // CRITICAL: Detect correct window scope (Tampermonkey uses unsafeWindow)
    // This IIFE is in separate scope from main script, so we need to detect which window has our data
    const isUserscript = typeof unsafeWindow !== 'undefined';
    const correctWindow = isUserscript ? unsafeWindow : window;

    // Get correct API base URL (handles Discord browser context)
    const globalScope = correctWindow;
    const getApiBase = globalScope.getGameApiBaseUrl || (() => location.origin);
    const apiBase = getApiBase();
    const API_V1 = name => `${apiBase}/api/rooms/${encodeURIComponent(name)}/info`;
    const TRACKED = correctWindow.UnifiedState?.data?.customRooms ||
      correctWindow.TRACKED_ROOMS || ['MG1', 'MG2', 'MG3', 'MG4', 'MG5', 'MG6', 'MG7', 'MG8', 'MG9', 'MG10', 'SLAY'];
    let extra = new Set();
    const counts = {};

    // Build reverse lookup: Discord room ID -> display name
    // This allows us to store counts by name (e.g., 'PLAY1') instead of by ID
    const roomIdToName = {};

    // Parse player count from various API response formats
    function parsePlayerCount(data) {
      if (!data) return 0;

      // Try multiple field names
      const count =
        data?.numPlayers ??
        data?.players?.online ??
        data?.players?.count ??
        data?.online ??
        data?.count ??
        data?.playerCount ??
        0;

      return Math.max(0, Number(count) || 0);
    }

    // Fetch using standard fetch API
    async function fetchWithFetch(url, name) {
      const r = await fetch(url, {
        method: 'GET',
        credentials: 'include',
        headers: { Accept: 'application/json' },
        signal: AbortSignal.timeout(10000)
      });

      if (!r.ok) {
        throw new Error(`HTTP ${r.status}`);
      }

      const data = await r.json();
      return data;
    }

    // Fallback: Fetch using GM_xmlhttpRequest (bypasses CORS)
    async function fetchWithGM(url, name) {
      return new Promise((resolve, reject) => {
        if (typeof GM_xmlhttpRequest !== 'function') {
          reject(new Error('GM_xmlhttpRequest not available'));
          return;
        }

        GM_xmlhttpRequest({
          method: 'GET',
          url: url,
          headers: { Accept: 'application/json' },
          timeout: 10000,
          onload: response => {
            if (response.status >= 200 && response.status < 300) {
              try {
                const data = JSON.parse(response.responseText);
                resolve(data);
              } catch (e) {
                reject(new Error(`Parse error: ${e.message}`));
              }
            } else {
              reject(new Error(`HTTP ${response.status}`));
            }
          },
          onerror: error => reject(new Error('Network error')),
          ontimeout: () => reject(new Error('Timeout'))
        });
      });
    }

    async function fetchOne(roomIdOrName) {
      const roomDebugMode = correctWindow.UnifiedState?.data?.settings?.roomDebugMode;
      const isDiscordRoom = roomIdOrName.includes('i-') && roomIdOrName.includes('-gc-');

      try {
        let data = null;

        // Try /api/rooms/{code}/info endpoint (works for both simple codes and Discord IDs)
        try {
          const url1 = API_V1(roomIdOrName);
          data = await fetchWithFetch(url1, roomIdOrName);
          if (roomDebugMode) {
            console.log(`[ROOMS] ‚úÖ Fetch succeeded for ${roomIdOrName}:`, data);
          }
        } catch (e1) {
          // Try GM_xmlhttpRequest fallback if fetch fails
          try {
            const url1 = API_V1(roomIdOrName);
            if (roomDebugMode) {
              console.log(`[ROOMS] üîÑ Retrying ${roomIdOrName} with GM_xmlhttpRequest`);
            }
            data = await fetchWithGM(url1, roomIdOrName);
            if (roomDebugMode) {
              console.log(`[ROOMS] ‚úÖ GM fetch succeeded for ${roomIdOrName}:`, data);
            }
          } catch (e2) {
            // Log error if Room Debug Mode is enabled
            if (roomDebugMode) {
              console.warn(`[ROOMS] ‚ùå Failed to fetch ${roomIdOrName}:`, e1.message);
            }
            throw new Error(`All methods failed for ${roomIdOrName}`);
          }
        }

        // Parse the count from whichever API succeeded
        const online = parsePlayerCount(data);

        // CRITICAL: For Discord rooms, store by DISPLAY NAME, not ID
        // This allows UI to find counts by looking up 'PLAY1' instead of long ID
        let storageKey;
        if (isDiscordRoom && roomIdToName[roomIdOrName]) {
          storageKey = roomIdToName[roomIdOrName].toUpperCase();
          if (roomDebugMode && online > 0) {
            console.log(`[ROOMS] üìä Discord room ${roomIdToName[roomIdOrName]}: ${online} players`);
          }
        } else {
          storageKey = roomIdOrName.toUpperCase();
          if (roomDebugMode && online > 0) {
            console.log(`[ROOMS] üìä ${roomIdOrName}: ${online} players`);
          }
        }

        counts[storageKey] = online;
      } catch (e) {
        // Store failure as 0, using same key logic
        let storageKey;
        if (isDiscordRoom && roomIdToName[roomIdOrName]) {
          storageKey = roomIdToName[roomIdOrName].toUpperCase();
        } else {
          storageKey = roomIdOrName.toUpperCase();
        }
        counts[storageKey] = 0;

        // Log failures only in debug mode
        if (roomDebugMode) {
          console.warn(
            `[ROOMS] ‚ö†Ô∏è ${isDiscordRoom ? 'Discord room' : 'Room'} ${roomIdOrName.substring(0, 30)}... failed:`,
            e.message
          );
        }
      }
    }

    // Track last poll time when UI was hidden (for reduced frequency)
    let lastTickWhenHidden = 0;

    // Cache room UI visibility check
    let cachedRoomsUIVisible = null;
    let lastUICheckTime = 0;

    async function tick() {
      const roomDebugMode = correctWindow.UnifiedState?.data?.settings?.roomDebugMode;

      // SMART POLLING: Reduce frequency when Rooms UI is closed (not skip entirely)
      // Cache the UI check - only re-query every 5 seconds
      const now = Date.now();
      if (!cachedRoomsUIVisible || now - lastUICheckTime > 5000) {
        cachedRoomsUIVisible =
          document.querySelector('.mga-sidebar[data-visible="true"] [data-tab="rooms"]') ||
          document.querySelector('#room-status-list') ||
          document.querySelector('[data-mga-popout="rooms"]');
        lastUICheckTime = now;
      }
      const roomsUIVisible = cachedRoomsUIVisible;

      // If UI not visible, only poll every 30 seconds instead of every 5 seconds
      if (!roomsUIVisible) {
        const now = Date.now();
        // Skip this tick if we polled less than 30 seconds ago while hidden
        if (lastTickWhenHidden > 0 && now - lastTickWhenHidden < 30000) {
          if (roomDebugMode) {
            const secondsSinceLastPoll = Math.floor((now - lastTickWhenHidden) / 1000);
            console.log(`[ROOMS] ‚è∏Ô∏è Skipping tick - UI hidden (last poll ${secondsSinceLastPoll}s ago)`);
          }
          return;
        }
        lastTickWhenHidden = now;
        if (roomDebugMode) {
          console.log('[ROOMS] üîÑ Polling while UI hidden (30s interval)');
        }
      } else {
        // Reset hidden timer when UI is visible
        lastTickWhenHidden = 0;
      }

      // Include Discord rooms from RoomRegistry for play1-play50 and country rooms
      const discordRoomIds =
        typeof correctWindow.RoomRegistry !== 'undefined' && correctWindow.RoomRegistry?.discord
          ? correctWindow.RoomRegistry.discord.map(r => r.id)
          : [];

      // CRITICAL: Build roomId -> name lookup for Discord rooms
      // This allows us to store counts by display name (e.g., 'PLAY1') instead of long ID
      if (correctWindow.RoomRegistry?.discord && Object.keys(roomIdToName).length === 0) {
        correctWindow.RoomRegistry.discord.forEach(room => {
          roomIdToName[room.id] = room.name;
        });
        if (roomDebugMode) {
          console.log('[ROOMS] üó∫Ô∏è Built Discord room lookup map:', Object.keys(roomIdToName).length, 'rooms');
        }
      }

      const names = [...TRACKED, ...extra, ...discordRoomIds];

      if (roomDebugMode) {
        console.log(
          `[ROOMS] üîÑ Tick running: ${names.length} total rooms (${TRACKED.length} MG/Custom, ${discordRoomIds.length} Discord)`
        );
      }

      // PERFORMANCE OPTIMIZATION: Batch room requests to avoid network spam
      // Process 10 rooms at a time with 200ms delay between batches
      try {
        const BATCH_SIZE = 10;
        const BATCH_DELAY = 200; // ms between batches

        for (let i = 0; i < names.length; i += BATCH_SIZE) {
          const batch = names.slice(i, i + BATCH_SIZE);
          await Promise.all(batch.map(fetchOne));

          // Add delay between batches (except for last batch)
          if (i + BATCH_SIZE < names.length) {
            await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
          }
        }

        // Show sample of Discord room counts if debug mode enabled
        if (roomDebugMode) {
          const discordKeys = Object.keys(counts).filter(k => k.startsWith('PLAY'));
          if (discordKeys.length > 0) {
            console.log(
              '[ROOMS] üìù Sample Discord room counts:',
              discordKeys
                .slice(0, 5)
                .map(k => `${k}:${counts[k]}`)
                .join(', ')
            );
          }
        }
      } catch (e) {
        console.error('[ROOMS] ‚ùå Tick error:', e);
      }

      // write into UnifiedState so UI updates
      if (typeof correctWindow.UnifiedState !== 'undefined' && correctWindow.UnifiedState?.data) {
        correctWindow.UnifiedState.data.roomStatus = correctWindow.UnifiedState.data.roomStatus || {};
        // CRITICAL: Directly replace counts to ensure fresh data
        correctWindow.UnifiedState.data.roomStatus.counts = { ...counts };

        // ADDED: Persist to storage
        MGA_saveJSON('MGA_roomStatus', correctWindow.UnifiedState.data.roomStatus);

        if (roomDebugMode) {
          console.log(`[ROOMS] ‚úÖ Updated ${Object.keys(counts).length} room counts in UnifiedState`);
        }

        // refresh any open rooms views
        if (typeof window.refreshSeparateWindowPopouts === 'function') {
          try {
            window.refreshSeparateWindowPopouts('rooms');
          } catch {}
        }
        try {
          rerenderRoomsUI();
          // Force update room counts in any visible room UI
          document.querySelectorAll('.mga-tab-item[data-tab="rooms"]').forEach(tab => tab.click());
        } catch {}
        // Inline rooms lists
        const list = document.getElementById('room-status-list');
        if (list) {
          // trigger the existing re-render path if available
          if (typeof window.updateRoomStatusUI === 'function') {
            window.updateRoomStatusUI();
          } else {
            // minimal DOM update: replace counts in .room-count els
            list.querySelectorAll('.room-row').forEach(row => {
              const code = (row.getAttribute('data-room') || '').toUpperCase();
              const span = row.querySelector('.room-count');
              if (span && code) {
                span.textContent = String(counts[code] ?? window.UnifiedState.data.roomStatus.counts[code] ?? 0);
              }
            });
          }
        }
      }
    }
    // PERFORMANCE OPTIMIZATION: Watch specific container instead of entire document
    // This reduces mutation callback frequency by 90%+
    const obs = new MutationObserver(() => {
      const inp = document.getElementById('room-search-input');
      if (inp && !inp.__mgtpBound) {
        inp.__mgtpBound = true;
        inp.addEventListener('input', () => {
          const q = (inp.value || '').trim().toUpperCase();
          extra = new Set(
            q
              ? q
                  .split(',')
                  .map(s => s.trim())
                  .filter(Boolean)
              : []
          );
        });
      }
    });

    // Watch only the sidebar container instead of entire document
    // Falls back to document if sidebar not found yet
    const observeRoomSearch = () => {
      const sidebar = document.getElementById('mgh-sidebar') || document.querySelector('.mga-sidebar');
      const targetElement = sidebar || document.documentElement;

      obs.observe(targetElement, {
        subtree: true,
        childList: true,
        // OPTIMIZATION: Only watch childList changes, ignore attributes/characterData
        attributes: false,
        characterData: false
      });

      if (!sidebar) {
        // If sidebar not ready yet, retry in 1 second
        setTimeout(() => {
          obs.disconnect();
          observeRoomSearch();
        }, 1000);
      }
    };

    observeRoomSearch();

    // Wait for UnifiedState and RoomRegistry to be ready before starting polling
    function startPollingWhenReady() {
      const hasUnifiedState = typeof correctWindow.UnifiedState !== 'undefined' && correctWindow.UnifiedState?.data;
      const hasRoomRegistry = typeof correctWindow.RoomRegistry !== 'undefined' && correctWindow.RoomRegistry?.discord;

      if (hasUnifiedState && hasRoomRegistry) {
        // PERFORMANCE OPTIMIZATION: Increased interval from 5s to 10s
        // Room counts don't change that rapidly, 10s is still responsive
        setTimeout(tick, 1000); // First tick after 1 second
        setInterval(tick, 10000); // Then every 10 seconds (was 5s)
      } else {
        setTimeout(startPollingWhenReady, 500);
      }
    }

    startPollingWhenReady();

    // Expose diagnostic function for testing
    // Usage: testDiscordRoomFetch() or testDiscordRoomFetch('room-id')
    correctWindow.testDiscordRoomFetch = async function (roomId) {
      const testId = roomId || 'i-1425232387037462538-gc-1399110335469977781-1411124424676999308';
      const url = `${apiBase}/api/rooms/${encodeURIComponent(testId)}/info`;

      console.log('[ROOMS TEST] Testing:', testId.substring(0, 40) + '...');
      console.log('[ROOMS TEST] URL:', url);

      try {
        const response = await fetch(url, {
          method: 'GET',
          credentials: 'include',
          headers: { Accept: 'application/json' }
        });

        if (!response.ok) {
          const text = await response.text();
          console.error('[ROOMS TEST] ‚ùå HTTP', response.status, '-', text);
          return;
        }

        const data = await response.json();
        console.log('[ROOMS TEST] ‚úÖ Success! Players:', data.numPlayers ?? 'NOT FOUND', '| Full data:', data);
      } catch (e) {
        console.error('[ROOMS TEST] ‚ùå Fetch failed:', e);
      }
    };
  })();

  // ==================== ENHANCED WEBSOCKET AUTO-RECONNECT SYSTEM ====================
  (function enhancedSocketReconnect() {
    const Native = window.WebSocket;
    if (!Native || Native.__mgtoolsPatched) return; // Prevent double-patching

    let attempts = 0;
    const MAX_ATTEMPTS = 6;
    let reconnectTimer = null;
    let userNotified = false;

    // Platform detection for context-aware reconnection
    const isDiscord =
      /discord|overlay|electron/i.test(navigator.userAgent) || !!(window.DiscordNative || window.__discordApp);
    const isIframe = window !== window.top;
    const isMobile = /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    // ==================== DOCUMENT.HIDDEN OVERRIDE FOR COMPAT MODE ====================
    // The game checks document.hidden and refuses to reconnect when hidden
    // In compat mode (Discord/managed devices), we override this to always return false
    if (typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.wsReconnectWhenHidden) {
      try {
        const originalDescriptor =
          Object.getOwnPropertyDescriptor(Document.prototype, 'hidden') ||
          Object.getOwnPropertyDescriptor(document, 'hidden');

        if (originalDescriptor && originalDescriptor.get) {
          Object.defineProperty(document, 'hidden', {
            get: function () {
              // Always return false in compat mode to allow reconnection
              return false;
            },
            configurable: true
          });

          logInfo('COMPAT-WS', 'Overrode document.hidden to enable reconnection in hidden state');
        }

        // Also patch visibilityState
        const originalVisibilityDescriptor =
          Object.getOwnPropertyDescriptor(Document.prototype, 'visibilityState') ||
          Object.getOwnPropertyDescriptor(document, 'visibilityState');

        if (originalVisibilityDescriptor && originalVisibilityDescriptor.get) {
          Object.defineProperty(document, 'visibilityState', {
            get: function () {
              // Always return 'visible' in compat mode
              return 'visible';
            },
            configurable: true
          });
        }
      } catch (e) {
        logWarn('COMPAT-WS', 'Failed to override document.hidden', e);
      }
    }

    // Add CSS animations
    const style = document.createElement('style');
    style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(400px); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(400px); opacity: 0; }
            }
        `;
    document.head.appendChild(style);

    // User feedback: Visual toast notification
    function showReconnectToast(attemptNum, maxAttempts, nextWait) {
      let toast = document.getElementById('mga-reconnect-toast');

      const toastHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 24px;">üîÑ</div>
                    <div>
                        <div style="font-weight: 600; margin-bottom: 4px;">Connection Lost</div>
                        <div style="font-size: 12px; opacity: 0.9;">
                            Reconnecting... (${attemptNum}/${maxAttempts})
                            <br>Next attempt in ${Math.round(nextWait / 1000)}s
                        </div>
                    </div>
                </div>
            `;

      if (!toast) {
        toast = document.createElement('div');
        toast.id = 'mga-reconnect-toast';
        toast.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                    background: linear-gradient(135deg, rgba(59, 130, 246, 0.95), rgba(37, 99, 235, 0.95));
                    color: white; padding: 16px 24px; border-radius: 12px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    font-size: 14px; font-weight: 500; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                    animation: slideInRight 0.3s ease-out; max-width: 320px; pointer-events: auto;
                `;
        document.body.appendChild(toast);
      }

      toast.innerHTML = toastHTML;
      userNotified = true;

      setTimeout(() => {
        if (toast && toast.parentNode) {
          toast.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => toast.remove(), 300);
        }
      }, 5000);
    }

    // Show max attempts failure with manual reload button
    function showFailureToast() {
      const failToast = document.createElement('div');
      failToast.id = 'mga-reconnect-fail-toast';
      failToast.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                background: linear-gradient(135deg, rgba(220, 38, 38, 0.95), rgba(185, 28, 28, 0.95));
                color: white; padding: 16px 24px; border-radius: 12px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                font-size: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); max-width: 320px;
            `;

      failToast.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">‚ö†Ô∏è Connection Failed</div>
                <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                    Unable to reconnect after ${MAX_ATTEMPTS} attempts
                </div>
                <button onclick="location.reload()" style="
                    background: white; color: #dc2626; border: none; padding: 8px 16px;
                    border-radius: 6px; cursor: pointer; font-weight: 600; width: 100%; font-size: 13px;
                ">Reload Page</button>
            `;

      document.body.appendChild(failToast);
    }

    // Schedule reconnect with exponential backoff
    function scheduleReload(code, wasClean, reason) {
      // Handle version expired (4710) immediately - auto-refresh with notification
      if (code === 4710 || /version.?expired/i.test(reason || '')) {
        if (typeof productionLog === 'function') {
          productionLog('[WebSocket] Version expired detected (code 4710) - auto-refreshing in 5 seconds');
        }

        // Show friendly update notification with countdown
        let countdown = 5;
        const updateToast = document.createElement('div');
        updateToast.id = 'mga-update-toast';
        updateToast.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
                    color: white; padding: 16px 24px; border-radius: 12px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    font-size: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                    animation: slideInRight 0.3s ease-out; max-width: 320px;
                `;

        updateToast.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 24px;">üéÆ</div>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 4px;">Game Update Available</div>
                            <div style="font-size: 12px; opacity: 0.9;">
                                Refreshing in <span id="mga-countdown">${countdown}</span>s...
                            </div>
                        </div>
                    </div>
                `;

        document.body.appendChild(updateToast);

        // Update countdown every second
        const countdownInterval = setInterval(() => {
          countdown--;
          const countdownEl = document.getElementById('mga-countdown');
          if (countdownEl) {
            countdownEl.textContent = countdown;
          }
          if (countdown <= 0) {
            clearInterval(countdownInterval);
          }
        }, 1000);

        // Auto-refresh after 5 seconds
        setTimeout(() => {
          if (typeof productionLog === 'function') {
            productionLog('[WebSocket] Auto-refreshing for game update...');
          }
          window.location.reload();
        }, 5000);

        return;
      }

      // Only reconnect for 1006 (abnormal) or if reason mentions update
      if (wasClean && code !== 1006 && !/update/i.test(reason || '')) {
        if (typeof productionLog === 'function') {
          productionLog('[WebSocket] Clean close detected - no reconnect needed');
        }
        return;
      }

      // Clear any existing timer
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }

      // Check if max attempts exceeded
      if (attempts >= MAX_ATTEMPTS) {
        if (typeof productionWarn === 'function') {
          productionWarn(`[WebSocket] Max reconnect attempts (${MAX_ATTEMPTS}) reached - manual refresh required`);
        }
        showFailureToast();
        return;
      }

      // Exponential backoff: 1s, 2s, 4s, 8s, 15s, 15s
      const wait = Math.min(1000 * Math.pow(2, attempts), 15000);
      attempts++;

      if (typeof productionLog === 'function') {
        productionLog(
          `[WebSocket] Reconnect attempt ${attempts}/${MAX_ATTEMPTS} in ${wait}ms (code: ${code}, reason: "${reason || 'none'}")`
        );
      }

      // Show user feedback
      showReconnectToast(attempts, MAX_ATTEMPTS, wait);

      reconnectTimer = setTimeout(() => {
        try {
          // Add timestamp to force reload and bypass cache
          const u = new URL(location.href);
          u.searchParams.set('_mgtp', Date.now().toString());

          // Platform-specific reload strategy
          if (isDiscord && isIframe) {
            // Discord iframe: try parent reload first
            try {
              window.parent.location.reload();
            } catch (e) {
              // Fallback to self reload if parent is inaccessible
              location.replace(u.toString());
            }
          } else if (isMobile) {
            // Mobile: hard reload to clear any cached state
            location.href = u.toString();
          } else {
            // Desktop: use replace to avoid back button issues
            location.replace(u.toString());
          }
        } catch (e) {
          if (typeof productionError === 'function') {
            productionError('[WebSocket] Reload failed:', e);
          }
          // Last resort: simple reload
          location.href = location.href + '?_t=' + Date.now();
        }
      }, wait);
    }

    // Patch WebSocket constructor
    window.WebSocket = function (url, protocols) {
      const ws = new Native(url, protocols);

      // Reset attempts on successful connection
      ws.addEventListener('open', () => {
        if (typeof productionLog === 'function') {
          productionLog('[WebSocket] Connection established successfully');
        }
        attempts = 0;
        userNotified = false;

        // Remove any reconnect toasts
        const toast = document.getElementById('mga-reconnect-toast');
        if (toast) toast.remove();
      });

      // Handle close events
      ws.addEventListener('close', e => {
        if (typeof productionLog === 'function') {
          productionLog(`[WebSocket] Closed - Code: ${e.code}, Clean: ${e.wasClean}, Reason: "${e.reason || 'none'}"`);
        }
        scheduleReload(e.code, e.wasClean, e.reason);
      });

      // Handle errors
      ws.addEventListener('error', e => {
        if (typeof productionError === 'function') {
          productionError('[WebSocket] Error detected:', e);
        }
      });

      return ws;
    };

    // Preserve prototype and static properties
    Object.setPrototypeOf(window.WebSocket, Native);
    window.WebSocket.prototype = Native.prototype;
    window.WebSocket.__mgtoolsPatched = true;

    // Network state listeners for smarter reconnection
    window.addEventListener('online', () => {
      if (typeof productionLog === 'function') {
        productionLog('[Network] Back online - reducing reconnect attempt counter');
      }
      attempts = Math.max(0, attempts - 2); // Give extra chances when network returns

      // If we have a toast, update it
      const toast = document.getElementById('mga-reconnect-toast');
      if (toast) toast.remove();
    });

    window.addEventListener('offline', () => {
      if (typeof productionWarn === 'function') {
        productionWarn('[Network] Offline detected - pausing reconnection attempts');
      }
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }

      // Update toast if visible
      const toast = document.getElementById('mga-reconnect-toast');
      if (toast) {
        toast.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 24px;">üì°</div>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 4px;">Network Offline</div>
                            <div style="font-size: 12px; opacity: 0.9;">
                                Reconnection paused<br>Waiting for network...
                            </div>
                        </div>
                    </div>
                `;
      }
    });

    if (typeof productionLog === 'function') {
      productionLog('‚úÖ [WebSocket] Enhanced auto-reconnect system initialized (max attempts: ' + MAX_ATTEMPTS + ')');
    }
  })();

  // ==================== DOM UPDATE DETECTION (BACKUP METHOD) ====================
  // BUGFIX v3.7.8: Re-enabled with smarter detection to avoid false positives
  (function () {
    let updateDetected = false; // Shared flag to prevent duplicate refreshes

    function checkForGameUpdatePopup() {
      if (updateDetected) return false;

      // Look for Chakra UI alert dialog (game's update modal)
      const popup = document.querySelector('section.chakra-modal__content[role="alertdialog"]');
      if (!popup) return false;

      // Ensure it's not an MGTools element
      if (popup.closest('.mga-overlay, .mgh-sidebar, .mgh-dock, .mga-popout')) {
        return false;
      }

      // Check for game update text in header
      const header = popup.querySelector('header.chakra-modal__header');
      if (header && /game update available/i.test(header.textContent)) {
        updateDetected = true;
        if (typeof productionLog === 'function') {
          productionLog('[DOM] Game update popup detected - attempting auto-click CONTINUE button');
        }

        // Find and click the CONTINUE button before reloading
        const continueBtn = popup.querySelector('button');
        if (continueBtn && /continue/i.test(continueBtn.textContent)) {
          if (typeof productionLog === 'function') {
            productionLog('[DOM] Clicking CONTINUE button...');
          }
          continueBtn.click();

          // Small delay to let the click process, then trigger reload
          setTimeout(() => {
            if (typeof productionLog === 'function') {
              productionLog('[DOM] CONTINUE clicked - triggering refresh');
            }
            // Trigger the same refresh logic as WebSocket code 4710
            if (typeof scheduleReload === 'function') {
              scheduleReload(4710, true, 'DOM detection after button click');
            }
          }, 500);
        } else {
          // Fallback: if button not found, proceed with immediate reload
          if (typeof productionLog === 'function') {
            productionLog('[DOM] CONTINUE button not found - proceeding with immediate refresh');
          }
          // Trigger the same refresh logic as WebSocket code 4710
          if (typeof scheduleReload === 'function') {
            scheduleReload(4710, true, 'DOM detection');
          }
        }
        return true;
      }

      return false;
    }

    // MutationObserver to watch for popup appearance
    const observer = new MutationObserver(() => {
      if (!updateDetected) {
        checkForGameUpdatePopup();
      }
    });

    observer.observe(document.body, { childList: true, subtree: true });

    // Periodic check as backup (every 10 seconds - performance optimized)
    setInterval(checkForGameUpdatePopup, 10000);

    if (typeof productionLog === 'function') {
      productionLog('‚úÖ [DOM] Game update popup monitor initialized');
    }
  })();
})();

/* MGTOOLS_MERGE_BLOCK_v1 */

/* 1) Ability Logs: ghost-free hard clear with tombstone and writers lifting the flag */
(function () {
  const LOG_MAIN = 'MGA_petAbilityLogs';
  const LOG_ARCH = 'MGA_petAbilityLogs_archive';
  const FLAG = 'MGA_logs_manually_cleared';

  function gmGet(k, d = null) {
    try {
      const raw = typeof GM_getValue === 'function' ? GM_getValue(k, null) : null;
      if (raw == null) return d;
      return typeof raw === 'string' ? JSON.parse(raw) : raw;
    } catch {
      return d;
    }
  }
  function gmSet(k, v) {
    try {
      if (typeof GM_setValue === 'function') GM_setValue(k, JSON.stringify(v));
    } catch {}
  }

  // Enforce tombstone on read paths (localStorage + GM)
  try {
    const _get = Storage.prototype.getItem;
    if (!_get.__mgtoolsPatched) {
      Storage.prototype.getItem = function (k) {
        if ((k === LOG_MAIN || k === LOG_ARCH) && localStorage.getItem(FLAG) === 'true') return '[]';
        return _get.apply(this, arguments);
      };
      Storage.prototype.getItem.__mgtoolsPatched = true;
    }
  } catch {}

  try {
    if (typeof GM_getValue === 'function' && !GM_getValue.__mgtoolsPatched) {
      const _gm = GM_getValue;
      window.GM_getValue = function (k, d) {
        if ((k === LOG_MAIN || k === LOG_ARCH) && localStorage.getItem(FLAG) === 'true') return '[]';
        return _gm.apply(this, arguments);
      };
      window.GM_getValue.__mgtoolsPatched = true;
    }
  } catch {}

  try {
    if (typeof GM_setValue === 'function' && !GM_setValue.__mgtoolsPatched) {
      const _gm = GM_setValue;
      window.GM_setValue = function (k, v) {
        if (k === LOG_MAIN) {
          try {
            const arr = Array.isArray(v) ? v : typeof v === 'string' ? JSON.parse(v) : [];
            if (arr && arr.length) localStorage.removeItem(FLAG);
          } catch {}
        }
        return _gm.apply(this, arguments);
      };
      window.GM_setValue.__mgtoolsPatched = true;
    }
  } catch {}

  function hardClear() {
    try {
      localStorage.setItem(FLAG, 'true');
      gmSet(LOG_MAIN, []);
      gmSet(LOG_ARCH, []);
      try {
        localStorage.removeItem(LOG_MAIN);
        localStorage.removeItem(LOG_ARCH);
      } catch {}
      if (window.UnifiedState?.data) window.UnifiedState.data.petAbilityLogs = [];
      if (Array.isArray(window.petAbilityLogs)) window.petAbilityLogs.length = 0;
    } catch (e) {
      console.error('[MGTools] hardClear logs failed', e);
    }
  }
  window.MGTOOLS_hardClearAbilityLogs = hardClear;

  document.addEventListener(
    'click',
    ev => {
      const t =
        ev.target &&
        ev.target.closest(
          '#clear-ability-logs,[data-role="clear-ability-logs"],[data-action="clear-ability-logs"],[data-mga-clear-logs],#mga-clear-logs'
        );
      if (t) {
        hardClear();
      }
    },
    true
  );

  // REMOVED v3.7.8: Startup sanitizer was preventing ability logs from persisting
  // The sanitizer ran for 16 seconds and cleared logs even after new abilities were added
  // Proper flag management already exists in the proxy (line 26681-26685)
})();

/* WebSocket reconnect handled by enhanced implementation above (lines 22603+) */
